---
slug: the-need-for-a-new-language
title: The need for a new language
authors: [pgte]
tags: [deci, low-code, no-code, programming, language, spreadsheets, numbers]
---

In the quest of helping to democratize and simplify access to quantitative modeling and analysis, we have created the Deci language and Decipad. Today I'll let you know some of the reasons behind how the current tools are lacking in some important aspects, but first we will need a bit of historical context.

## A small slice of history

Computers started as custom-purpose calculation machines. Initially they were hardware that was built with a single purpose (like to calculate the trajectory of a bullet, decrypt a message or predict tides). But soon, as hardware progressed, people started building generic-purpose computers. Before these, the inputs you gave a computer _were_ the program, but with the new multi-purpose and generic computers, they were programmable. Not only the inputs could change, but also the nature of the computation could change without changing the hardware.

The language of programming a computer evolved from setting some switches to storing some machine code in a piece of memory. The CPU would run the program in that memory and performed the low-level hardware operations that it dictated.

But programming these computers was difficult: you had to know many details of the hardware this **software** would be running on, and you had to provide the instructions in a way that the computer would understand: in the form of binary-encoded numbers that were then decoded by the hardware. This was no easy task.

To help with that, people created assembly languages. Instead of the number of the operation, you would write the name of that operation, and instead of the number of the register, you would write the name of the register, and so on. This language was then translated into the machine code the computer could run.

But even with assembly languages, programming was a hard task. The programmer still needed to understand the hardware very well and all the operations that that CPU supported. Also, it was verbose: for instance, in order to perform a relatively simple arithmetic operation, you had to create many complex lines of assembly code.

Then the first so-called high-level languages like COBOL or FORTRAN appeared. These were languages that allowed the programmer to be more terse and made the program easier to understand, but still required highly specialized individuals to be trained and paid to program.

Since then, many other so-called high-level languages have appeared, each one specialized in different areas. Some were more approachable and more forgiving (like Python or Ruby), and others were more powerful and performant (like C), but less helpful and forgiving in their nature.

## Spreadsheets and the democratization of programming

In 1979 Visicalc was released. It ran on Apple II computers and was the first spreadsheet program. Instantly, Visicalc demonstrated the utility of personal computers. When running, it introduced a matrix where the user could input numbers on each cell. The user also could, instead of a number, use a formula containing other cells as arguments.

Now, with spreadsheet software, tasks that used to take many hours by hand or that required a specialized programmer to create on an expensive computer, was available on an affordable personal computer to anyone that knew how to type and input formulas.

With Visicalc and all the following spreadsheet applications, people built many different types of application: data entry, payroll, taxes, accounting, operational planning, logistics, forecasts and many others. At the time (and still today) this revolution allowed businesses and people to defer the cost of an expensive off-the-shelf or a custom-built piece of software, permitting the common user to quickly create and adapt the software to their needs.

This revolution has had many benefits, but also it came with some problems. Before we analyze some of those problems, let's first see what types of tasks and problems people typically build software for.

## The tasks of a program

There are many different tasks and purposes that people build software for, but they generally fit in a small set of buckets. Here I touch in some of those buckets that are more relevant to this conversation:

### Creating models

One of the ways that people use software is to model past, present or future reality. These models then may be used to plan, to create forecasts or to create different scenarios so that they can make a decision.

### Analyzing

In this mode, people use computers to analyze the past, with different purposes. They may want to extract the behavior of a system in order to make better predictions, or they may want to extract indicators that will help them make decisions.

### Communicate

People need to communicate with one another in many and varying forms. Messaging, social networks, and e-mail applications fall into this category. But also tools like Word or Powerpoint, they're used for communicating, either with your future self or with others.

## Some of the problems

### The context behind a number

When either using a traditional programming language or spreadsheets, people use numbers. These numbers represent a certain quantity of a subject (like the amount of sugar in a beverage, the office area, the number of kilograms of wheat, the amount of value of an asset, the percentage of a transaction fee, etc.). So numbers have an implicit unit (square meters, dollars, kilograms, ratio of money, etc.) and an implicit subject (grain of wheat, medicine, salary, office space, a transaction, etc.).

But again, in traditional programming languages, numbers are treated as pure numbers without much context. This makes the programs more error-prone (to unit conversion errors, to scale errors, to subject errors). These errors may lead to loss of value, loss of human lives, the loss of space probes ad many other evitable consequences if the system understood the unit and subject of the quantity these numbers refer to.

**We need a way to tell the computer some of the meaning and context behind the numbers, and let the computer do the rest.**

### One to many

Let's see an example: if you're modeling the cost of office space, you may want to model the average value of office space per unit of area in a certain city. So the way that we're modelling that cost (dollars per month per square meter of office space) is a single number.

Then you may model the monthly cost of business as a sum of many factors, one of them being the cost of office space, which is the total area of office space multiplied by the monthly cost of office space per unit of area.

But say that you're modeling an enterprise and that that enterprise may have a varying number of employees occupying that office space. In this model, you may want to model the amount of office space as a function of the number of employees (say 10 square meters per employee). Now the amount of office space is no longer a single number, but it's a relation between the number of employees and the cost of a unit of office space area.And now, the number of employees varies with time. Also now, the need of office space varies with time and the cost of office space varies with it.

As we make the model more complex, numbers are turned into relations of different quantities, becoming a multi-dimensional set of numbers.

But yet, the equation with started from (office cost is office space times the office cost per area) still holds. We shouldn't have to change it as we make the model more complex. But this is what happens with traditional programming languages. Multiplying a multi-dimensional quantity with another multi-dimensional quantity is different from multiplying two numbers. But why?

That happens because the software does not let us declare relations between entities. Instead it's imperative, where we encode each one of the small calculations ourselves. Again, the software does not have that information about the relationships between these entities, and the programmer or spreadsheet author has then to change all the calculations accordingly. Not only this is more complex and time-consuming, it's also error-prone.

The way that we make our models is against this. First we start with a simple model and then make it more complex. But usually, adding complexity to the model means redoing a part of our program. We need a better way.

**We don't relate numbers. We relate concepts. These concepts may be numbers or relations between other concepts.**

### Collaborating

As we mentioned here, spreadsheets have been a huge force for democratizing the access to computation, modeling and analysis.
As we make the models in our spreadsheets more complex, we quickly fall prey of that spreadsheet. No longer someone other than the author of that spreadsheet is able to understand it without having to sit down with the author and go through all the meaning, knowledge and intricacies behind that spreadsheet.

Also, a spreadsheet has no natural flow. A new person is not able to easily understand where to start, as it jumps and **hides** all the relationships between all the cells. A serious effort must be done to decode the spreadsheet and the context, meaning and relations behind all the numbers in it.

Also, spreadsheets have no inherent good way of collaborating across documents. Spreadsheets can hardly be reused (other than making copies of it), and they cannot easily embed data and calculations from other spreadsheets (without a good effort and knowledge of programming).

**We need a better and more transparent way for people to collaborate, to take data and calculations out of their silos and allow people to communicate and reuse them easily.**

### Communicating

Many many times, complex spreadsheets are not used to communicate to other people. Instead, their values or graphics are extracted and embedded in a document, e-mail or Powerpoint presentation. They lose their provenance, and there's no good way for the recipient of that message to validate the process or correction of the data that they're being presented with. They're getting a value out of context in a static document.

Imagine if the medium that you communicated in was also the medium in which the calculations and data lived in. All the data would be traceable to its origin, and easily understood with with minimal effort by anyone with enough diligence.

**Documents like these are not meant to be static. These documents are meant to be living things, updated in real-time, created, changed and consumed by many people collaborating with each other.**

---

In future articles we'll go over the details of how this language and product deals with these and other issues, and we'll also touch some other aspects like dealing with dates, uncertain values and some other data types. Stay tuned!
