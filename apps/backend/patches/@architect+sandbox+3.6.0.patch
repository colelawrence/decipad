diff --git a/node_modules/@architect/sandbox/src/invoke-lambda/nodelambda/invoke.js b/node_modules/@architect/sandbox/src/invoke-lambda/nodelambda/invoke.js
new file mode 100644
index 0000000..aca9a7c
--- /dev/null
+++ b/node_modules/@architect/sandbox/src/invoke-lambda/nodelambda/invoke.js
@@ -0,0 +1,82 @@
+const { workerFor } = require('./workers');
+
+module.exports = function invokeByRunning(params, callback) {
+  const { options, request, timeout, update } = params;
+  const { env, cwd } = options;
+  const functionPath = `${cwd}/index.js`;
+  const headers = {
+    'content-type': 'text/html; charset=utf8;',
+    'cache-control':
+      'no-cache, no-store, must-revalidate, max-age=0, s-maxage=0',
+  };
+  let returned = false;
+
+  const event = JSON.parse(request);
+  const worker = workerFor(functionPath, env, update);
+  worker.work(event, (err, response) => {
+    returned = true;
+    done(err, response);
+  });
+
+  // Set an execution timeout
+  const to = setTimeout(function timedOut() {
+    const duration = `${timeout / 1000}s`;
+    update.warn(
+      `${functionPath} timed out after hitting its ${duration} timeout!`
+    );
+    done(new Error(`${duration} timeout`));
+  }, timeout);
+
+  // End execution
+  function done(error, response) {
+    clearTimeout(to); // ensure the timeout doesn't block
+    if (error) {
+      callback(null, {
+        statusCode: 502,
+        headers,
+        body: `<h1>Requested function is missing or not defined, or unknown error</h1>
+        <p>${error}</p>
+        `,
+      });
+    } else if (returned) {
+      const apiType = process.env.ARC_API_TYPE;
+      if (apiType === 'http') {
+        callback(null, response);
+      } else if (response) {
+        // If it's an error pretty print it
+        if (response.name && response.message && response.stack) {
+          response.body = `
+          <h1>${response.name}</h1>
+          <p>${response.message}</p>
+          <pre>${response.stack}</pre>
+          `;
+          response.code = 500;
+          response.type = 'text/html';
+        }
+        // otherwise just return the command line
+        callback(null, response);
+      } else {
+        callback(null, {
+          statusCode: 500,
+          headers,
+          body: `<h1>Async error</h1>
+<p><strong>Lambda <code>${functionPath}</code> ran without executing the completion callback or returning a value.</strong></p>
+
+<p>Dependency-free functions, or functions that use <code>@architect/functions arc.http.async()</code> must return a correctly formatted response object.</p>
+
+<p>Functions that utilize <code>@architect/functions arc.http()</code> must ensure <code>res</code> gets called</p>
+
+<p>Learn more about <a href="https://arc.codes/primitives/http">dependency-free responses</a>, or about using <code><a href="https://arc.codes/reference/functions/http/node/classic">arc.http()</a></code> and <code><a href="https://arc.codes/reference/functions/http/node/async">arc.http.async()</a></code></p>.
+          `,
+        });
+      }
+    } else {
+      callback(null, {
+        statusCode: 500,
+        headers,
+        body: `<h1>Error</h1>
+        <p>Process exited<p>`,
+      });
+    }
+  }
+};
diff --git a/node_modules/@architect/sandbox/src/invoke-lambda/nodelambda/run.js b/node_modules/@architect/sandbox/src/invoke-lambda/nodelambda/run.js
new file mode 100644
index 0000000..017ab7c
--- /dev/null
+++ b/node_modules/@architect/sandbox/src/invoke-lambda/nodelambda/run.js
@@ -0,0 +1,67 @@
+/* eslint-disable no-console */
+const { parentPort, workerData } = require('worker_threads');
+const { join } = require('path');
+const { existsSync: exists, readFileSync: read } = require('fs');
+
+const { arcConfig, arcContext, functionPath } = workerData;
+
+const { handlerFunction, shared } = arcConfig;
+const context = arcContext;
+const cwd = process.cwd();
+const fn = loadFunction();
+
+/* Enumerate package files */
+const pkg = (dir) =>
+  exists(join(dir, 'package.json')) &&
+  JSON.parse(read(join(dir, 'package.json')));
+const lambdaPackage = pkg(cwd);
+
+const debug = [{ note: 'Execution metadata', cwd, lambdaPackage, shared }];
+
+function callback(err, result) {
+  if (err) console.log(err);
+  const payload = err
+    ? { name: err.name, message: err.message, stack: err.stack }
+    : result;
+  if (payload) payload.__DEP_ISSUES__ = [];
+  if (payload) payload.__DEP_DEBUG__ = debug;
+
+  parentPort.postMessage(payload);
+}
+
+parentPort.on('message', (event) => {
+  let calledback = false;
+  const callbackGuard = (err, result) => {
+    if (!calledback) {
+      calledback = true;
+      callback(err, result);
+    }
+  };
+  const result = fn(event, context, callbackGuard);
+  if (result instanceof Promise) {
+    result
+      .then((res) => callbackGuard(null, res))
+      .catch((err) => callbackGuard(err));
+  } else if (typeof result !== 'undefined') {
+    callbackGuard(null, result);
+  }
+});
+
+parentPort.postMessage('ready');
+
+function loadFunction() {
+  try {
+    // eslint-disable-next-line import/no-dynamic-require
+    const func = require(functionPath)[handlerFunction]; // eslint-disable-line global-require
+    if (typeof func !== 'function') {
+      throw new Error(
+        `${functionPath} is not a function: ${typeof func}, ${func}`
+      );
+    }
+
+    return func;
+  } catch (err) {
+    console.error(err);
+    throw err;
+  }
+}
diff --git a/node_modules/@architect/sandbox/src/invoke-lambda/nodelambda/workers.js b/node_modules/@architect/sandbox/src/invoke-lambda/nodelambda/workers.js
new file mode 100644
index 0000000..1df9a08
--- /dev/null
+++ b/node_modules/@architect/sandbox/src/invoke-lambda/nodelambda/workers.js
@@ -0,0 +1,117 @@
+const { Worker } = require('worker_threads');
+const assert = require('assert');
+const watch = require('node-watch');
+
+const workerPath = `${__dirname}/run.js`;
+const workers = new Map();
+
+function createWorkerFor(functionName, env, update) {
+  const workQueue = [];
+  const replyQueue = [];
+
+  const workerData = {
+    arcConfig: JSON.parse(env.__ARC_CONFIG__),
+    arcContext: JSON.parse(env.__ARC_CONTEXT__),
+    functionPath: functionName,
+  };
+
+  const workerOptions = {
+    env,
+    workerData,
+    stdout: true,
+    stderr: true,
+  };
+
+  const fn = {
+    worker: new Worker(workerPath, workerOptions),
+    ready: false,
+    working: false,
+    terminating: false,
+    work,
+  };
+
+  const w = watch(functionName, () => {
+    update.status(`function ${functionName} changed`);
+    w.close();
+    fn.terminating = true;
+    fn.worker.terminate();
+  });
+
+  fn.worker.on('message', (message) => {
+    if (message === 'ready') {
+      assert(!fn.ready, 'worker is already ready');
+      fn.ready = true;
+      maybeWork();
+      return;
+    }
+    assert(fn.ready, 'should be ready when getting a response message');
+    assert(
+      fn.working,
+      'worker should be working when getting a response message'
+    );
+    replyWith(null, message);
+  });
+
+  fn.worker.once('error', (err) => {
+    update.error(`worker ${functionName} error:\n${err.stack}`);
+    while (replyQueue.length > 0) {
+      replyWith(err);
+    }
+  });
+
+  fn.worker.once('exit', () => {
+    let err;
+    if (!fn.terminating) {
+      update.error(`worker exited prematurely: ${functionName} `, functionName);
+      err = new Error('Worker exited prematurely');
+    } else {
+      err = new Error('Worker exited without reply');
+      update.status(`worker exited: ${functionName} `, functionName);
+    }
+    while (replyQueue.length > 0) {
+      replyWith(err);
+    }
+    workers.delete(functionName);
+  });
+
+  fn.worker.stderr.on('data', (d) => {
+    update.error(`${functionName}:\n${d}`);
+  });
+  fn.worker.stdout.on('data', (d) => {
+    update.status(`${functionName}:\n${d}`);
+  });
+
+  return fn;
+
+  function maybeWork() {
+    if (workQueue.length === 0 || !fn.ready || fn.working) {
+      return;
+    }
+    fn.working = true;
+    const nextWork = workQueue.splice(0, 1)[0];
+    fn.worker.postMessage(nextWork);
+  }
+
+  function replyWith(error, response) {
+    fn.working = false;
+    const reply = replyQueue.splice(0, 1)[0];
+    reply(error, response);
+    maybeWork();
+  }
+
+  function work(request, callback) {
+    workQueue.push(request);
+    replyQueue.push(callback);
+    maybeWork();
+  }
+}
+
+module.exports.workerFor = function workerFor(functionName, env, update) {
+  let fn = workers.get(functionName);
+  if (!fn) {
+    fn = createWorkerFor(functionName, env, update);
+    workers.set(functionName, fn);
+  }
+
+  return fn;
+};
diff --git a/node_modules/@architect/sandbox/src/invoke-lambda/run-in-node.js b/node_modules/@architect/sandbox/src/invoke-lambda/run-in-node.js
index f788df1..6474c5e 100644
--- a/node_modules/@architect/sandbox/src/invoke-lambda/run-in-node.js
+++ b/node_modules/@architect/sandbox/src/invoke-lambda/run-in-node.js
@@ -1,13 +1 @@
-let load = require('./runtimes/_loader')
-let spawn = require('./spawn')
-
-module.exports = function runInNode (params, callback) {
-  let { node } = load()
-  let minify = script => '"' + script.replace(/\n/g, '').trim() + '"'
-  let script = minify(node)
-  spawn({
-    command: 'node',
-    args: [ '-e', script ],
-    ...params,
-  }, callback)
-}
+module.exports = require('./nodelambda/invoke');
