{"version":3,"file":"static/js/7082.8c9fd82c.chunk.js","mappings":"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","sources":["../../fnqueue/src/fn-queue.ts","../../slate-yjs/src/applyToSlate/index.ts","../../slate-yjs/src/applyToSlate/arrayEvent.ts","../../slate-yjs/src/applyToSlate/mapEvent.ts","../../slate-yjs/src/applyToSlate/textEvent.ts","../../slate-yjs/src/path/index.ts","../../slate-yjs/src/applyToYjs/node/index.ts","../../slate-yjs/src/applyToYjs/node/insertNode.ts","../../slate-yjs/src/applyToYjs/node/mergeNode.ts","../../slate-yjs/src/applyToYjs/node/moveNode.ts","../../slate-yjs/src/applyToYjs/node/removeNode.ts","../../slate-yjs/src/applyToYjs/node/setNode.ts","../../slate-yjs/src/applyToYjs/node/splitNode.ts","../../slate-yjs/src/applyToYjs/text/index.ts","../../slate-yjs/src/applyToYjs/text/insertText.ts","../../slate-yjs/src/applyToYjs/text/removeText.ts","../../slate-yjs/src/applyToYjs/index.ts","../../slate-yjs/src/model/index.ts","../../slate-yjs/src/utils/clone.ts","../../slate-yjs/src/utils/convert.ts","../../y-websocket/src/receive/version1.ts","../../message-packer/src/receiver.ts","../../y-websocket/src/receive/version2.ts","../../y-websocket/src/types.ts"],"sourcesContent":["type AsyncFunction<T> = () => Promise<T>;\ntype Fn<T> = (value: T) => void;\n\ntype FunctionQueue = {\n  push: <T>(fn: AsyncFunction<T>) => Promise<T>;\n  flush: () => Promise<unknown>;\n  pendingCount: () => number;\n};\n\nexport function fnQueue(): FunctionQueue {\n  const fns: AsyncFunction<unknown>[] = [];\n  let processing = 0;\n  const flushes: Fn<void>[] = [];\n\n  async function processOne() {\n    const fn = fns.shift();\n    if (!fn) {\n      throw new Error('Expected to have a function left in the queue');\n    }\n\n    return fn();\n  }\n\n  async function work() {\n    if (processing === 0 && fns.length > 0) {\n      processing += 1;\n      try {\n        await processOne();\n      } finally {\n        processing -= 1;\n      }\n      work();\n    } else if (processing === 0 && fns.length === 0) {\n      while (flushes.length) {\n        // just checked length\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const resolveFlush = flushes.shift()!;\n        resolveFlush();\n      }\n    }\n  }\n\n  function push<T>(fn: AsyncFunction<T>): Promise<T> {\n    let resolve: Fn<T>;\n    let reject: Fn<Error>;\n    const p = new Promise<T>((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    fns.push(async () => {\n      try {\n        resolve(await fn());\n      } catch (err) {\n        reject(err as Error);\n      }\n    });\n    work();\n\n    return p;\n  }\n\n  async function flush() {\n    if (fns.length === 0 && processing === 0) {\n      return undefined;\n    }\n    return new Promise((resolve) => {\n      flushes.push(resolve);\n    });\n  }\n\n  function pendingCount() {\n    return fns.length;\n  }\n\n  return {\n    push,\n    flush,\n    pendingCount,\n  };\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  findNode,\n  setSelection,\n  TOperation,\n  withoutNormalizing,\n} from '@udecode/plate';\nimport * as Y from 'yjs';\nimport { YjsEditor } from '@decipad/slate-yjs';\nimport translateArrayEvent from './arrayEvent';\nimport translateMapEvent from './mapEvent';\nimport translateTextEvent from './textEvent';\n\n/**\n * Translates a Yjs event into slate editor operations.\n *\n * @param event\n */\nexport function translateYjsEvent(\n  editor: YjsEditor,\n  event: Y.YEvent<any>\n): TOperation[] {\n  if (event instanceof Y.YArrayEvent) {\n    return translateArrayEvent(editor, event);\n  }\n\n  if (event instanceof Y.YMapEvent) {\n    return translateMapEvent(editor, event);\n  }\n\n  if (event instanceof Y.YTextEvent) {\n    return translateTextEvent(editor, event);\n  }\n\n  throw new Error('Unsupported yjs event');\n}\n\n/**\n * Applies multiple yjs events to a slate editor.\n */\nexport function applyYjsEvents(\n  editor: YjsEditor,\n  events: Y.YEvent<any>[]\n): void {\n  const { selection } = editor;\n  withoutNormalizing(editor, () => {\n    events.forEach((event) =>\n      translateYjsEvent(editor, event).forEach(editor.apply)\n    );\n    if (selection) {\n      const { anchor, focus } = selection;\n      for (const point of [anchor, focus]) {\n        const node = findNode(editor, { at: point });\n        if (!node) {\n          setSelection(editor, { anchor: undefined, focus: undefined });\n        }\n      }\n    }\n  });\n}\n","import { getNode, isText, TDescendant, TNodeOperation } from '@udecode/plate';\nimport invariant from 'tiny-invariant';\nimport * as Y from 'yjs';\nimport { MyElement } from '@decipad/editor-types';\nimport { YjsEditor } from '@decipad/slate-yjs';\nimport { SyncElement } from '../model';\nimport { toSlateNode, toSlatePath } from '../utils/convert';\n\n/**\n * Translates a Yjs array event into a slate operations.\n */\nexport default function translateArrayEvent(\n  editor: YjsEditor,\n  event: Y.YArrayEvent<SyncElement>\n): TNodeOperation[] {\n  const targetPath = toSlatePath(event.path);\n  const targetElement = getNode<MyElement>(editor, targetPath);\n  if (!targetElement) return [];\n\n  invariant(!isText(targetElement), 'Cannot apply array event to text node');\n\n  let offset = 0;\n  const ops: TNodeOperation[] = [];\n  const children = Array.from(targetElement.children as TDescendant[]);\n\n  event.changes.delta.forEach((delta) => {\n    if ('retain' in delta) {\n      offset += delta.retain ?? 0;\n    }\n\n    if ('delete' in delta) {\n      const path = [...targetPath, offset];\n      children.splice(offset, delta.delete ?? 0).forEach((node) => {\n        ops.push({ type: 'remove_node', path, node });\n      });\n    }\n\n    if ('insert' in delta) {\n      invariant(\n        Array.isArray(delta.insert),\n        `Unexpected array insert content type: expected array, got ${JSON.stringify(\n          delta.insert\n        )}`\n      );\n\n      const toInsert = delta.insert.map(toSlateNode) as TDescendant[];\n\n      toInsert.forEach((node, i) => {\n        ops.push({\n          type: 'insert_node',\n          path: [...targetPath, offset + i],\n          node,\n        });\n      });\n\n      children.splice(offset, 0, ...toInsert);\n      offset += delta.insert.length;\n    }\n  });\n\n  return ops;\n}\n","import { getNode, TNodeOperation } from '@udecode/plate';\nimport * as Y from 'yjs';\nimport { YjsEditor } from '@decipad/slate-yjs';\nimport { SyncElement } from '../model';\nimport { toSlatePath } from '../utils/convert';\n\n/**\n * Translates a Yjs map event into a slate operations.\n *\n * @param event\n */\nexport default function translateMapEvent(\n  editor: YjsEditor,\n  event: Y.YMapEvent<unknown>\n): TNodeOperation[] {\n  const targetPath = toSlatePath(event.path);\n  const targetSyncElement = event.target as SyncElement;\n  const targetElement = getNode(editor, targetPath);\n  if (!targetElement) {\n    return [];\n  }\n\n  const keyChanges = Array.from(event.changes.keys.entries());\n  const newProperties = Object.fromEntries(\n    keyChanges.map(([key, info]) => [\n      key,\n      info.action === 'delete' ? null : targetSyncElement.get(key),\n    ])\n  );\n\n  const properties = Object.fromEntries(\n    keyChanges.map(([key]) => [\n      key,\n      (targetElement as unknown as Record<string, unknown>)[key],\n    ])\n  );\n\n  return [{ type: 'set_node', newProperties, properties, path: targetPath }];\n}\n","import { getNode, isText, TTextOperation } from '@udecode/plate';\nimport invariant from 'tiny-invariant';\nimport * as Y from 'yjs';\nimport { YjsEditor } from '@decipad/slate-yjs';\nimport { toSlatePath } from '../utils/convert';\n\n/**\n * Translates a Yjs text event into a slate operations.\n *\n * @param event\n */\nexport default function translateTextEvent(\n  editor: YjsEditor,\n  event: Y.YTextEvent\n): TTextOperation[] {\n  const targetPath = toSlatePath(event.path);\n  const targetText = getNode(editor, targetPath);\n\n  invariant(isText(targetText), 'Cannot apply text event to non-text node');\n\n  let offset = 0;\n  let { text } = targetText;\n  const ops: TTextOperation[] = [];\n\n  event.changes.delta.forEach((delta) => {\n    if ('retain' in delta) {\n      offset += delta.retain ?? 0;\n    }\n\n    if ('delete' in delta) {\n      const endOffset = offset + (delta.delete ?? 0);\n\n      ops.push({\n        type: 'remove_text',\n        offset,\n        path: targetPath,\n        text: text.slice(offset, endOffset),\n      });\n\n      text = text.slice(0, offset) + text.slice(endOffset);\n    }\n\n    if ('insert' in delta) {\n      invariant(\n        typeof delta.insert === 'string',\n        `Unexpected text insert content type: expected string, got ${typeof delta.insert}`\n      );\n\n      ops.push({\n        type: 'insert_text',\n        offset,\n        text: delta.insert,\n        path: targetPath,\n      });\n\n      offset += delta.insert.length;\n      text = text.slice(0, offset) + delta.insert + text.slice(offset);\n    }\n  });\n\n  return ops;\n}\n","import { Path } from 'slate';\nimport invariant from 'tiny-invariant';\nimport * as Y from 'yjs';\nimport { SharedType, SyncElement, SyncNode } from '../model';\nimport { toSlateDoc } from '../utils/convert';\n\nconst isTree = (node: SyncNode): boolean => !!SyncNode.getChildren(node);\n\n/**\n * Returns the SyncNode referenced by the path\n *\n * @param doc\n * @param path\n */\nexport function getTarget(doc: SharedType, path: Path): SyncNode {\n  function iterate(current: SyncNode, idx: number) {\n    const children = SyncNode.getChildren(current);\n\n    if (!isTree(current) || !children?.get(idx)) {\n      throw new TypeError(\n        `path ${path.toString()} does not match doc ${JSON.stringify(\n          toSlateDoc(doc)\n        )}`\n      );\n    }\n\n    return children.get(idx);\n  }\n\n  return path.reduce<SyncNode>(iterate, doc);\n}\n\nfunction getParentPath(path: Path, level = 1): [number, Path] {\n  if (level > path.length) {\n    throw new TypeError('requested ancestor is higher than root');\n  }\n\n  return [path[path.length - level], path.slice(0, path.length - level)];\n}\n\nexport function getParent(\n  doc: SharedType,\n  path: Path,\n  level = 1\n): [SyncNode, number] {\n  const [idx, parentPath] = getParentPath(path, level);\n  const parent = getTarget(doc, parentPath);\n  invariant(parent, 'Parent node should exists');\n  return [parent, idx];\n}\n\n/**\n * Returns the position of the sync item inside inside it's parent array.\n *\n * @param item\n */\nexport function getArrayPosition(item: Y.Item): number {\n  let i = 0;\n  let c = (item.parent as Y.Array<SyncElement>)._start;\n\n  while (c !== item && c !== null) {\n    if (!c.deleted) {\n      i += 1;\n    }\n    c = c.right;\n  }\n\n  return i;\n}\n\n/**\n * Returns the document path of a sync item\n *\n * @param node\n */\nexport function getSyncNodePath(node: SyncNode): Path {\n  if (!node) {\n    return [];\n  }\n\n  const { parent } = node;\n  if (!parent) {\n    return [];\n  }\n\n  if (parent instanceof Y.Array) {\n    invariant(node._item, 'Parent should be associated with a item');\n    return [...getSyncNodePath(parent), getArrayPosition(node._item)];\n  }\n\n  if (parent instanceof Y.Map) {\n    return getSyncNodePath(parent);\n  }\n\n  throw new Error(`Unknown parent type ${parent}`);\n}\n","import { TNodeOperation } from '@udecode/plate';\nimport { OpMapper } from '../types';\nimport insertNode from './insertNode';\nimport mergeNode from './mergeNode';\nimport moveNode from './moveNode';\nimport removeNode from './removeNode';\nimport setNode from './setNode';\nimport splitNode from './splitNode';\n\nconst mapper: OpMapper<TNodeOperation> = {\n  insert_node: insertNode,\n  merge_node: mergeNode,\n  move_node: moveNode,\n  remove_node: removeNode,\n  set_node: setNode,\n  split_node: splitNode,\n};\n\nexport default mapper;\n","import invariant from 'tiny-invariant';\nimport { MyElement } from '@decipad/editor-types';\nimport { TInsertNodeOperation } from '@udecode/plate';\nimport { SharedType, SyncNode } from '../../model';\nimport { getParent } from '../../path';\nimport { toSyncElement } from '../../utils/convert';\n\n/**\n * Applies an insert node operation to a SharedType.\n *\n * @param doc\n * @param op\n */\nexport default function insertNode(\n  doc: SharedType,\n  op: TInsertNodeOperation\n): SharedType {\n  const [parent, index] = getParent(doc, op.path);\n\n  const children = SyncNode.getChildren(parent);\n  if (SyncNode.getText(parent) !== undefined || !children) {\n    throw new TypeError(\"Can't insert node into text node\");\n  }\n\n  invariant(children, 'cannot apply insert node operation to text node');\n\n  children.insert(index, [toSyncElement(op.node as MyElement)]);\n  return doc;\n}\n","import invariant from 'tiny-invariant';\nimport { TMergeNodeOperation } from '@udecode/plate';\nimport { SharedType, SyncNode } from '../../model';\nimport { getParent } from '../../path';\nimport { cloneSyncElement } from '../../utils';\n\n/**\n * Applies a merge node operation to a SharedType.\n *\n * @param doc\n * @param op\n */\nexport default function mergeNode(\n  doc: SharedType,\n  op: TMergeNodeOperation\n): SharedType {\n  const [parent, index] = getParent(doc, op.path);\n\n  const children = SyncNode.getChildren(parent);\n  invariant(children, 'Parent of element should have children');\n\n  const prev = children.get(index - 1);\n  const next = children.get(index);\n\n  const prevText = SyncNode.getText(prev);\n  const nextText = SyncNode.getText(next);\n\n  if (prevText && nextText) {\n    prevText.insert(prevText.length, nextText.toString());\n  } else {\n    const nextChildren = SyncNode.getChildren(next);\n    const prevChildren = SyncNode.getChildren(prev);\n\n    invariant(nextChildren, 'Next element should have children');\n    invariant(prevChildren, 'Prev element should have children');\n\n    const toPush = nextChildren.map(cloneSyncElement);\n    prevChildren.push(toPush);\n  }\n\n  children.delete(index, 1);\n  return doc;\n}\n","import invariant from 'tiny-invariant';\nimport { TMoveNodeOperation } from '@udecode/plate';\nimport { SharedType, SyncNode } from '../../model';\nimport { getParent } from '../../path';\nimport { cloneSyncElement } from '../../utils';\n\n/**\n * Applies a move node operation to a SharedType.\n *\n * @param doc\n * @param op\n */\nexport default function moveNode(\n  doc: SharedType,\n  op: TMoveNodeOperation\n): SharedType {\n  const [from, fromIndex] = getParent(doc, op.path);\n  const [to, toIndex] = getParent(doc, op.newPath);\n\n  if (\n    SyncNode.getText(from) !== undefined ||\n    SyncNode.getText(to) !== undefined\n  ) {\n    throw new TypeError(\"Can't move node as child of a text node\");\n  }\n\n  const fromChildren = SyncNode.getChildren(from);\n  const toChildren = SyncNode.getChildren(to);\n\n  invariant(fromChildren, 'From element should not be a text node');\n  invariant(toChildren, 'To element should not be a text node');\n\n  const toMove = fromChildren.get(fromIndex);\n  const toInsert = cloneSyncElement(toMove);\n\n  fromChildren.delete(fromIndex);\n  toChildren.insert(Math.min(toIndex, toChildren.length), [toInsert]);\n\n  return doc;\n}\n","import invariant from 'tiny-invariant';\nimport { TRemoveNodeOperation } from '@udecode/plate';\nimport { SharedType, SyncNode } from '../../model';\nimport { getParent } from '../../path';\n\n/**\n * Applies a remove node operation to a SharedType.\n *\n * @param doc\n * @param op\n */\nexport default function removeNode(\n  doc: SharedType,\n  op: TRemoveNodeOperation\n): SharedType {\n  const [parent, index] = getParent(doc, op.path);\n\n  if (SyncNode.getText(parent) !== undefined) {\n    throw new TypeError(\"Can't remove node from text node\");\n  }\n\n  const children = SyncNode.getChildren(parent);\n  invariant(children, 'Parent should have children');\n  children.delete(index);\n\n  return doc;\n}\n","import { TSetNodeOperation } from '@udecode/plate';\nimport { SharedType, SyncElement } from '../../model';\nimport { getTarget } from '../../path';\n\n/**\n * Applies a setNode operation to a SharedType\n *\n * @param doc\n * @param op\n */\nexport default function setNode(\n  doc: SharedType,\n  op: TSetNodeOperation\n): SharedType {\n  const node = getTarget(doc, op.path) as SyncElement;\n\n  Object.entries(op.newProperties).forEach(([key, value]) => {\n    if (key === 'children' || key === 'text') {\n      throw new Error(`Cannot set the \"${key}\" property of nodes!`);\n    }\n\n    node.set(key, value);\n  });\n\n  Object.entries(op.properties).forEach(([key]) => {\n    // eslint-disable-next-line no-prototype-builtins\n    if (!op.newProperties.hasOwnProperty(key)) {\n      node.delete(key);\n    }\n  });\n\n  return doc;\n}\n","import invariant from 'tiny-invariant';\nimport { TSplitNodeOperation } from '@udecode/plate';\nimport { SharedType, SyncNode } from '../../model';\nimport { getParent } from '../../path';\nimport cloneSyncElement from '../../utils/clone';\n\n/**\n * Applies a split node operation to a SharedType\n *\n * @param doc\n * @param op\n */\nexport default function splitNode(\n  doc: SharedType,\n  op: TSplitNodeOperation\n): SharedType {\n  const [parent, index]: [SyncNode, number] = getParent(doc, op.path);\n\n  const children = SyncNode.getChildren(parent);\n  invariant(children, 'Parent of node should have children');\n\n  const target = children.get(index);\n  const inject = cloneSyncElement(target);\n  children.insert(index + 1, [inject]);\n\n  Object.entries(op.properties).forEach(([key, value]) =>\n    inject.set(key, value)\n  );\n\n  if (SyncNode.getText(target) !== undefined) {\n    const targetText = SyncNode.getText(target);\n    const injectText = SyncNode.getText(inject);\n\n    invariant(targetText);\n    invariant(injectText);\n\n    if (targetText.length > op.position) {\n      targetText.delete(op.position, targetText.length - op.position);\n    }\n\n    if (injectText !== undefined && op.position !== undefined) {\n      injectText.delete(0, op.position);\n    }\n  } else {\n    const targetChildren = SyncNode.getChildren(target);\n    const injectChildren = SyncNode.getChildren(inject);\n\n    invariant(targetChildren);\n    invariant(injectChildren);\n\n    targetChildren.delete(op.position, targetChildren.length - op.position);\n\n    if (op.position !== undefined) {\n      injectChildren.delete(0, op.position);\n    }\n  }\n\n  return doc;\n}\n","import { TTextOperation } from '@udecode/plate';\nimport { OpMapper } from '../types';\nimport insertText from './insertText';\nimport removeText from './removeText';\n\nconst mappers: OpMapper<TTextOperation> = {\n  insert_text: insertText,\n  remove_text: removeText,\n};\n\nexport default mappers;\n","import invariant from 'tiny-invariant';\nimport { TInsertTextOperation } from '@udecode/plate';\nimport { SharedType, SyncElement } from '../../model';\nimport { getTarget } from '../../path';\n\n/**\n * Applies a insert text operation to a SharedType.\n *\n * @param doc\n * @param op\n */\nexport default function insertText(\n  doc: SharedType,\n  op: TInsertTextOperation\n): SharedType {\n  const node = getTarget(doc, op.path) as SyncElement;\n  const nodeText = SyncElement.getText(node);\n\n  invariant(nodeText, 'Apply text operation to non text node');\n\n  nodeText.insert(op.offset, op.text);\n  return doc;\n}\n","import { getDefined } from '@decipad/utils';\nimport { TRemoveTextOperation } from '@udecode/plate';\nimport { SharedType, SyncElement } from '../../model';\nimport { getTarget } from '../../path';\n\n/**\n * Applies a remove text operation to a SharedType.\n *\n * @param doc\n * @param op\n */\nexport default function removeText(\n  doc: SharedType,\n  op: TRemoveTextOperation\n): SharedType {\n  const node = getTarget(doc, op.path) as SyncElement;\n  const nodeText = getDefined(\n    SyncElement.getText(node),\n    'could not find text in node'\n  );\n  nodeText.delete(op.offset, op.text.length);\n  return doc;\n}\n","import invariant from 'tiny-invariant';\nimport { TOperation } from '@udecode/plate';\nimport { SharedType } from '../model';\nimport node from './node';\nimport text from './text';\nimport { ApplyFunc, OpMapper } from './types';\n\nconst nullOp: ApplyFunc = (doc: SharedType) => doc;\n\nconst opMappers: OpMapper = {\n  ...text,\n  ...node,\n\n  // SetSelection is currently a null op since we don't support cursors\n  set_selection: nullOp,\n};\n\n/**\n * Applies a slate operation to a SharedType\n *\n * @param sharedType\n * @param op\n */\nexport function applySlateOp(\n  sharedType: SharedType,\n  op: TOperation\n): SharedType {\n  const apply = opMappers[op.type] as ApplyFunc<typeof op>;\n  if (!apply) {\n    throw new Error(`Unknown operation: ${op.type}`);\n  }\n\n  return apply(sharedType, op);\n}\n\n/**\n * Applies slate operations to a SharedType\n */\nexport default function applySlateOps(\n  sharedType: SharedType,\n  ops: TOperation[],\n  origin: unknown\n): SharedType {\n  invariant(sharedType.doc, 'Shared type without attached document');\n\n  if (ops.length > 0) {\n    sharedType.doc.transact(() => {\n      ops.forEach((op) => applySlateOp(sharedType, op));\n    }, origin);\n  }\n\n  return sharedType;\n}\n","import { Range } from 'slate';\nimport * as Y from 'yjs';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type SyncElement = Y.Map<any>;\nexport type SharedType = Y.Array<SyncElement>;\nexport type SyncNode = SharedType | SyncElement;\n\nexport const slateYjsSymbol = Symbol('slate-yjs');\n\nexport interface Cursor extends Range {\n  data: {\n    [key: string]: unknown;\n  };\n}\n\nexport const SyncElement = {\n  getText(element: SyncElement): Y.Text | undefined {\n    return element?.get('text');\n  },\n\n  getChildren(element: SyncElement): Y.Array<SyncElement> | undefined {\n    return element?.get('children');\n  },\n};\n\nexport const SyncNode = {\n  getChildren(node: SyncNode): Y.Array<SyncElement> | undefined {\n    if (node instanceof Y.Array) {\n      return node;\n    }\n\n    return SyncElement.getChildren(node);\n  },\n\n  getText(node: SyncNode): Y.Text | undefined {\n    if (node instanceof Y.Array) {\n      return undefined;\n    }\n\n    return SyncElement.getText(node);\n  },\n};\n","import * as Y from 'yjs';\nimport { SyncElement } from '../model';\n\nexport default function cloneSyncElement(element: SyncElement): SyncElement {\n  const text = SyncElement.getText(element);\n  const children = SyncElement.getChildren(element);\n\n  const clone = new Y.Map();\n\n  if (text !== undefined) {\n    const textElement = new Y.Text(text.toString());\n    clone.set('text', textElement);\n  }\n\n  if (children !== undefined) {\n    const childElements = children.map(cloneSyncElement);\n    const childContainer = new Y.Array();\n    childContainer.insert(0, childElements);\n    clone.set('children', childContainer);\n  }\n\n  Array.from(element.entries()).forEach(([key, value]) => {\n    if (key !== 'children' && key !== 'text') {\n      clone.set(key, value);\n    }\n  });\n\n  return clone;\n}\n","import {\n  BlockElement,\n  MyElement,\n  MyDescendant,\n  MyNode,\n  PlainText,\n} from '@decipad/editor-types';\nimport { Path } from 'slate';\nimport * as Y from 'yjs';\nimport { isElement, isText } from '@udecode/plate';\nimport { supportBigIntToJSON } from '@decipad/utils';\nimport { SharedType, SyncElement } from '../model';\n\nsupportBigIntToJSON();\n\n/**\n * Converts a sync element to a slate node\n *\n * @param element\n */\nexport function toSlateNode(element: SyncElement): MyNode {\n  const text = SyncElement.getText(element);\n  const children = SyncElement.getChildren(element);\n\n  const node: Partial<MyElement | MyNode> = {};\n  if (text !== undefined) {\n    (node as PlainText).text = text.toString();\n  }\n  if (children !== undefined) {\n    (node as BlockElement).children = children.map(\n      toSlateNode\n    ) as BlockElement['children'];\n  }\n\n  const entries = element.entries();\n\n  Array.from(entries).forEach(([key, value]) => {\n    if (key !== 'children' && key !== 'text') {\n      (node as Record<string, unknown>)[key] = value;\n    }\n  });\n\n  return node as MyNode;\n}\n\n/**\n * Converts a SharedType to a Slate doc\n * @param doc\n */\nexport function toSlateDoc(doc: SharedType): MyNode[] {\n  return doc.map(toSlateNode);\n}\n\n/**\n * Converts a slate node to a sync element\n *\n * @param node\n */\nexport function toSyncElement(node: MyElement | MyDescendant): SyncElement {\n  const element: SyncElement = new Y.Map();\n\n  if (isElement(node)) {\n    const childElements = node.children.map(toSyncElement);\n    const childContainer = new Y.Array();\n    childContainer.insert(0, childElements);\n    element.set('children', childContainer);\n  }\n\n  if (isText(node)) {\n    const textElement = new Y.Text(node.text);\n    element.set('text', textElement);\n  }\n\n  Object.entries(node).forEach(([key, value]) => {\n    if (key !== 'children' && key !== 'text') {\n      element.set(key, value);\n    }\n  });\n\n  return element;\n}\n\n/**\n * Converts all elements int a Slate doc to SyncElements and adds them\n * to the SharedType\n *\n * @param sharedType\n * @param doc\n */\nexport function toSharedType(sharedType: SharedType, doc: MyElement[]): void {\n  sharedType.insert(0, doc.map(toSyncElement));\n}\n\n/**\n * Converts a SharedType path the a slate path\n *\n * @param path\n */\nexport function toSlatePath(path: (string | number)[]): Path {\n  return path.filter((node) => typeof node === 'number') as Path;\n}\n","import { Subject } from 'rxjs';\nimport type { MessageHandler } from '.';\n\nexport const version1 = (): MessageHandler => {\n  const message = new Subject<Buffer>();\n  const receive = (m: Uint8Array) => {\n    message.next(Buffer.from(m));\n  };\n  return {\n    message,\n    receive,\n  };\n};\n","import { Subject } from 'rxjs';\nimport {\n  Decoder,\n  readVarString,\n  readUint16,\n  readUint8Array,\n} from 'lib0/decoding';\nimport { getDefined } from '@decipad/utils';\n\nclass MessagePrep {\n  public readonly pendingMessages: Array<Uint8Array>;\n  public readonly expectedMessageCount: number;\n\n  constructor(expectedMessageCount: number) {\n    this.pendingMessages = new Array(expectedMessageCount);\n    this.expectedMessageCount = expectedMessageCount;\n  }\n}\n\nexport class Receiver {\n  public readonly messages = new Subject<Buffer>();\n  private pendingMessages = new Map<string, MessagePrep>();\n\n  private maybeFinalizeMessage(messageId: string) {\n    const messages = getDefined(this.pendingMessages.get(messageId));\n\n    if (\n      messages.pendingMessages.filter((m) => m != null).length ===\n      messages.expectedMessageCount\n    ) {\n      this.release(messageId);\n    }\n  }\n\n  private release(messageId: string) {\n    const messages = getDefined(this.pendingMessages.get(messageId));\n    this.messages.next(Buffer.concat(messages.pendingMessages));\n    this.pendingMessages.delete(messageId);\n  }\n\n  public receive(message: Uint8Array) {\n    const decoder = new Decoder(message);\n    const messageId = readVarString(decoder);\n    const messageCount = readUint16(decoder);\n    let prep = this.pendingMessages.get(messageId);\n    if (!prep) {\n      prep = new MessagePrep(messageCount);\n      this.pendingMessages.set(messageId, prep);\n    }\n    const pos = readUint16(decoder);\n    const len = readUint16(decoder);\n    prep.pendingMessages[pos] = readUint8Array(decoder, len);\n\n    this.maybeFinalizeMessage(messageId);\n  }\n\n  public get pending() {\n    return this.pendingMessages.size;\n  }\n}\n","import { Receiver } from '@decipad/message-packer';\nimport type { MessageHandler } from '.';\n\nexport const version2 = (): MessageHandler => {\n  const r = new Receiver();\n  return {\n    message: r.messages,\n    receive: r.receive.bind(r),\n  };\n};\n","import { Doc as YDoc } from 'yjs';\nimport * as awarenessProtocol from 'y-protocols/awareness';\nimport * as decoding from 'lib0/decoding';\nimport * as encoding from 'lib0/encoding';\nimport { Observable } from 'lib0/observable';\n\nexport type MessageType = 0 | 1 | 2 | 3;\n\nexport const messageSync = 0;\nexport const messageQueryAwareness = 3;\nexport const messageAwareness = 1;\nexport const messageAuth = 2;\n\nexport type MessageHandler = (\n  encoder: encoding.Encoder,\n  decoder: decoding.Decoder,\n  provider: TWebSocketProvider,\n  emitSynced: boolean,\n  messageType: MessageType\n) => void;\n\nexport type TWebSocketProvider = Observable<string> & {\n  doc: YDoc;\n  readOnly: boolean;\n  ws?: WebSocket;\n  _WS: typeof WebSocket;\n  serverUrl: string | undefined;\n  url?: string;\n  protocol?: string;\n  protocolVersion: number;\n  awareness: awarenessProtocol.Awareness;\n  messageHandlers: MessageHandler[];\n\n  wsUnsuccessfulReconnects: number;\n  wsLastMessageReceived: number;\n  synced: boolean;\n  wsconnecting: boolean;\n  wsconnected: boolean;\n  shouldConnect: boolean;\n  destroyed: boolean;\n\n  beforeConnect?: (provider: TWebSocketProvider) => void | Promise<void>;\n  connect: () => void;\n  send: (buf: Uint8Array) => void;\n  disconnect: () => void;\n  onError?: (error: Error) => void;\n};\n"],"names":["fnQueue","fns","processing","flushes","async","work","length","fn","shift","Error","processOne","resolveFlush","push","resolve","reject","p","Promise","res","rej","err","flush","pendingCount","translateYjsEvent","editor","event","Y","targetPath","toSlatePath","path","targetElement","getNode","invariant","isText","offset","ops","children","Array","from","changes","delta","forEach","retain","splice","delete","node","type","isArray","insert","JSON","stringify","toInsert","map","toSlateNode","i","translateArrayEvent","targetSyncElement","target","keyChanges","keys","entries","newProperties","Object","fromEntries","key","info","action","get","properties","translateMapEvent","targetText","text","endOffset","slice","translateTextEvent","applyYjsEvents","events","selection","withoutNormalizing","apply","anchor","focus","point","findNode","at","setSelection","undefined","getTarget","doc","reduce","current","idx","SyncNode","isTree","TypeError","toString","toSlateDoc","getParentPath","level","getParent","parentPath","parent","mapper","insert_node","op","index","toSyncElement","merge_node","prev","next","prevText","nextText","nextChildren","prevChildren","toPush","cloneSyncElement","move_node","fromIndex","to","toIndex","newPath","fromChildren","toChildren","toMove","Math","min","remove_node","set_node","value","set","hasOwnProperty","split_node","inject","injectText","position","targetChildren","injectChildren","mappers","insert_text","nodeText","SyncElement","remove_text","getDefined","opMappers","set_selection","applySlateOps","sharedType","origin","transact","applySlateOp","slateYjsSymbol","Symbol","getText","element","getChildren","clone","textElement","childElements","childContainer","isElement","filter","supportBigIntToJSON","version1","message","Subject","receive","m","Buffer","MessagePrep","constructor","expectedMessageCount","this","pendingMessages","Receiver","Map","maybeFinalizeMessage","messageId","messages","release","concat","decoder","Decoder","readVarString","messageCount","readUint16","prep","pos","len","readUint8Array","pending","size","version2","r","bind","messageSync","messageQueryAwareness","messageAwareness","messageAuth"],"sourceRoot":""}