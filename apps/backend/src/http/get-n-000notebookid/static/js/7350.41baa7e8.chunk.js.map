{"version":3,"file":"static/js/7350.41baa7e8.chunk.js","mappings":"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","sources":["../../../node_modules/@mixer/postmessage-rpc/dist/error.js","../../../node_modules/@mixer/postmessage-rpc/dist/reorder.js","../../../node_modules/@mixer/postmessage-rpc/dist/rpc.js","../../../node_modules/@mixer/postmessage-rpc/dist/types.js","../../../node_modules/@mixer/postmessage-rpc/node_modules/eventemitter3/index.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * An RPCError can be thrown in socket.call() if bad input is\n * passed to the service.\n */\nvar RPCError = /** @class */ (function (_super) {\n    __extends(RPCError, _super);\n    function RPCError(code, message, path) {\n        var _this = _super.call(this, \"Error #\" + code + \": \" + message) || this;\n        _this.code = code;\n        _this.message = message;\n        _this.path = path;\n        // Patch for ES5 compilation target errors:\n        Object.setPrototypeOf(_this, RPCError.prototype);\n        return _this;\n    }\n    RPCError.prototype.toReplyError = function () {\n        return {\n            code: this.code,\n            message: this.message,\n            path: this.path,\n        };\n    };\n    return RPCError;\n}(Error));\nexports.RPCError = RPCError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Reorder is a utility responsible for reording incoming messages.\n */\nvar Reorder = /** @class */ (function () {\n    function Reorder() {\n        /**\n         * Last call we got which was in sequence..\n         */\n        this.lastSequentialCall = -1;\n        /**\n         * Queue of messages to send out once reordered data comes back.\n         */\n        this.queue = [];\n    }\n    /**\n     * Resets the queue and call counter to the given value.\n     */\n    Reorder.prototype.reset = function (counter) {\n        this.lastSequentialCall = counter - 1;\n        this.queue = [];\n    };\n    /**\n     * Appends a message to the reorder queue. Returns all messages which\n     * are good to send out.\n     */\n    Reorder.prototype.append = function (packet) {\n        if (packet.counter <= this.lastSequentialCall + 1) {\n            var list = [packet];\n            this.lastSequentialCall = packet.counter;\n            this.replayQueue(list);\n            return list;\n        }\n        for (var i = 0; i < this.queue.length; i++) {\n            if (this.queue[i].counter > packet.counter) {\n                this.queue.splice(i, 0, packet);\n                return [];\n            }\n        }\n        this.queue.push(packet);\n        return [];\n    };\n    Reorder.prototype.replayQueue = function (list) {\n        while (this.queue.length) {\n            var next = this.queue[0];\n            if (next.counter > this.lastSequentialCall + 1) {\n                return;\n            }\n            list.push(this.queue.shift());\n            this.lastSequentialCall = next.counter;\n        }\n    };\n    return Reorder;\n}());\nexports.Reorder = Reorder;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar eventemitter3_1 = require(\"eventemitter3\");\nvar error_1 = require(\"./error\");\nvar reorder_1 = require(\"./reorder\");\nvar types_1 = require(\"./types\");\nfunction objToError(obj) {\n    return new error_1.RPCError(obj.code, obj.message, obj.path);\n}\n/**\n * Magic ID used for the \"ready\" call.\n */\nvar magicReadyCallId = -1;\n/**\n * Primitive postMessage based RPC.\n */\nvar RPC = /** @class */ (function (_super) {\n    __extends(RPC, _super);\n    /**\n     * Creates a new RPC instance. Note: you should use the `rpc` singleton,\n     * rather than creating this class directly, in your controls.\n     */\n    function RPC(options) {\n        var _this = _super.call(this) || this;\n        _this.options = options;\n        /**\n         * A map of IDs to callbacks we'll fire whenever the remote frame responds.\n         */\n        _this.calls = Object.create(null);\n        /**\n         * Counter to track the sequence number of our calls for reordering.\n         * Incremented each time we send a message.\n         */\n        _this.callCounter = 0;\n        /**\n         * Reorder utility for incoming messages.\n         */\n        _this.reorder = new reorder_1.Reorder();\n        _this.listener = function (ev) {\n            // If we got data that wasn't a string or could not be parsed, or was\n            // from a different remote, it's not for us.\n            if (_this.options.origin && _this.options.origin !== '*' && ev.origin !== _this.options.origin) {\n                return;\n            }\n            var packet;\n            try {\n                packet = JSON.parse(ev.data);\n            }\n            catch (e) {\n                return;\n            }\n            if (!types_1.isRPCMessage(packet) || packet.serviceID !== _this.options.serviceId) {\n                return;\n            }\n            // postMessage does not guarantee message order, reorder messages as needed.\n            // Reset the call counter when we get a \"ready\" so that the other end sees\n            // calls starting from 0.\n            if (_this.isReadySignal(packet)) {\n                var params = packet.type === 'method' ? packet.params : packet.result;\n                if (params && params.protocolVersion) {\n                    _this.remoteProtocolVersion = params.protocolVersion;\n                }\n                else {\n                    _this.remoteProtocolVersion = _this.remoteProtocolVersion;\n                }\n                _this.callCounter = 0;\n                _this.reorder.reset(packet.counter);\n                _this.emit('isReady', true);\n            }\n            for (var _i = 0, _a = _this.reorder.append(packet); _i < _a.length; _i++) {\n                var p = _a[_i];\n                _this.emit('recvData', p);\n                _this.dispatchIncoming(p);\n            }\n        };\n        _this.unsubscribeCallback = (options.receiver || types_1.defaultRecievable).readMessages(_this.listener);\n        // Both sides will fire \"ready\" when they're set up. When either we get\n        // a ready or the other side successfully responds that they're ready,\n        // resolve the \"ready\" promise.\n        _this.isReady = new Promise(function (resolve) {\n            var response = { protocolVersion: options.protocolVersion || '1.0' };\n            _this.expose('ready', function () {\n                resolve();\n                return response;\n            });\n            _this.call('ready', response)\n                .then(resolve)\n                .catch(resolve);\n        });\n        return _this;\n    }\n    /**\n     * Create instantiates a new RPC instance and waits until it's ready\n     * before returning.\n     */\n    RPC.prototype.create = function (options) {\n        var rpc = new RPC(options);\n        return rpc.isReady.then(function () { return rpc; });\n    };\n    /**\n     * Attaches a method callable by the other window, to this one. The handler\n     * function will be invoked with whatever the other window gives us. Can\n     * return a Promise, or the results directly.\n     *\n     * @param {string} method\n     * @param {function(params: any): Promise.<*>|*} handler\n     */\n    RPC.prototype.expose = function (method, handler) {\n        var _this = this;\n        this.on(method, function (data) {\n            if (data.discard) {\n                handler(data.params);\n                return;\n            }\n            // tslint:disable-next-line\n            new Promise(function (resolve) { return resolve(handler(data.params)); })\n                .then(function (result) {\n                return ({\n                    type: 'reply',\n                    serviceID: _this.options.serviceId,\n                    id: data.id,\n                    result: result,\n                });\n            })\n                .catch(function (err) {\n                return ({\n                    type: 'reply',\n                    serviceID: _this.options.serviceId,\n                    id: data.id,\n                    error: err instanceof error_1.RPCError\n                        ? err.toReplyError()\n                        : { code: 0, message: err.stack || err.message },\n                });\n            })\n                .then(function (packet) {\n                _this.emit('sendReply', packet);\n                _this.post(packet);\n            });\n        });\n        return this;\n    };\n    /**\n     * Makes an RPC call out to the target window.\n     *\n     * @param {string} method\n     * @param {*} params\n     * @param {boolean} [waitForReply=true]\n     * @return {Promise.<object> | undefined} If waitForReply is true, a\n     * promise is returned that resolves once the server responds.\n     */\n    RPC.prototype.call = function (method, params, waitForReply) {\n        var _this = this;\n        if (waitForReply === void 0) { waitForReply = true; }\n        var id = method === 'ready' ? magicReadyCallId : this.callCounter;\n        var packet = {\n            type: 'method',\n            serviceID: this.options.serviceId,\n            id: id,\n            params: params,\n            method: method,\n            discard: !waitForReply,\n        };\n        this.emit('sendMethod', packet);\n        this.post(packet);\n        if (!waitForReply) {\n            return;\n        }\n        return new Promise(function (resolve, reject) {\n            _this.calls[id] = function (err, res) {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(res);\n                }\n            };\n        });\n    };\n    /**\n     * Tears down resources associated with the RPC client.\n     */\n    RPC.prototype.destroy = function () {\n        this.emit('destroy');\n        this.unsubscribeCallback();\n    };\n    /**\n     * Returns the protocol version that the remote client implements. This\n     * will return `undefined` until we get a `ready` event.\n     * @return {string | undefined}\n     */\n    RPC.prototype.remoteVersion = function () {\n        return this.remoteProtocolVersion;\n    };\n    RPC.prototype.handleReply = function (packet) {\n        var handler = this.calls[packet.id];\n        if (!handler) {\n            return;\n        }\n        if (packet.error) {\n            handler(objToError(packet.error), null);\n        }\n        else {\n            handler(null, packet.result);\n        }\n        delete this.calls[packet.id];\n    };\n    RPC.prototype.post = function (message) {\n        message.counter = this.callCounter++;\n        this.options.target.postMessage(JSON.stringify(message), this.options.origin || '*');\n    };\n    RPC.prototype.isReadySignal = function (packet) {\n        if (packet.type === 'method' && packet.method === 'ready') {\n            return true;\n        }\n        if (packet.type === 'reply' && packet.id === magicReadyCallId) {\n            return true;\n        }\n        return false;\n    };\n    RPC.prototype.dispatchIncoming = function (packet) {\n        switch (packet.type) {\n            case 'method':\n                this.emit('recvMethod', packet);\n                if (this.listeners(packet.method).length > 0) {\n                    this.emit(packet.method, packet);\n                    return;\n                }\n                this.post({\n                    type: 'reply',\n                    serviceID: this.options.serviceId,\n                    id: packet.id,\n                    error: { code: 4003, message: \"Unknown method name \\\"\" + packet.method + \"\\\"\" },\n                    result: null,\n                });\n                break;\n            case 'reply':\n                this.emit('recvReply', packet);\n                this.handleReply(packet);\n                break;\n            default:\n            // Ignore\n        }\n    };\n    return RPC;\n}(eventemitter3_1.EventEmitter));\nexports.RPC = RPC;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Checks whether the message duck-types into an Interactive message.\n * This is needed to distinguish between postmessages that we get,\n * and postmessages from other sources.\n */\nfunction isRPCMessage(data) {\n    return (data.type === 'method' || data.type === 'reply') && typeof data.counter === 'number';\n}\nexports.isRPCMessage = isRPCMessage;\n/**\n * Default `IRecievable` implementation that listens on the window.\n */\nexports.defaultRecievable = {\n    readMessages: function (callback) {\n        window.addEventListener('message', callback);\n        return function () { return window.removeEventListener('message', callback); };\n    },\n};\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n"],"names":["__extends","this","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","exports","value","RPCError","_super","code","message","path","_this","call","toReplyError","Error","Reorder","lastSequentialCall","queue","reset","counter","append","packet","list","replayQueue","i","length","splice","push","next","shift","eventemitter3_1","require","error_1","reorder_1","types_1","RPC","options","calls","callCounter","reorder","listener","ev","origin","JSON","parse","data","e","isRPCMessage","serviceID","serviceId","isReadySignal","params","type","result","protocolVersion","remoteProtocolVersion","emit","_i","_a","dispatchIncoming","unsubscribeCallback","receiver","defaultRecievable","readMessages","isReady","Promise","resolve","response","expose","then","catch","rpc","method","handler","on","discard","id","err","error","stack","post","waitForReply","reject","res","destroy","remoteVersion","handleReply","obj","target","postMessage","stringify","listeners","EventEmitter","callback","window","addEventListener","removeEventListener","has","prefix","Events","EE","fn","context","once","addListener","emitter","event","TypeError","evt","_events","_eventsCount","clearEvent","eventNames","events","name","names","slice","getOwnPropertySymbols","concat","handlers","l","ee","listenerCount","a1","a2","a3","a4","a5","args","len","arguments","removeListener","undefined","apply","j","removeAllListeners","off","prefixed","module"],"sourceRoot":""}