{"version":3,"file":"static/js/8819.26d3ef08.chunk.js","mappings":"iHAGO,MAAMA,EAAgB,CAAIC,EAAkBC,IAC1CC,EAAAA,GAAAA,QAAkBF,EAAgCC,I,mGCepD,SAASE,EACdH,EACAI,EACAC,EACAC,GAEA,MAAMC,EAAS,IAAIC,KAEd,OAALH,QAAK,IAALA,GAAAA,EAAOI,GAAG,UAAU,WAClBF,EAAOG,KAAK,SAAU,YAEnB,OAALL,QAAK,IAALA,GAAAA,EAAOI,GACL,SACA,SAAsBE,EAAiCC,GACrD,MAAMC,EAAqBD,EAAU,QAAU,SAC/CL,EAAOG,KAAK,QAASG,MAIrBP,IACFA,EAAGG,GAAG,UAAU,SAAoBK,GAC9BA,IACFP,EAAOG,KAAK,SAAU,UACtBK,EAAgBC,MAAK,OAGzBV,EAAGG,GAAG,SAAS,WACbF,EAAOG,KAAK,QAAS,UACrBK,EAAgBC,MAAK,MAEvBV,EAAGG,GAAG,UAAU,SAAoBQ,GACb,cAAjBA,EAAMC,QACRX,EAAOG,KAAK,gBAGhBJ,EAAGG,GAAG,SAAUU,IAEdC,QAAQC,MAAM,6BAA8BF,OAIhD,MAAMG,EAAkB,IAAIC,EAAAA,iBAAyB,GAC/CR,EAAkB,IAAIQ,EAAAA,iBAAyB,GAE/CC,EAAkB,KACtB,IAAIC,EAAa,EACjBlB,EAAOE,GAAG,SAAUI,IAClBY,GAAc,EACVA,EAAa,IACfA,EAAa,EACE,UAAXZ,IACFS,EAAgBN,MAAK,GACrBD,EAAgBC,MAAK,SAKzBX,EACFA,EAAMqB,KAAK,SAAUF,GAErBA,IAGF,IAAIG,GAAY,EAChBpB,EAAOmB,KAAK,aAAa,KACvBC,GAAY,KAgEd,OA7DkBC,OAAOC,OAAO7B,EAAQ,CACtC8B,SAASC,GACPxB,EAAOE,GAAG,SAAUsB,IAEtBC,UAAUD,GACRxB,EAAO0B,eAAe,SAAUF,IAElCG,QAAQH,GACNxB,EAAOE,GAAG,QAASsB,IAErBI,SAASJ,GACPxB,EAAO0B,eAAe,QAASF,IAEjCK,YAAYL,GACVxB,EAAOE,GAAG,YAAasB,IAEzBM,YAAYN,GACVxB,EAAOE,GAAG,YAAasB,IAEzBO,aAAaP,GACXxB,EAAO0B,eAAe,YAAaF,IAErCQ,UACEhC,EAAOG,KAAK,aACZH,EAAOiC,qBACPpC,EAAImC,UACC,OAALlC,QAAK,IAALA,GAAAA,EAAOkC,UACL,OAAFjC,QAAE,IAAFA,GAAAA,EAAIiC,WAENE,UACI,OAAFnC,QAAE,IAAFA,GAAAA,EAAImC,WAENC,aACI,OAAFpC,QAAE,IAAFA,GAAAA,EAAIoC,cAENpB,gBAAe,IACNA,EAETP,gBAAe,IACNA,EAET4B,mBAAkB,KACJ,OAALtC,QAAK,IAALA,OAAK,EAALA,EAAOuC,WAAYC,QAAQC,UAEpCC,oBACExC,EAAOG,KAAK,SAAU,WAExBsC,kBAAkB,EAClBC,YAAcC,IACP,OAAL7C,QAAK,IAALA,OAAK,EAALA,EAAO4C,YAAYC,KAAYL,QAAQC,UACzCK,YAAcD,IACP,OAAL7C,QAAK,IAALA,OAAK,EAALA,EAAO8C,YAAYD,KAAYL,QAAQC,SAAQ,GACjDM,OAASC,GACeC,IAAIC,KAAKC,WAAUC,EAAAA,EAAAA,IAAWrD,EAAIsD,gBAC/BL,EAEvB1B,gBACF,OAAOA,MA/HbgC,E,SAAAA,O,8KCqBAC,eAAeC,IACb,MAAMC,QAAaC,EAAAA,EAAAA,GAAM,8BACzB,GAAS,OAAJD,QAAI,IAAJA,IAAAA,EAAME,GACT,MAAM,IAAIC,MAAM,2CAAD,OAC8BH,EAAK5C,OAAM,aACpD4C,EAAKI,WAAU,gCACY,OAAJJ,QAAI,IAAJA,OAAI,EAAJA,EAAMK,SAAWZ,KAAKC,UAAUM,KAG7D,OAAW,OAAJA,QAAI,IAAJA,OAAI,EAAJA,EAAMK,OAGfP,eAAeQ,EAAUC,GAAiC,IAAD,EACvD,MAAM,GAAN,aAAuC,QAA7B,QAAaN,EAAAA,EAAAA,GAAM,kBAAU,aAAvB,EAA0BI,QAAM,gBAAQG,mBACtDD,GACD,eAGI,SAASE,EACdF,EAAc,GAcb,IAbD,OACErE,EAAM,SACNwE,GAAW,EAAK,WAChBC,EAAU,QACVC,EAAO,GACPpE,GAAK,EAAI,QACTmC,EAAUnC,EAAE,kBACZqE,EAAiB,iBACjBC,EAAgB,aAChBC,EAAY,gBACZC,GACe,EACjBC,EAAqC,uDAAG,OAEvC/E,EAAuBgF,SAAW,GACnC,MAAM5E,EAAM,IAAI6E,EAAAA,GACV5E,GAAQ6E,EAAAA,EAAAA,IAAS,aACnB,IAAIC,EAAAA,GAAqBd,EAAOjE,EAAK,CAAEoE,kBACvCY,EACEC,EAAmBC,KAAKC,MAExBC,EAAsB,IAC1BF,KAAKC,MAAQF,EA9DM,IAgEfI,EAAW,IACfD,KAAoD,OAAhBZ,QAAgB,IAAhBA,OAAZQ,EAAYR,EAAkBc,MAElDC,EAAgB/B,UACpB,IACEgC,EAASC,UAA4B,OAAhBjB,QAAgB,IAAhBA,GAAAA,EAAkBkB,IAAG,UACnClB,EAAiBkB,WACd1B,EAAUC,GACpBuB,EAASG,SAAWtB,GAAcgB,WAAqB5B,IACvD,MAAO1C,GAEPC,QAAQC,MAAMF,KAIlB,IAAI6E,EACAC,EAEJ,MAAMC,EACJ5F,IAAM4E,EAAAA,EAAAA,IAAS,iBAAmBV,GAA4B,MAAhBK,GAC5CqB,GACFF,GAAMG,EAAAA,EAAAA,IAAwB/F,EAAK,CACjCuE,oBACAH,WACA/B,SAAS,EACTkD,gBACAS,eAAgB,IAChB1B,UACAI,oBAEFmB,EAAYD,EAAIC,WAEhBA,EAAY,IAAII,EAAAA,GAAUjG,GAI5B,MAAMkG,EAASlG,EAAIsD,WACb6C,GAAYC,EAAAA,EAAAA,IAAQxG,EAAoBsG,GAE9CC,EAAUE,mBAEV,IAAI9E,GAAY,EACZb,GAAS,EAEb,MAAM4F,EAAa,KACjB,IAAI5F,IAGJA,GAAS,EACL2B,IAAYd,GAAW,CAAC,IAAD,EACzB,GAAoB,MAAhBkD,EACF,IACE,MAAM8B,EAASC,EAAOC,KAAKhC,EAAc,WACzCiC,EAAAA,EAAAA,IAAY1G,EAAKuG,GACjBI,YAAW,IAAMC,EAAWjE,qBAAqB,GACjD,MAAO5B,GAEPC,QAAQC,MAAM,gCAAiCF,GAGhD,QAAH,EAAA6E,SAAG,OAAH,EAAKvD,YAILpC,EACFA,EAAMqB,KAAK,SAAUgF,GAErBK,WAAWL,EAAY,GAIzB,MAAMO,GAAeC,EAAAA,EAAAA,IAAWX,EAAWN,EAAWlB,IAEhD,cAAEoC,GAAkBF,EAC1BA,EAAaE,cAAiBC,IAC5BrH,EAAAA,EAAAA,GAAckH,GAAc,IAAME,EAAcC,KAGlD,IAAIJ,GAAa7G,EAAAA,EAAAA,GAAc8G,EAAc7G,EAAKC,EAAO2F,GACzDgB,EAAWzE,QAAU,KAAO,IAAD,EACzBZ,GAAY,EACP,OAALtB,QAAK,IAALA,GAAAA,EAAOkC,UACJ,QAAH,EAAAyD,SAAG,OAAH,EAAKzD,WAGPyE,EAAWhE,kBAAmB,EAE9B,IAAIqE,GAAgB,EAChBC,GAAiB,EAErB,MAAMxF,EAAYjB,IAEb2D,GACA7C,GACA2F,GACChH,GAAiB,WAAXO,IAER0G,EAAAA,EAAAA,GAAsBvH,GAET,WAAXa,IACFyG,GAAiB,GAEJ,UAAXzG,IACFwG,GAAgB,GAEdC,GAAkBD,GACpBL,EAAWhF,UAAUF,IASzB,OANAkF,EAAWlF,SAASA,GAEpBkF,GAAaQ,EAAAA,EAAAA,GAAUR,GAEvBA,EAAWS,WAAajD,EAEjBwC,I,gDCnMF,MAAMU,EAA0B9D,UAED+D,EAAAA,EAAAA,IAAqBtD,I,mICApD,MAAMmD,EAAaxH,IACxB,IAAI4H,GAAqB,EACzB,MAAMC,EAAc,IAAIC,EAAAA,GAAY9H,EAAO+H,WAAY,CACrDC,eAAgB,IAAIC,IAAI,CAACC,EAAAA,KACzBN,mBAAoB,IAAMA,EAC1BO,eAAgB,MAmBlB,OAjBAnI,EAAOoI,KAAO,KACZP,EAAYO,QAEdpI,EAAOqI,KAAO,KACZR,EAAYQ,QAEdrI,EAAOsI,qBAAwBvG,IAC7B,MAAMwG,EAAkBX,EACxBA,GAAqB,EACrB,IACE7F,IACD,QACC6F,EAAqBW,IAGzBvI,EAAO6H,YAAcA,EAEd7H,I,0DCnBF,SAASuH,EAAsBvH,GACpC,MAAM,SAAEgF,GAAahF,EACjBgF,EAASwD,OAAS,GAGE,IAApBxD,EAASwD,SACXC,EAAAA,EAAAA,KAAmBzI,GAAQ,MACzB0I,EAAAA,EAAAA,KACE1I,EACA,CACE2I,KAAMC,EAAAA,IACN5D,SAAU,CAAC,CAAEb,KAAM,sBACnB0E,IAAIC,EAAAA,EAAAA,OAEN,CAAEC,GAAI,CAAC,MAETL,EAAAA,EAAAA,KACE1I,EACA,CACE2I,KAAMK,EAAAA,IACNhE,SAAU,CAAC,CAAEb,KAAM,KACnB0E,IAAIC,EAAAA,EAAAA,OAEN,CAAEC,GAAI,CAAC,U,yLCzBf,MAAME,EAAyC,IAAIC,QAStCC,EAAe,CAC1BlD,UAAUjG,GACR,MAAMiG,EAAYgD,EAAUG,IAAIpJ,GAEhC,OADAqJ,EAAAA,EAAAA,GAAUpD,EAAW,2CACdA,GAGTqD,aAAc,CAACtJ,EAAsBuJ,KACnC,IACE,MAAM,UAAEC,GAAcxJ,GAEhB,OAAEyJ,GAAoB,OAATD,QAAS,IAATA,EAAAA,EAAa,IAC1B,MAAEE,GAAmB,OAATF,QAAS,IAATA,EAAAA,EAAa,GAEzBvD,EAAYkD,EAAalD,UAAUjG,GACnC2J,EAAa1D,EAAU2D,iBACvB,KAAEC,GAAgB,OAAPN,QAAO,IAAPA,EAAAA,EAAW,GACtBO,EAAW,IACZH,EACHF,SACAC,QACAG,KAAMA,GAAQ,CACZE,MAAOF,EAAKE,MACZC,KAAMH,EAAKG,OAGf/D,EAAUgE,cAAcH,GACxB,MAAO3I,GAEPC,QAAQC,MAAMF,MAKb,SAAS+F,EACdlH,EACAiG,EACAlB,GAEA,MAAMmF,EAAIlK,EAEViJ,EAAUkB,IAAID,EAAGjE,GACjBiE,EAAEjE,UAAYA,EAEd,MAAM,SAAEmE,EAAQ,QAAE7H,GAAYvC,EAExBqK,GAAoBC,EAAAA,EAAAA,WAAS1G,UACjC,IACEuF,EAAaG,aAAaY,EAAGnF,KAC7B,MAAO5D,OAxDkB,KAwE7B,OAXA+I,EAAEE,SAAW,KACXC,IAEAD,KAGFF,EAAE3H,QAAU,KACV2H,EAAEE,SAAWA,EACb7H,EAAQgI,KAAKL,IAGRA,I,mMCnET,MAAMM,EAA8B,IAAIC,QAClCC,EAAsD,IAAIxB,QAC1DyB,EAA6C,IAAIzB,QAY1ChJ,EAAY,CAIvBuG,iBAAmByD,KACjBzB,EAAAA,EAAAA,KAAmByB,GAAG,KACpBA,EAAElF,UAAWvB,EAAAA,EAAAA,IAAWyG,EAAEnC,YAC1BmC,EAAEE,eAMNrC,WAAa/H,IACX,MAAM+H,EAAa4C,EAAavB,IAAIpJ,GAEpC,OADAqJ,EAAAA,EAAAA,GAAUtB,EAAY,0CACfA,GAMT6C,SAAW5K,GACFwK,EAAUK,IAAI7K,GAMvB8K,SAAU,CAAC9K,EAAmBC,KAC5B,MAAM8K,EAAY7K,EAAU0K,SAAS5K,GACrCwK,EAAUQ,IAAIhL,GAEdC,IAEK8K,GACHP,EAAUS,OAAOjL,IAGrBkL,QAAS,CAAIlL,EAAmBC,KAC9B,MAAM8K,EAAY7K,EAAU0K,SAAS5K,GACjC+K,GACFP,EAAUS,OAAOjL,GAGnB,MAAMmL,EAAMlL,IAMZ,OAJI8K,GACFP,EAAUQ,IAAIhL,GAGTmL,IAIX,SAASC,EAAgBpL,GACvB,MAAMqL,EAAaX,EAAiBtB,IAAIpJ,GAExC,OADAqJ,EAAAA,EAAAA,GAAUgC,EAAY,+CACfA,EA8BT,MAAMC,EAAW,CAACtL,EAAmBO,KACnCkI,EAAAA,EAAAA,KAAmBzI,GAAQ,IACzBE,EAAU4K,SAAS9K,GAAQ,KACzB,KACEuL,EAAAA,EAAAA,GACEvL,EACAO,EAAOiL,QAAQvK,IAAK,aAAsB,QAAjB,EAAAA,EAAMwK,mBAAW,aAAjB,EAAmBC,UAAWxD,EAAAA,OAEzD,MAAO/G,GAGP,MADAC,QAAQC,MAAM,8BAA+BF,GACvCA,QAwBP,SAASqF,EACdxG,EACA+H,GAEA,MAAMmC,EAAIlK,EAEVkK,EAAEnC,WAAaA,EACf4C,EAAaR,IAAInK,EAAQ+H,GACzB2C,EAAiBP,IAAInK,EAAQ,IAAIiI,KAGjC,MAAM0D,EAAYpL,GA9BpB,SACEqL,EAEArL,GAEA,KACMsL,EAAAA,EAAAA,KAAgBD,IAClBE,EAAAA,EAAAA,KAAqBF,GAAS,KAC5BN,EAASM,EAASrL,MAGpB+K,EAASM,EAASrL,GAEpB,MAAOY,GAEPC,QAAQC,MAAM,+BAAgC,CAAEA,MAAOF,EAAKZ,YAehBwL,CAAqB7B,EAAG3J,GACtEwH,EAAWiE,YAAYL,GAEvB,MAAM,MAAEM,EAAK,SAAE7B,EAAQ,QAAE7H,GAAY2H,EAyBrC,OAvBAA,EAAE+B,MAASC,KA9Eb,SAA8BlM,EAAmBmM,GAC1CjM,EAAU0K,SAAS5K,IACtBoL,EAAgBpL,GAAQgL,IAAImB,GA6E5BC,CAAqBlC,EAAGgC,GAExBD,EAAMC,IAGRhC,EAAEE,SAAW,MA3Ef,SAA8BpK,GAC5B,MAAMqM,EAAMjB,EAAgBpL,GACtBsM,EAAwBC,MAAM1F,KAAKwF,GAAKG,QAE9CC,EAAAA,EAAAA,GACEvM,EAAU6H,WAAW/H,GACrBsM,EACApE,EAAAA,IAGFmE,EAAIK,QAkEFC,CAAqBzC,GAErBE,KAGFF,EAAE3H,QAAU,KACVwF,EAAW6E,cAAcjB,GACzBzB,EAAE+B,MAAQA,EACV/B,EAAEE,SAAWA,EACb7H,EAAQgI,KAAKL,IAGfA,EAAEzD,iBAAmB,KACnBvG,EAAUuG,iBAAiByD,IAGtBA,I,sEC1LF,MAAMvC,EAAuB/D,UAGlC,MAAMiJ,QAAcC,EAAAA,GAAWzI,GAAQ0I,GACrCD,EAAAA,GAAiBC,EAAI,CAAC,CAAC,UAAW,CAAEC,eAAe,SAG9CC,GAAgBH,EAAAA,GAAaD,EAAO,CAACK,EAAAA,IAAmB,YACzDC,QAAiBL,EAAAA,GACrBG,EACAH,EAAAA,GAAgC,GAAG,IAGrC,GAAIK,EAAQ3E,OACV,OAAO4E,EAAAA,EAAAA,IAAaD,K,uNCZjB,MAAMD,EAAmB,UAKzBtJ,eAAeyJ,EACpBC,GAEA,OAAOA,EAAeC,KAAKC,MAAK5J,gBACxB6J,EAAeH,GAAgB,GAAO1J,UAC1C,MAAMuJ,QAAgBL,EAAAA,GACpBzM,EACAyM,EAAAA,GAAgCQ,EAAeI,QAAQ,IAGrDJ,EAAeK,aAInBL,EAAelN,IAAIwN,UAAS,IAC1BT,EAAQU,SAASC,GAAQC,EAAAA,GAAcT,EAAelN,IAAK0N,aAGvDL,EAAeH,GAAgB,GAAO1J,UAC1C,MAAMoK,QAAgBlB,EAAAA,GAAemB,GAErCX,EAAeI,OAASM,EAAU,QAC5BP,EAAeH,GAAgB,GAAO1J,UAC1C,MAAMsK,QAAYpB,EAAAA,GAAUqB,GAE5Bb,EAAec,QAAUF,eA0BnC,SAASG,EACPf,GAEwB,IADxBgB,EAAK,wDAEL,IACE,MAAOC,GAAiBzB,EAAAA,IACtB0B,EAAAA,EAAAA,IAAWlB,EAAeP,IAC1B,CAACG,GACDoB,EAAQ,YAAc,YAExB,OAAOC,EACP,MAAOpN,GACP,GAA4B,sBAAvBA,EAAc6I,KACjB,OAAO,KAET,MAAM7I,GAIVyC,eAAe6J,EACbH,EACAgB,EACArO,GAEA,GAAIqN,EAAeK,WACjB,OAEF,MAAMtN,EA9CR,SACEiN,GAEwB,IADxBgB,EAAK,wDAEL,IACE,MAAOrB,GAAgBH,EAAAA,IACrB0B,EAAAA,EAAAA,IAAWlB,EAAeP,IAC1B,CAACG,GACDoB,EAAQ,YAAc,YAExB,OAAOrB,EACP,MAAO9L,GACP,GAA4B,sBAAvBA,EAAc6I,KACjB,OAAO,KAET,MAAM7I,GA+BMsN,CAAgBnB,EAAgBgB,GAC9C,OAAIjO,EACKJ,EAAGI,QADZ,EA2CK,MAAM8E,UAA6BuJ,EAAAA,EAmBxCC,YACE3E,EACA5J,GAEC,IADD,SAAEoE,GAAW,GAAoC,uDAAG,GAEpDoK,QAAQ,cAvBsB,MAAI,kEAGpB,GAAK,gDAGL,GAAC,mBACA,GAAC,iBACJC,EAAAA,EAAAA,MAAS,uBACH,GAAK,mFAOD,KAQtBC,KAAK1O,IAAMA,EACX0O,KAAK9E,KAAOxF,EAAQ,UAAMwF,EAAI,aAAcA,EAC5C8E,KAAKC,IAAMjC,EAAAA,GAAWgC,KAAK9E,MAAO+C,GAChCD,EAAAA,GAAiBC,EAAI,CAAC,CAAC,UAAW,CAAEC,eAAe,QAErD8B,KAAKE,WAAaF,KAAKG,QACvBH,KAAKI,aAAeJ,KAAKI,aAAaC,KAAKL,MAC3CA,KAAKvM,QAAUuM,KAAKvM,QAAQ4M,KAAKL,MACjC1O,EAAIK,GAAG,SAAUqO,KAAKI,cACtB9O,EAAIK,GAAG,UAAWqO,KAAKvM,SAGzB,cACEuM,KAAK/B,SAAW+B,KAAKC,IACrB,MAAMK,EAAYrB,EAAAA,GAAsBe,KAAK1O,KAE7C,aADMiN,EAAayB,MACZrB,EACLqB,MACA,GACAlL,gBACQkJ,EAAAA,GAAezM,EAAO+O,GACrBN,QAETO,MAAMhP,IACDyO,KAAKnB,aACRmB,KAAKpO,KAAK,SAAU,CAACoO,OACrBA,KAAKhO,QAAS,GAET,IAAI+B,SAASC,IACdzC,GACFyC,EAAQzC,SAMhB,mBACEsG,EACA2I,EACAC,EACAC,SAEMV,KAAKvB,KAAKC,MAAK5J,gBACbkL,KAAKE,iBACLvB,EAAeqB,MAAM,GAAMlL,gBACzBkJ,EAAAA,GAAezM,EAAOsG,GAC5BmI,KAAKpO,KAAK,QAAS,CAACoO,KAAMU,EAAGC,QAC7BX,KAAKV,SAAW,EACZU,KAAKV,SArMkB,MAuMrBU,KAAKY,iBACPC,aAAab,KAAKY,iBAEpBZ,KAAKY,gBAAkB3I,YAAWnD,gBApHrCA,eACL0J,GAEgB,IADhBsC,IAAU,+DAEJvC,EAAaC,IAEfsC,GAActC,EAAec,SA5FA,YA6FzBX,EAAeH,GAAgB,GAAM1J,gBACnCkJ,EAAAA,GAAezM,EAAO0N,EAAAA,GAAsBT,EAAelN,MACjEkN,EAAe5M,KAAK,QAAS,CAAC4M,UACxBG,EAAeH,GAAgB,GAAM1J,gBACnCkJ,EAAAA,GACJmB,EACAnB,EAAAA,GAAgCQ,EAAeI,QAAQ,UAEnDD,EAAeH,GAAgB,GAAO1J,UAE1C0J,EAAec,cAAgBtB,EAAAA,GAAUqB,YAoGjC0B,CAAWf,MAAM,GACvBA,KAAKY,qBAAkBtK,IACtB0J,KAAKgB,sBAMhBlM,gBACEkL,KAAKnB,YAAa,EACdmB,KAAKY,iBACPC,aAAab,KAAKY,iBAEpBZ,KAAK1O,IAAI2P,IAAI,SAAUjB,KAAKI,cAC5BJ,KAAK1O,IAAI2P,IAAI,UAAWjB,KAAKvM,SAC7B,MAAMwK,QAAW+B,KAAKC,UAChBhC,EAAGiD,QAGXpM,qBACQ6J,EAAeqB,MAAM,GAAMlL,UAC/BvD,EAAMqM,WAIV9I,kBAAkBqM,GAChB,MAAM1B,GAAgBC,EAAAA,EAAAA,IAAWH,EAAiBS,MAAM,IAClD5L,EAA2B,CAC/B8G,KAAMiG,EACN/M,QAAS0D,EAAOC,KAAKkH,EAAAA,GAAoBe,KAAK1O,MAAM8P,SAAS,OAC7DC,UAAW7K,KAAKC,aAEZuH,EAAAA,GAAQyB,EAAehL,KAAKC,UAAUN,GAAU+M,GAGxDrM,kBAAkBqM,GAChB,MAAM1B,GAAgBC,EAAAA,EAAAA,IAAWH,EAAiBS,MAAM,IAClDsB,QAAsBtD,EAAAA,GAAQyB,EAAe0B,GACnD,GAAIG,GAA0C,kBAAlBA,EAA4B,CACtD,MAAMlN,EAAUK,KAAK8M,MAAMD,GACrBE,EAAiB1J,EAAOC,KAC5BkH,EAAAA,GAAoBe,KAAK1O,MACzB8P,SAAS,OACX,OAAOhN,EAAQA,UAAYoN,EAE7B,OAAO,K,0JCnPX,MAAMC,EAA0B,CAC9B3K,EACA4K,IAGApP,QAAQqP,KAAK,+BAAD,OAAgC7K,EAASE,IAAG,cAAM0K,IAEnDE,EAAoC,GAEjDA,EAAgBC,EAAAA,IAAe,CAC7BC,EACAC,EACAjL,EACAkL,KAEAC,EAAAA,GAAsBH,EAASD,EAAAA,IAC/B,MAAMK,EAAkBC,EAAAA,GACtBJ,EACAD,EACAhL,EAASxF,IACTwF,GAGAkL,GACAE,IAAoBC,EAAAA,KACnBrL,EAAS9E,SAGV8E,EAAS9E,QAAS,IAItB4P,EAAgBQ,EAAAA,IAAyB,CACvCN,EACAO,EACAvL,KAEAmL,EAAAA,GAAsBH,EAASQ,EAAAA,IAC/BL,EAAAA,GACEH,EACAS,EAAAA,GACEzL,EAASK,UACTsG,MAAM1F,KAAKjB,EAASK,UAAUqL,YAAYC,WAKhDb,EAAgBU,EAAAA,IAAoB,CAClCI,EACAX,EACAjL,KAEAyL,EAAAA,GACEzL,EAASK,UACTwL,EAAAA,GAA2BZ,GAC3BjL,IAIJ8K,EAAgBgB,EAAAA,IAAe,CAC7BF,EACAX,EACAjL,KAEA+L,EAAAA,GAA6Bd,EAASjL,EAASxF,IAAKmQ,K,2DCrEtD,MAAMqB,EAAyD,CAC7D,EAAGC,EAAAA,EACH,EAAGC,EAAAA,GAGQC,EAAYjN,IACvB,MAAMkN,EAAiBJ,EAAiB9M,GACxC,IAAKkN,EACH,MAAM,IAAI/N,MAAM,6BAAD,OAA8Ba,IAE/C,OAAOkN,M,8NC8BT,MASMC,EAAiBC,GACE,kBAAZA,EACFD,EAAcrL,EAAAA,OAAAA,KAAYsL,EAAS,WAErCtL,EAAAA,OAAAA,KAAYsL,GASRC,EAAc,CACzBvM,EACAwM,EACAtB,KAEA,GAX2BsB,IAEV,kBAARA,GAAoBxL,EAAAA,OAAAA,SAAgBwL,IAAQA,aAAeC,WAS/DC,CAAoBF,GAKzB,IACE,MAAMF,EAAUtL,EAAAA,OAAAA,KAAYwL,GACtBvB,EAAUY,EAAAA,GAAuBS,GACjCtB,EAAUG,EAAAA,KACVwB,EAAcd,EAAAA,GAAqBZ,GACnC2B,EAAiB5M,EAAS8K,gBAAgB6B,GAehD,OAdIC,EACFA,EACE5B,EACAC,EACAjL,EACAkL,EACAyB,GAIFnR,QAAQC,MAAM,8CAAD,OACmCkR,IAG3C3B,EACP,MAAOzP,GAEPC,QAAQC,MAAM,iCAAkCF,QA1BhDC,QAAQqP,KAAK,2BAA4B2B,IA+BvCK,EAAU7O,UACd,MAAM8O,EAAoB,KACxB,GAAI9M,EAAS+M,cAAe,CAC1B,MAAMC,EAAUC,KAAKC,IACnB,GAAKlN,EAASmN,yBAhEO,IACD,KAkEtBhM,WAAW0L,EAASG,EAAShN,KAIjC,IACE,GAAIA,EAAS+M,gBAAkB/M,EAAStF,KAAOsF,EAASoN,aAAc,CAChEpN,EAASD,qBACLC,EAASD,cAAcC,GAG/BA,EAASlF,KAAK,SAAU,CACtB,CACEQ,OAAQ,gBAIZ,MAAM+R,EAAY,IAAIrN,EAASsN,KAC7B1E,EAAAA,EAAAA,IAAW5I,EAASE,KACpBF,EAASG,UAEXkN,EAAUE,WAAa,cACvBvN,EAAStF,GAAK2S,EACdrN,EAASoN,cAAe,EACxBpN,EAASwN,aAAc,EACvBxN,EAAS9E,QAAS,EAElBmS,EAAUI,QAAWlS,IAGnBC,QAAQqP,KAAK,6BAA8BtP,IAG7C,MAAM,QAAE+Q,EAAO,QAAEoB,IAAYvB,EAAAA,EAAAA,GAASnM,EAASd,iBACzCyO,EAAsBrB,EAAQsB,WAAWC,IAC7C,IACE,MAAM7C,EAAUuB,EAAYvM,EAAU6N,GAAG,GACzC,IAAK7N,EAASpB,UAAYoM,GAAWG,EAAAA,GAAgBH,GAAW,EAAG,CACjE,MAAM8C,EAAQ3C,EAAAA,GAAsBH,GACpChL,EAAS+N,KAAKD,IAEhB,MAAOvS,GAAM,IAAD,EAEZC,QAAQC,MACN,kEAGFD,QAAQC,MAAMF,GACE,QAAhB,EAAAyE,EAASlB,eAAO,OAAhB,OAAAkB,EAAmBzE,OAIvB8R,EAAUW,UAAa3S,KACjB2E,EAASjE,WAAcV,EAAM4S,OAGjCjO,EAASkO,sBAAwBC,EAAAA,KACjCT,EAAQrB,EAAchR,EAAM4S,SAG9BZ,EAAUe,QAAWC,IAEnB7S,QAAQ8S,KAAK,YAAaD,GAC1BV,EAAoBY,cACpBvO,EAAStF,QAAK8E,EACdQ,EAASoN,cAAe,GACnBpN,EAASjE,WAAaiE,EAASwN,aAClCxN,EAASwN,aAAc,EACvBxN,EAAS9E,QAAS,EAElBuQ,EAAAA,GACEzL,EAASK,UACTsG,MAAM1F,KAAKjB,EAASK,UAAUqL,YAAYC,QAAQ/F,QAC/C4I,GAAWA,IAAWxO,EAASxF,IAAIiU,WAEtCzO,GAEFA,EAASlF,KAAK,SAAU,CACtB,CACEQ,OAAQ,mBAIZ0E,EAASmN,0BAA4B,EAGnCnN,EAAS+M,eACXD,KAIJO,EAAUqB,OAAS,KAEjBlT,QAAQ8S,KAAK,cACbtO,EAASkO,sBAAwBC,EAAAA,KACjCnO,EAASoN,cAAe,EACxBpN,EAASwN,aAAc,EACvBxN,EAASmN,yBAA2B,EACpCnN,EAASlF,KAAK,SAAU,CACtB,CACEQ,OAAQ,eAIZ,MAAM0P,EAAUG,EAAAA,KAKhB,GAJAA,EAAAA,GAAsBH,EAASD,EAAAA,IAC/BM,EAAAA,GAA4BL,EAAShL,EAASxF,KAC9CwF,EAAS+N,KAAK5C,EAAAA,GAAsBH,IAEM,MAAtChL,EAASK,UAAU2D,gBAAyB,CAC9C,MAAM2K,EAAwBxD,EAAAA,KAC9BA,EAAAA,GAAsBwD,EAAuBnD,EAAAA,IAC7CL,EAAAA,GACEwD,EACAlD,EAAAA,GAAwCzL,EAASK,UAAW,CAC1DL,EAASxF,IAAIiU,YAGjBzO,EAAS+N,KAAK5C,EAAAA,GAAsBwD,OAI1C,MAAOpT,GAEPC,QAAQC,MAAMF,GACVyE,EAAStF,IAAMsF,EAAStF,GAAGkU,aAAe5O,EAAStF,GAAGmU,MACxD7O,EAAStF,GAAG0P,QAEdpK,EAAStF,QAAK8E,EACdQ,EAASoN,cAAe,EACxBN,MAIEgC,EAAmB,CAAC9O,EAA6BwM,KACrD,IAAIxM,EAASjE,YAAaiE,EAASpB,UAG/BoB,EAASwN,YACX,IACExN,EAAS+N,KAAKvB,GACd,MAAOjR,GACP,GAEE,oDADCA,EAAc+Q,QAGf,MAAM/Q,IAMd,MAAMwT,UACIjG,EAAAA,EAqCRC,YAAYvO,GAAuD,IAA5CwU,EAAgB,uDAAG,CAAE9P,gBAAiB,GAC3D8J,QAAQ,wUAxBI,GAAK,yBACJ,GAAK,iCACI,GAAC,oCACE,GAAC,gFAGhB,GAAK,sBACU,IAAE,4CACiBtE,EAAAA,EAAAA,UAC5CwE,KAAK+F,+BAA+B1F,KAAKL,MA9OnB,MAgPvB,+BAC+B,IAAE,qDACqBxE,EAAAA,EAAAA,UACrDwE,KAAKgG,wCAAwC3F,KAAKL,MAnP5B,MAqPvB,2BAEwB,GAAK,oBACZ,GAAK,2BACuC,GAAC,2EAoKxB,KAAO,IAAD,EAG3C,IAAKiG,UAAUC,QAAUlG,KAAKxO,KAAOwO,KAAKxO,GAAG2U,YAAqB,QAAX,EAAInG,KAAKxO,UAAE,OAAP,EAASmU,MAAO,CACzE3F,KAAK6D,eAAgB,EACrB,IAEEvR,QAAQ8S,KAAK,yCACbpF,KAAKxO,GAAG0P,QACR,MAAO7O,GAEPC,QAAQqP,KAAK,2BAA4BtP,QA1K7C,MAAM,SACJqD,GAAW,EAAK,QAChB/B,GAAU,EAAI,UACdwD,EAAS,kBACTtB,EAAoBuQ,UAAS,eAC7B9O,GAAiB,EAAE,SACnBL,EAAQ,cACRJ,EAAa,QACbjB,EAAO,gBACPI,GACE8P,EAEJ9F,KAAKtK,SAAWA,EAChBsK,KAAK1O,IAAMA,EACX0O,KAAK/I,SAAWA,EAChB+I,KAAKnJ,cAAgBA,EACrBmJ,KAAKoE,IAAMvO,EACXmK,KAAKpK,QAAUA,EACfoK,KAAKhK,gBAAkBA,EAElBmB,EAIH6I,KAAK7I,UAAYA,GAHjB6I,KAAK7I,UAAY,IAAIoL,EAAAA,GAA4BjR,GACjD0O,KAAKqG,gBAAiB,GAKxBrG,KAAK4B,gBAAkBA,EAAAA,EAAAA,QACvB5B,KAAKsG,IAAMC,EAAAA,IACXvG,KAAK6D,cAAgBlQ,EAEjB2D,EAAiB,IACnB0I,KAAKwG,gBAAkBC,aAAY,KACjC,GAAIzG,KAAKxO,IAAMwO,KAAKsE,cAAgBtE,KAAKtK,SAAU,CAEjD,MAAMoM,EAAUG,EAAAA,KAChBA,EAAAA,GAAsBH,EAASD,EAAAA,IAC/BM,EAAAA,GAA4BL,EAASxQ,GACrC,IACE0O,KAAK6E,KAAK5C,EAAAA,GAAsBH,IAChC,MAAOzP,GACP,GAEE,oDADCA,EAAc+Q,QAGf,MAAM/Q,MAIXiF,IAGD,qBAAsBoP,SACxBA,OAAOC,iBAAiB,SAAU3G,KAAK4G,8BACvCF,OAAOC,iBAAiB,UAAW3G,KAAK4G,+BAG1C5G,KAAK6G,eAAiB7G,KAAK6G,eAAexG,KAAKL,MAC/CA,KAAK8G,qBAAuB9G,KAAK8G,qBAAqBzG,KAAKL,MAC3DA,KAAK+G,wBAA0B/G,KAAK+G,wBAAwB1G,KAAKL,MAE5DA,KAAKtK,UACRsK,KAAK1O,IAAIK,GAAG,SAAUqO,KAAK6G,gBAGP,qBAAXG,OACTA,OAAOL,iBAAiB,eAAgB3G,KAAK8G,sBACjB,qBAAZG,GAChBA,EAAQtV,GAAG,QAAQ,IAAMqO,KAAK8G,uBAE3BpR,GACHsK,KAAK7I,UAAUxF,GAAG,SAAUqO,KAAK+G,yBAEnC/G,KAAKkH,eAAiBT,aAAY,KAK7B,IAAD,EAHAzG,KAAKsE,aA1UmB,IA4UtBW,EAAAA,KAAqBjF,KAAKgF,wBAI5BhF,KAAK6D,eAAgB,EACd,QAAP,EAAA7D,KAAKxO,UAAE,OAAP,EAAS0P,WAEViG,KAECxT,GACFqM,KAAKrM,UAILoD,cAAUA,GACZ,GAAIA,EAAW,CACb,MAAMC,EAAM,IAAIoQ,IAAIrQ,GAAWsQ,KAC/BrH,KAAKhJ,IAAMA,GAIXD,gBACF,OAAOiJ,KAAKhJ,IAGd6N,KAAKzB,GACCpD,KAAKsE,aAAetE,KAAKxO,IAC3BwO,KAAKxO,GAAGqT,KApWSzB,IACrBtL,EAAAA,OAAAA,KAAYsL,GAAShC,SAAS,UAmWbkG,CAAclE,IAIvByD,eAAehP,EAAoB+E,GACrCA,IAAWoD,OAASA,KAAKtK,UAAYsK,KAAKsE,cAC5CtE,KAAKuH,WAAW7I,KAAK7G,GACrBmI,KAAKwH,mCAIDzB,iCACN,MAAM0B,EAAShK,MAAM1F,KAAKiI,KAAKuH,YAC/BvH,KAAKuH,WAAa,GAClB,MAAMzF,EAAUG,EAAAA,KAChBA,EAAAA,GAAsBH,EAASD,EAAAA,IAC/BM,EAAAA,GAAyBL,GAASxD,EAAAA,EAAAA,IAAamJ,IAC3CxF,EAAAA,GAAgBH,GAAW,GAC7B8D,EAAiB5F,KAAMiC,EAAAA,GAAsBH,IAE/C9B,KAAKpO,KAAK,QAAS,CAACoO,OAGd+G,wBAAwBW,GAC9B,MAAM,MAAEC,EAAK,QAAEC,EAAO,QAAEC,GAAYH,EAC9BI,EAAiBH,EAAMI,OAAOH,GAASG,OAAOF,GACpD7H,KAAKgI,oBAAsBhI,KAAKgI,oBAAoBD,OAAOD,GAC3D9H,KAAKiI,2CAGCjC,0CACN,MAAM8B,EAAiBrK,MAAM1F,KAAKiI,KAAKgI,qBACvC,GAAIF,EAAepO,OAAS,EAAG,CAC7BsG,KAAKgI,oBAAsB,GAC3B,MAAMnQ,EAAS0K,EAAAA,GACbvC,KAAK7I,UACL2Q,GAEIhG,EAAUG,EAAAA,KAChBA,EAAAA,GAAsBH,EAASQ,EAAAA,IAC/BL,EAAAA,GAA4BH,EAASjK,GACjCoK,EAAAA,GAAgBH,GAAW,GAC7B8D,EAAiB5F,KAAMiC,EAAAA,GAAsBH,KAK3CgF,uBACNvE,EAAAA,GACEvC,KAAK7I,UACL,CAAC6I,KAAK1O,IAAIiU,UACV,iBAoBAvT,aACF,OAAOgO,KAAKkI,QAGVlW,WAAOmW,GACLnI,KAAKkI,UAAYC,IACnBnI,KAAKkI,QAAUC,EACfnI,KAAKpO,KAAK,SAAU,CAACuW,IACrBnI,KAAKpO,KAAK,OAAQ,CAACuW,KAIvB1U,UACEuM,KAAKnN,WAAY,EACY,IAAzBmN,KAAKwG,iBACP4B,cAAcpI,KAAKwG,iBAEjBxG,KAAKkH,gBACPkB,cAAcpI,KAAKkH,gBAGrBlH,KAAKpM,aACiB,qBAAXoT,OACTA,OAAOqB,oBAAoB,eAAgBrI,KAAK8G,sBACpB,qBAAZG,GAChBA,EAAQhG,IAAI,QAAQ,IAAMjB,KAAK8G,uBAEjC9G,KAAK7I,UAAU8J,IAAI,SAAUjB,KAAK+G,yBAC9B/G,KAAKqG,gBACPrG,KAAK7I,UAAU1D,UAGjBuM,KAAK1O,IAAI2P,IAAI,SAAUjB,KAAK6G,gBAExB,wBAAyBH,SAC3BA,OAAO2B,oBAAoB,SAAUrI,KAAK4G,8BAC1CF,OAAO2B,oBAAoB,UAAWrI,KAAK4G,+BAG7C9G,MAAMrM,UAGRG,aAKE,GAJIoM,KAAKsE,aACPtE,KAAK+F,iCAEP/F,KAAK6D,eAAgB,EACN,MAAX7D,KAAKxO,GAAY,CACnB,IACEwO,KAAKxO,GAAG0P,QACR,MAAO7O,IAGT2N,KAAKpO,KAAK,SAAU,CAClB,CACEQ,OAAQ,mBAMhB0C,gBACEkL,KAAK6D,eAAgB,EAChB7D,KAAKsE,aAAgBtE,KAAKxO,UACvBmS,EAAQ3D,OAKb,MAAM3I,EAA0B,SACrC/F,GAEwB,IADxBwU,EAAgB,uDAAG,CAAE9P,gBAAiB,GAEtC,OAAO,IAAI6P,EAAkBvU,EAAKwU","sources":["../../docsync/src/asLocalEditor.ts","../../docsync/src/docSyncEditor.ts","../../docsync/src/docsync.ts","../../docsync/src/getLocalNotebookUpdates.ts","../../docsync/src/setupUndo.ts","../../docsync/src/utils/ensureInitialDocument.ts","../../slate-yjs/src/plugin/cursorEditor.ts","../../slate-yjs/src/plugin/yjsEditor.ts","../../y-indexeddb/src/fetchUpdatesAsBuffer.ts","../../y-indexeddb/src/y-indexeddb.ts","../../y-websocket/src/messageHandlers.ts","../../y-websocket/src/receive/index.ts","../../y-websocket/src/y-websocket.ts"],"sourcesContent":["import { MyEditor } from '@decipad/editor-types';\nimport { YjsEditor } from '@decipad/slate-yjs';\n\nexport const asLocalEditor = <T>(editor: MyEditor, fn: () => T): T => {\n  return YjsEditor.asLocal(editor as unknown as YjsEditor, fn);\n};\n","import { CursorEditor, toSlateDoc, YjsEditor } from '@decipad/slate-yjs';\nimport { IndexeddbPersistence } from '@decipad/y-indexeddb';\nimport { TWebSocketProvider } from '@decipad/y-websocket';\nimport EventEmitter from 'events';\nimport md5 from 'md5';\nimport { Doc as YDoc } from 'yjs';\nimport { BehaviorSubject } from 'rxjs';\nimport { MyEditor } from '@decipad/editor-types';\nimport { supportBigIntToJSON } from '@decipad/utils';\nimport {\n  DocSyncEditor,\n  OnLoadedCallback,\n  OnSavedCallback,\n  SyncSource,\n  OnConnectedCallback,\n} from './types';\n\nsupportBigIntToJSON();\n\nexport function docSyncEditor<E extends MyEditor>(\n  editor: E & YjsEditor & CursorEditor,\n  doc: YDoc,\n  store?: IndexeddbPersistence,\n  ws?: TWebSocketProvider\n): E & DocSyncEditor {\n  const events = new EventEmitter();\n\n  store?.on('synced', function onStoreSynced() {\n    events.emit('loaded', 'local');\n  });\n  store?.on(\n    'saved',\n    function onStoreSaved(_provider: IndexeddbPersistence, isLocal?: boolean) {\n      const source: SyncSource = isLocal ? 'local' : 'remote';\n      events.emit('saved', source);\n    }\n  );\n\n  if (ws) {\n    ws.on('synced', function onWsSynced(synced: boolean) {\n      if (synced) {\n        events.emit('loaded', 'remote');\n        isSavedRemotely.next(true);\n      }\n    });\n    ws.on('saved', function onWsSaved() {\n      events.emit('saved', 'remote');\n      isSavedRemotely.next(true);\n    });\n    ws.on('status', function onWsStatus(event: { status: string }) {\n      if (event.status === 'connected') {\n        events.emit('connected');\n      }\n    });\n    ws.on('error', (err: Error) => {\n      // eslint-disable-next-line no-console\n      console.error('Error caught in websocket:', err);\n    });\n  }\n\n  const hasLocalChanges = new BehaviorSubject<boolean>(false);\n  const isSavedRemotely = new BehaviorSubject<boolean>(false);\n\n  const onceStoreSynced = () => {\n    let savedCount = 0;\n    events.on('saved', (source: SyncSource) => {\n      savedCount += 1;\n      if (savedCount > 1) {\n        savedCount = 1;\n        if (source === 'local') {\n          hasLocalChanges.next(true);\n          isSavedRemotely.next(false);\n        }\n      }\n    });\n  };\n  if (store) {\n    store.once('synced', onceStoreSynced);\n  } else {\n    onceStoreSynced();\n  }\n\n  let destroyed = false;\n  events.once('destroyed', () => {\n    destroyed = true;\n  });\n\n  const useEditor = Object.assign(editor, {\n    onLoaded(cb: OnLoadedCallback) {\n      events.on('loaded', cb);\n    },\n    offLoaded(cb: OnLoadedCallback) {\n      events.removeListener('loaded', cb);\n    },\n    onSaved(cb: OnSavedCallback) {\n      events.on('saved', cb);\n    },\n    offSaved(cb: OnSavedCallback) {\n      events.removeListener('saved', cb);\n    },\n    onConnected(cb: OnConnectedCallback) {\n      events.on('connected', cb);\n    },\n    onDestroyed(cb: () => void) {\n      events.on('destroyed', cb);\n    },\n    offDestroyed(cb: () => void) {\n      events.removeListener('destroyed', cb);\n    },\n    destroy() {\n      events.emit('destroyed');\n      events.removeAllListeners();\n      doc.destroy();\n      store?.destroy();\n      ws?.destroy();\n    },\n    connect() {\n      ws?.connect();\n    },\n    disconnect() {\n      ws?.disconnect();\n    },\n    hasLocalChanges() {\n      return hasLocalChanges;\n    },\n    isSavedRemotely() {\n      return isSavedRemotely;\n    },\n    removeLocalChanges() {\n      return store?.remove() || Promise.resolve();\n    },\n    setLoadedRemotely() {\n      events.emit('loaded', 'remote');\n    },\n    isDocSyncEnabled: true,\n    markVersion: (version: string) =>\n      store?.markVersion(version) || Promise.resolve(),\n    sameVersion: (version: string) =>\n      store?.sameVersion(version) || Promise.resolve(false),\n    equals: (checksumRemote: string) => {\n      const checksumLocal = md5(JSON.stringify(toSlateDoc(doc.getArray())));\n      return checksumLocal === checksumRemote;\n    },\n    get destroyed() {\n      return destroyed;\n    },\n  });\n\n  return useEditor;\n}\n","import { Session } from 'next-auth';\nimport { Awareness } from 'y-protocols/awareness';\nimport { applyUpdate, Doc as YDoc } from 'yjs';\nimport { PlateEditor } from '@udecode/plate';\nimport { fetch } from '@decipad/fetch';\nimport { SyncElement, withCursor, withYjs } from '@decipad/slate-yjs';\nimport { IndexeddbPersistence } from '@decipad/y-indexeddb';\nimport {\n  TWebSocketProvider,\n  createWebsocketProvider,\n} from '@decipad/y-websocket';\nimport { MyEditor } from '@decipad/editor-types';\nimport { supports } from '@decipad/support';\nimport { docSyncEditor } from './docSyncEditor';\nimport { ensureInitialDocument } from './utils/ensureInitialDocument';\nimport { setupUndo } from './setupUndo';\nimport { asLocalEditor } from './asLocalEditor';\n\nconst tokenTimeoutMs = 60 * 1000;\n\ninterface DocSyncConnectionParams {\n  url: string;\n  token: string;\n}\n\nexport interface DocSyncOptions {\n  editor: MyEditor;\n  readOnly?: boolean;\n  authSecret?: string;\n  WebSocketPolyfill?: typeof WebSocket;\n  onError?: (event: Error | Event) => void;\n  ws?: boolean;\n  connect?: boolean;\n  connectionParams?: DocSyncConnectionParams;\n  initialState?: string;\n  protocolVersion: number;\n}\n\nasync function fetchToken(): Promise<string> {\n  const resp = await fetch(`/api/auth/token?for=pubsub`);\n  if (!resp?.ok) {\n    throw new Error(\n      `Error fetching token: response code was ${resp.status}: ${\n        resp.statusText\n      }. response was ${(await resp?.text()) || JSON.stringify(resp)}`\n    );\n  }\n  return resp?.text();\n}\n\nasync function wsAddress(docId: string): Promise<string> {\n  return `${await (await fetch('/api/ws'))?.text()}?doc=${encodeURIComponent(\n    docId\n  )}&protocol=2`;\n}\n\nexport function createDocSyncEditor(\n  docId: string,\n  {\n    editor,\n    readOnly = false,\n    authSecret,\n    onError,\n    ws = true,\n    connect = ws,\n    WebSocketPolyfill,\n    connectionParams,\n    initialState,\n    protocolVersion,\n  }: DocSyncOptions,\n  getSession: () => Session | undefined = () => undefined\n) {\n  (editor as PlateEditor).children = [];\n  const doc = new YDoc();\n  const store = supports('indexeddb')\n    ? new IndexeddbPersistence(docId, doc, { readOnly })\n    : undefined;\n  const initialTokenTime = Date.now();\n\n  const isInitialTokenStale = () =>\n    Date.now() - initialTokenTime > tokenTimeoutMs;\n\n  const getToken = () =>\n    isInitialTokenStale() ? undefined : connectionParams?.token;\n\n  const beforeConnect = async (provider: TWebSocketProvider) => {\n    try {\n      provider.serverUrl = connectionParams?.url\n        ? `${connectionParams.url}`\n        : await wsAddress(docId);\n      provider.protocol = authSecret || getToken() || (await fetchToken());\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(err);\n    }\n  };\n\n  let wsp: TWebSocketProvider | undefined;\n  let awareness: Awareness | undefined;\n\n  const startWebsocket =\n    ws && supports('websockets') && (!readOnly || initialState == null);\n  if (startWebsocket) {\n    wsp = createWebsocketProvider(doc, {\n      WebSocketPolyfill,\n      readOnly,\n      connect: false,\n      beforeConnect,\n      resyncInterval: 60000,\n      onError,\n      protocolVersion,\n    });\n    awareness = wsp.awareness;\n  } else {\n    awareness = new Awareness(doc);\n  }\n\n  // Yjs editor\n  const shared = doc.getArray<SyncElement>();\n  const yjsEditor = withYjs(editor as MyEditor, shared);\n\n  yjsEditor.synchronizeValue();\n\n  let destroyed = false;\n  let synced = false;\n\n  const onceSynced = () => {\n    if (synced) {\n      return;\n    }\n    synced = true;\n    if (connect && !destroyed) {\n      if (initialState != null) {\n        try {\n          const update = Buffer.from(initialState, 'base64');\n          applyUpdate(doc, update);\n          setTimeout(() => syncEditor.setLoadedRemotely(), 0);\n        } catch (err) {\n          // eslint-disable-next-line no-console\n          console.error('Error applying initial update', err);\n        }\n      }\n      wsp?.connect();\n    }\n  };\n\n  if (store) {\n    store.once('synced', onceSynced);\n  } else {\n    setTimeout(onceSynced, 0);\n  }\n\n  // Cursor editor\n  const cursorEditor = withCursor(yjsEditor, awareness, getSession);\n\n  const { normalizeNode } = cursorEditor;\n  cursorEditor.normalizeNode = (entry) =>\n    asLocalEditor(cursorEditor, () => normalizeNode(entry));\n\n  // Sync editor\n  let syncEditor = docSyncEditor(cursorEditor, doc, store, wsp);\n  syncEditor.destroy = () => {\n    destroyed = true;\n    store?.destroy();\n    wsp?.destroy();\n  };\n\n  syncEditor.isDocSyncEnabled = true;\n\n  let loadedLocally = false;\n  let loadedRemotely = false;\n\n  const onLoaded = (source: 'remote' | 'local') => {\n    if (\n      !readOnly &&\n      !destroyed &&\n      !loadedRemotely &&\n      (!ws || source === 'remote')\n    ) {\n      ensureInitialDocument(editor);\n    }\n    if (source === 'remote') {\n      loadedRemotely = true;\n    }\n    if (source === 'local') {\n      loadedLocally = true;\n    }\n    if (loadedRemotely && loadedLocally) {\n      syncEditor.offLoaded(onLoaded);\n    }\n  };\n  syncEditor.onLoaded(onLoaded);\n\n  syncEditor = setupUndo(syncEditor);\n\n  syncEditor.isReadOnly = readOnly;\n\n  return syncEditor;\n}\n","import { fetchUpdatesAsBuffer } from '@decipad/y-indexeddb';\n\nexport const getLocalNotebookUpdates = async (\n  docId: string\n): Promise<Uint8Array | undefined> => fetchUpdatesAsBuffer(docId);\n","import { slateYjsSymbol } from 'libs/slate-yjs/src/model';\nimport { UndoManager } from 'yjs';\nimport { DocSyncEditor } from '.';\n\nexport const setupUndo = (editor: DocSyncEditor): DocSyncEditor => {\n  let captureTransaction = true;\n  const undoManager = new UndoManager(editor.sharedType, {\n    trackedOrigins: new Set([slateYjsSymbol]),\n    captureTransaction: () => captureTransaction,\n    captureTimeout: 200,\n  });\n  editor.undo = () => {\n    undoManager.undo();\n  };\n  editor.redo = () => {\n    undoManager.redo();\n  };\n  editor.withoutCapturingUndo = (cb: () => void) => {\n    const beforeCapturing = captureTransaction;\n    captureTransaction = false;\n    try {\n      cb();\n    } finally {\n      captureTransaction = beforeCapturing;\n    }\n  };\n  editor.undoManager = undoManager;\n\n  return editor;\n};\n","import { nanoid } from 'nanoid';\nimport { H1Element, MyEditor, ParagraphElement } from '@decipad/editor-types';\nimport {\n  ELEMENT_H1,\n  ELEMENT_PARAGRAPH,\n  insertNodes,\n  withoutNormalizing,\n} from '@udecode/plate';\n\nexport function ensureInitialDocument(editor: MyEditor): void {\n  const { children } = editor;\n  if (children.length > 1) {\n    return;\n  }\n  if (children.length === 0) {\n    withoutNormalizing(editor, () => {\n      insertNodes<H1Element>(\n        editor,\n        {\n          type: ELEMENT_H1,\n          children: [{ text: 'My notebook title' }],\n          id: nanoid(),\n        },\n        { at: [0] }\n      );\n      insertNodes<ParagraphElement>(\n        editor,\n        {\n          type: ELEMENT_PARAGRAPH,\n          children: [{ text: '' }],\n          id: nanoid(),\n        },\n        { at: [1] }\n      );\n    });\n  }\n}\n","import { TEditor } from '@udecode/plate';\nimport invariant from 'tiny-invariant';\nimport { Awareness } from 'y-protocols/awareness';\nimport { debounce } from 'lodash';\nimport { Session } from 'next-auth';\nimport { YjsEditor } from './yjsEditor';\n\nconst AWARENESS: WeakMap<TEditor, Awareness> = new WeakMap();\n\nconst cursorChangeDebounceMs = 2_000;\n\nexport interface CursorEditor extends YjsEditor {\n  awareness: Awareness;\n  destroy: () => void;\n}\n\nexport const CursorEditor = {\n  awareness(editor: CursorEditor): Awareness {\n    const awareness = AWARENESS.get(editor);\n    invariant(awareness, 'CursorEditor without attaches awareness');\n    return awareness;\n  },\n\n  updateCursor: (editor: CursorEditor, session: Session | undefined): void => {\n    try {\n      const { selection } = editor;\n\n      const { anchor } = selection ?? {};\n      const { focus } = selection ?? {};\n\n      const awareness = CursorEditor.awareness(editor);\n      const localState = awareness.getLocalState();\n      const { user } = session ?? {};\n      const newState = {\n        ...localState,\n        anchor,\n        focus,\n        user: user && {\n          email: user.email,\n          name: user.name,\n        },\n      };\n      awareness.setLocalState(newState);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(err);\n    }\n  },\n};\n\nexport function withCursor<T extends YjsEditor>(\n  editor: T,\n  awareness: Awareness,\n  getSession: () => Session | undefined\n): T & CursorEditor {\n  const e = editor as T & CursorEditor;\n\n  AWARENESS.set(e, awareness);\n  e.awareness = awareness;\n\n  const { onChange, destroy } = editor;\n\n  const debouncedOnChange = debounce(async () => {\n    try {\n      CursorEditor.updateCursor(e, getSession());\n    } catch (err) {\n      // do nothing, not important\n    }\n  }, cursorChangeDebounceMs);\n\n  e.onChange = () => {\n    debouncedOnChange();\n\n    onChange();\n  };\n\n  e.destroy = () => {\n    e.onChange = onChange;\n    destroy.call(e);\n  };\n\n  return e;\n}\n","import {\n  isHistoryEditor,\n  TEditor,\n  TOperation,\n  withoutNormalizing,\n  withoutSavingHistory,\n} from '@udecode/plate';\nimport invariant from 'tiny-invariant';\nimport * as Y from 'yjs';\nimport { applyYjsEvents } from '../applyToSlate';\nimport applySlateOps from '../applyToYjs';\nimport { SharedType, slateYjsSymbol } from '../model';\nimport { toSlateDoc } from '../utils';\n\nconst IS_REMOTE: WeakSet<TEditor> = new WeakSet();\nconst LOCAL_OPERATIONS: WeakMap<TEditor, Set<TOperation>> = new WeakMap();\nconst SHARED_TYPES: WeakMap<TEditor, SharedType> = new WeakMap();\n\nexport interface YjsEditor extends TEditor {\n  sharedType: SharedType;\n  destroy: () => void;\n  synchronizeValue: () => void;\n}\n\nexport type WithYjsOptions = {\n  synchronizeValue?: boolean;\n};\n\nexport const YjsEditor = {\n  /**\n   * Set the editor value to the content of the to the editor bound shared type.\n   */\n  synchronizeValue: (e: YjsEditor): void => {\n    withoutNormalizing(e, () => {\n      e.children = toSlateDoc(e.sharedType) as YjsEditor['children'];\n      e.onChange();\n    });\n  },\n  /**\n   * Returns whether the editor currently is applying remote changes.\n   */\n  sharedType: (editor: YjsEditor): SharedType => {\n    const sharedType = SHARED_TYPES.get(editor);\n    invariant(sharedType, 'YjsEditor without attached shared type');\n    return sharedType;\n  },\n\n  /**\n   * Returns whether the editor currently is applying remote changes.\n   */\n  isRemote: (editor: YjsEditor): boolean => {\n    return IS_REMOTE.has(editor);\n  },\n\n  /**\n   * Performs an action as a remote operation.\n   */\n  asRemote: (editor: YjsEditor, fn: () => void): void => {\n    const wasRemote = YjsEditor.isRemote(editor);\n    IS_REMOTE.add(editor);\n\n    fn();\n\n    if (!wasRemote) {\n      IS_REMOTE.delete(editor);\n    }\n  },\n  asLocal: <T>(editor: YjsEditor, fn: () => T): T => {\n    const wasRemote = YjsEditor.isRemote(editor);\n    if (wasRemote) {\n      IS_REMOTE.delete(editor);\n    }\n\n    const ret = fn();\n\n    if (wasRemote) {\n      IS_REMOTE.add(editor);\n    }\n\n    return ret;\n  },\n};\n\nfunction localOperations(editor: YjsEditor): Set<TOperation> {\n  const operations = LOCAL_OPERATIONS.get(editor);\n  invariant(operations, 'YjsEditor without attached local operations');\n  return operations;\n}\n\nfunction trackLocalOperations(editor: YjsEditor, operation: TOperation): void {\n  if (!YjsEditor.isRemote(editor)) {\n    localOperations(editor).add(operation);\n  }\n}\n\n/**\n * Applies a slate operations to the bound shared type.\n */\nfunction applyLocalOperations(editor: YjsEditor): void {\n  const ops = localOperations(editor);\n  const editorLocalOperations = Array.from(ops).flat();\n\n  applySlateOps(\n    YjsEditor.sharedType(editor),\n    editorLocalOperations,\n    slateYjsSymbol\n  );\n\n  ops.clear();\n}\n\n/**\n * Apply Yjs events to slate\n */\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst yjsApply = (editor: YjsEditor, events: Y.YEvent<any>[]) =>\n  withoutNormalizing(editor, () =>\n    YjsEditor.asRemote(editor, () => {\n      try {\n        applyYjsEvents(\n          editor,\n          events.filter((event) => event.transaction?.origin !== slateYjsSymbol)\n        );\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.error('Error applying remote event', err);\n        throw err;\n      }\n    })\n  );\n\nfunction applyRemoteYjsEvents(\n  _editor: YjsEditor,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  events: Y.YEvent<any>[]\n): void {\n  try {\n    if (isHistoryEditor(_editor)) {\n      withoutSavingHistory(_editor, () => {\n        yjsApply(_editor, events);\n      });\n    } else {\n      yjsApply(_editor, events);\n    }\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error('Error applying remote events', { error: err, events });\n  }\n}\n\nexport function withYjs<T extends TEditor>(\n  editor: T,\n  sharedType: SharedType\n): T & YjsEditor {\n  const e = editor as T & YjsEditor;\n\n  e.sharedType = sharedType;\n  SHARED_TYPES.set(editor, sharedType);\n  LOCAL_OPERATIONS.set(editor, new Set());\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const observer = (events: Y.YEvent<any>[]) => applyRemoteYjsEvents(e, events);\n  sharedType.observeDeep(observer);\n\n  const { apply, onChange, destroy } = e;\n\n  e.apply = (op: TOperation) => {\n    trackLocalOperations(e, op);\n\n    apply(op);\n  };\n\n  e.onChange = () => {\n    applyLocalOperations(e);\n\n    onChange();\n  };\n\n  e.destroy = () => {\n    sharedType.unobserveDeep(observer);\n    e.apply = apply;\n    e.onChange = onChange;\n    destroy.call(e);\n  };\n\n  e.synchronizeValue = () => {\n    YjsEditor.synchronizeValue(e);\n  };\n\n  return e;\n}\n","import * as idb from 'lib0/indexeddb';\nimport { mergeUpdates } from 'yjs';\nimport { updatesStoreName } from './y-indexeddb';\n\nexport const fetchUpdatesAsBuffer = async (\n  docId: string\n): Promise<Uint8Array | undefined> => {\n  const docDB = await idb.openDB(docId, (db) =>\n    idb.createStores(db, [['updates', { autoIncrement: true }]])\n  );\n\n  const [updatesStore] = idb.transact(docDB, [updatesStoreName], 'readonly');\n  const updates = (await idb.getAll(\n    updatesStore,\n    idb.createIDBKeyRangeLowerBound(0, false)\n  )) as Uint8Array[];\n\n  if (updates.length) {\n    return mergeUpdates(updates);\n  }\n  return undefined;\n};\n","import * as Y from 'yjs';\nimport * as idb from 'lib0/indexeddb';\nimport { Observable } from 'lib0/observable';\nimport { getDefined } from '@decipad/utils';\nimport { fnQueue } from '@decipad/fnqueue';\n\nexport const updatesStoreName = 'updates';\nexport const versionsStoreName = 'versions';\n\nexport const PREFERRED_TRIM_SIZE = 500;\n\nexport async function fetchUpdates(\n  idbPersistence: IndexeddbPersistence\n): Promise<void> {\n  return idbPersistence._mux.push(async () => {\n    await maybeWithStore(idbPersistence, false, async (store) => {\n      const updates = await idb.getAll(\n        store,\n        idb.createIDBKeyRangeLowerBound(idbPersistence._dbref, false)\n      );\n\n      if (idbPersistence._destroyed) {\n        return;\n      }\n\n      idbPersistence.doc.transact(() =>\n        updates.forEach((val) => Y.applyUpdate(idbPersistence.doc, val))\n      );\n\n      await maybeWithStore(idbPersistence, false, async (store2) => {\n        const lastKey = await idb.getLastKey(store2);\n        // eslint-disable-next-line no-param-reassign\n        idbPersistence._dbref = lastKey + 1;\n        await maybeWithStore(idbPersistence, false, async (store3) => {\n          const cnt = await idb.count(store3);\n          // eslint-disable-next-line no-param-reassign\n          idbPersistence._dbsize = cnt;\n        });\n      });\n    });\n  });\n}\n\nfunction getUpdatesStore(\n  idbPersistence: IndexeddbPersistence,\n  write = false\n): IDBObjectStore | null {\n  try {\n    const [updatesStore] = idb.transact(\n      getDefined(idbPersistence.db),\n      [updatesStoreName],\n      write ? 'readwrite' : 'readonly'\n    );\n    return updatesStore;\n  } catch (err) {\n    if ((err as Error).name === 'InvalidStateError') {\n      return null;\n    }\n    throw err;\n  }\n}\n\nfunction getVersionsStore(\n  idbPersistence: IndexeddbPersistence,\n  write = false\n): IDBObjectStore | null {\n  try {\n    const [versionsStore] = idb.transact(\n      getDefined(idbPersistence.db),\n      [updatesStoreName],\n      write ? 'readwrite' : 'readonly'\n    );\n    return versionsStore;\n  } catch (err) {\n    if ((err as Error).name === 'InvalidStateError') {\n      return null;\n    }\n    throw err;\n  }\n}\n\nasync function maybeWithStore<T>(\n  idbPersistence: IndexeddbPersistence,\n  write: boolean,\n  fn: (store: IDBObjectStore) => Promise<T> | void\n): Promise<T | void> {\n  if (idbPersistence._destroyed) {\n    return;\n  }\n  const store = getUpdatesStore(idbPersistence, write);\n  if (store) {\n    return fn(store);\n  }\n}\n\nexport async function storeState(\n  idbPersistence: IndexeddbPersistence,\n  forceStore = true\n): Promise<void> {\n  await fetchUpdates(idbPersistence);\n\n  if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {\n    await maybeWithStore(idbPersistence, true, async (store) => {\n      await idb.addAutoKey(store, Y.encodeStateAsUpdate(idbPersistence.doc));\n      idbPersistence.emit('saved', [idbPersistence]);\n      await maybeWithStore(idbPersistence, true, async (store2) => {\n        await idb.del(\n          store2,\n          idb.createIDBKeyRangeUpperBound(idbPersistence._dbref, true)\n        );\n        await maybeWithStore(idbPersistence, false, async (store3) => {\n          // eslint-disable-next-line no-param-reassign\n          idbPersistence._dbsize = await idb.count(store3);\n        });\n      });\n    });\n  }\n}\n\nexport async function clearDocument(name: string): Promise<void> {\n  await idb.deleteDB(name);\n}\n\ninterface DocumentVersion {\n  name: string;\n  version: string;\n  createdAt: number;\n}\n\ninterface IndexeddbPersistenceOptions {\n  readOnly?: boolean;\n}\n\nexport class IndexeddbPersistence extends Observable<string> {\n  public db: IDBDatabase | null = null;\n  public doc: Y.Doc;\n  public name: string;\n  public synced = false;\n  public whenSynced: Promise<IndexeddbPersistence>;\n\n  public _dbref = 0;\n  public _dbsize = 0;\n  public _mux = fnQueue();\n  public _destroyed = false;\n\n  private _db: Promise<IDBDatabase>;\n  private _storeTimeoutId: ReturnType<typeof setTimeout> | undefined;\n  /**\n   * Timeout in ms untill data is merged and persisted in idb.\n   */\n  private _storeTimeout = 1000;\n\n  constructor(\n    name: string,\n    doc: Y.Doc,\n    { readOnly = false }: IndexeddbPersistenceOptions = {}\n  ) {\n    super();\n    this.doc = doc;\n    this.name = readOnly ? `${name}:readonly` : name;\n    this._db = idb.openDB(this.name, (db) =>\n      idb.createStores(db, [['updates', { autoIncrement: true }]])\n    );\n    this.whenSynced = this._init();\n    this._storeUpdate = this._storeUpdate.bind(this);\n    this.destroy = this.destroy.bind(this);\n    doc.on('update', this._storeUpdate);\n    doc.on('destroy', this.destroy);\n  }\n\n  private async _init(): Promise<IndexeddbPersistence> {\n    this.db = await this._db;\n    const currState = Y.encodeStateAsUpdate(this.doc);\n    await fetchUpdates(this);\n    return maybeWithStore(\n      this,\n      true,\n      async (store): Promise<IndexeddbPersistence> => {\n        await idb.addAutoKey(store, currState);\n        return this;\n      }\n    ).then((store) => {\n      if (!this._destroyed) {\n        this.emit('synced', [this]);\n        this.synced = true;\n      }\n      return new Promise((resolve) => {\n        if (store) {\n          resolve(store);\n        }\n      });\n    });\n  }\n\n  private async _storeUpdate(\n    update: Uint8Array,\n    _origin: unknown,\n    _doc: Y.Doc,\n    tr: Y.Transaction\n  ) {\n    await this._mux.push(async () => {\n      await this.whenSynced;\n      await maybeWithStore(this, true, async (store) => {\n        await idb.addAutoKey(store, update);\n        this.emit('saved', [this, tr.local]);\n        this._dbsize += 1;\n        if (this._dbsize >= PREFERRED_TRIM_SIZE) {\n          // debounce store call\n          if (this._storeTimeoutId) {\n            clearTimeout(this._storeTimeoutId);\n          }\n          this._storeTimeoutId = setTimeout(async () => {\n            await storeState(this, false);\n            this._storeTimeoutId = undefined;\n          }, this._storeTimeout);\n        }\n      });\n    });\n  }\n\n  async destroy(): Promise<void> {\n    this._destroyed = true;\n    if (this._storeTimeoutId) {\n      clearTimeout(this._storeTimeoutId);\n    }\n    this.doc.off('update', this._storeUpdate);\n    this.doc.off('destroy', this.destroy);\n    const db = await this._db;\n    await db.close();\n  }\n\n  async remove(): Promise<void> {\n    await maybeWithStore(this, true, async (store) => {\n      store.clear();\n    });\n  }\n\n  async markVersion(versionName: string): Promise<void> {\n    const versionsStore = getDefined(getVersionsStore(this, true));\n    const version: DocumentVersion = {\n      name: versionName,\n      version: Buffer.from(Y.encodeStateVector(this.doc)).toString('hex'),\n      createdAt: Date.now(),\n    };\n    await idb.add(versionsStore, JSON.stringify(version), versionName);\n  }\n\n  async sameVersion(versionName: string): Promise<boolean> {\n    const versionsStore = getDefined(getVersionsStore(this, false));\n    const versionString = await idb.get(versionsStore, versionName);\n    if (versionString && typeof versionString === 'string') {\n      const version = JSON.parse(versionString);\n      const currentVersion = Buffer.from(\n        Y.encodeStateVector(this.doc)\n      ).toString('hex');\n      return version.version !== currentVersion;\n    }\n    return false;\n  }\n}\n","import * as decoding from 'lib0/decoding';\nimport * as encoding from 'lib0/encoding';\nimport * as syncProtocol from 'y-protocols/sync';\nimport * as awarenessProtocol from 'y-protocols/awareness';\nimport * as authProtocol from 'y-protocols/auth';\nimport {\n  messageAuth,\n  messageAwareness,\n  MessageHandler,\n  messageQueryAwareness,\n  messageSync,\n  TWebSocketProvider,\n} from './types';\n\nconst permissionDeniedHandler = (\n  provider: TWebSocketProvider,\n  reason: string\n) =>\n  // eslint-disable-next-line no-console\n  console.warn(`Permission denied to access ${provider.url}.\\n${reason}`);\n\nexport const messageHandlers: MessageHandler[] = [];\n\nmessageHandlers[messageSync] = (\n  encoder: encoding.Encoder,\n  decoder: decoding.Decoder,\n  provider: TWebSocketProvider,\n  emitSynced: boolean\n) => {\n  encoding.writeVarUint(encoder, messageSync);\n  const syncMessageType = syncProtocol.readSyncMessage(\n    decoder,\n    encoder,\n    provider.doc,\n    provider\n  );\n  if (\n    emitSynced &&\n    syncMessageType === syncProtocol.messageYjsSyncStep2 &&\n    !provider.synced\n  ) {\n    // eslint-disable-next-line no-param-reassign\n    provider.synced = true;\n  }\n};\n\nmessageHandlers[messageQueryAwareness] = (\n  encoder: encoding.Encoder,\n  _decoder: decoding.Decoder,\n  provider: TWebSocketProvider\n) => {\n  encoding.writeVarUint(encoder, messageAwareness);\n  encoding.writeVarUint8Array(\n    encoder,\n    awarenessProtocol.encodeAwarenessUpdate(\n      provider.awareness,\n      Array.from(provider.awareness.getStates().keys())\n    )\n  );\n};\n\nmessageHandlers[messageAwareness] = (\n  _encoder: encoding.Encoder,\n  decoder: decoding.Decoder,\n  provider: TWebSocketProvider\n) => {\n  awarenessProtocol.applyAwarenessUpdate(\n    provider.awareness,\n    decoding.readVarUint8Array(decoder),\n    provider\n  );\n};\n\nmessageHandlers[messageAuth] = (\n  _encoder: encoding.Encoder,\n  decoder: decoding.Decoder,\n  provider: TWebSocketProvider\n) => {\n  authProtocol.readAuthMessage(decoder, provider.doc, permissionDeniedHandler);\n};\n","import { Subject } from 'rxjs';\nimport { version1 } from './version1';\nimport { version2 } from './version2';\n\nexport interface MessageHandler {\n  message: Subject<Buffer>;\n  receive: (message: Uint8Array) => void;\n}\n\nconst protocolHandlers: Record<number, () => MessageHandler> = {\n  1: version1,\n  2: version2,\n};\n\nexport const receiver = (protocolVersion: number): MessageHandler => {\n  const handlerBuilder = protocolHandlers[protocolVersion];\n  if (!handlerBuilder) {\n    throw new Error(`Invalid protocol version: ${protocolVersion}`);\n  }\n  return handlerBuilder();\n};\n","/* eslint-disable no-param-reassign */\nimport { getDefined } from '@decipad/utils';\nimport { Buffer } from 'buffer';\nimport * as decoding from 'lib0/decoding';\nimport * as encoding from 'lib0/encoding';\nimport * as mutex from 'lib0/mutex';\nimport { Observable } from 'lib0/observable';\nimport * as time from 'lib0/time';\nimport { debounce } from 'lodash';\nimport * as awarenessProtocol from 'y-protocols/awareness';\nimport * as syncProtocol from 'y-protocols/sync';\nimport { Doc as YDoc, mergeUpdates } from 'yjs';\nimport { receiver } from './receive';\nimport { messageHandlers } from './messageHandlers';\nimport {\n  messageAwareness,\n  MessageHandler,\n  messageSync,\n  MessageType,\n  TWebSocketProvider,\n} from './types';\n\nexport type { TWebSocketProvider };\n\nexport interface WSStatus {\n  status: 'disconnected' | 'connected' | 'connecting';\n}\n\nexport interface Options {\n  readOnly?: boolean;\n  connect?: boolean;\n  awareness?: awarenessProtocol.Awareness;\n  params?: Record<string, string>;\n  WebSocketPolyfill?: typeof WebSocket;\n  resyncInterval?: number;\n  protocol?: string;\n  protocolVersion: number;\n  beforeConnect?: (provider: TWebSocketProvider) => Promise<void> | void;\n  onError?: (err: Error | Event) => void;\n}\n\ntype ClientId = number;\n\ninterface AwarenessUpdate {\n  added: ClientId[];\n  updated: ClientId[];\n  removed: ClientId[];\n}\n\nconst reconnectTimeoutBase = 2_000;\nconst maxReconnectTimeout = 20_000;\n// @todo - this should depend on awareness.outdatedTime\nconst messageReconnectTimeout = 30000;\nconst debounceBroadcast = 1000;\n\nconst encodeMessage = (message: Uint8Array): string =>\n  Buffer.from(message).toString('base64');\n\nconst decodeMessage = (message: string | Uint8Array): Buffer => {\n  if (typeof message === 'string') {\n    return decodeMessage(Buffer.from(message, 'base64'));\n  }\n  return Buffer.from(message);\n};\n\nconst isAcceptableMessage = (buf: string | Buffer | Uint8Array): boolean => {\n  return (\n    typeof buf === 'string' || Buffer.isBuffer(buf) || buf instanceof Uint8Array\n  );\n};\n\nexport const readMessage = (\n  provider: TWebSocketProvider,\n  buf: Uint8Array,\n  emitSynced: boolean\n): undefined | encoding.Encoder => {\n  if (!isAcceptableMessage(buf)) {\n    // eslint-disable-next-line no-console\n    console.warn('message is unnacceptable', buf);\n    return;\n  }\n  try {\n    const message = Buffer.from(buf);\n    const decoder = decoding.createDecoder(message);\n    const encoder = encoding.createEncoder();\n    const messageType = decoding.readVarUint(decoder);\n    const messageHandler = provider.messageHandlers[messageType];\n    if (messageHandler) {\n      messageHandler(\n        encoder,\n        decoder,\n        provider,\n        emitSynced,\n        messageType as MessageType\n      );\n    } else {\n      // eslint-disable-next-line no-console\n      console.error(\n        `Could not find handler for message of type ${messageType}`\n      );\n    }\n    return encoder;\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error('Error trying to decode message', err);\n  }\n  return undefined;\n};\n\nconst setupWS = async (provider: TWebSocketProvider) => {\n  const scheduleReconnect = () => {\n    if (provider.shouldConnect) {\n      const timeout = Math.min(\n        2 ** provider.wsUnsuccessfulReconnects * reconnectTimeoutBase,\n        maxReconnectTimeout\n      );\n      setTimeout(setupWS, timeout, provider);\n    }\n  };\n\n  try {\n    if (provider.shouldConnect && !provider.ws && !provider.wsconnecting) {\n      if (provider.beforeConnect) {\n        await provider.beforeConnect(provider);\n      }\n\n      provider.emit('status', [\n        {\n          status: 'connecting',\n        },\n      ]);\n\n      const websocket = new provider._WS(\n        getDefined(provider.url),\n        provider.protocol\n      );\n      websocket.binaryType = 'arraybuffer';\n      provider.ws = websocket;\n      provider.wsconnecting = true;\n      provider.wsconnected = false;\n      provider.synced = false;\n\n      websocket.onerror = (err) => {\n        // do nothing\n        // eslint-disable-next-line no-console\n        console.warn('Error caught on websocket:', err);\n      };\n\n      const { message, receive } = receiver(provider.protocolVersion);\n      const messageSubscription = message.subscribe((m) => {\n        try {\n          const encoder = readMessage(provider, m, true);\n          if (!provider.readOnly && encoder && encoding.length(encoder) > 1) {\n            const reply = encoding.toUint8Array(encoder);\n            provider.send(reply);\n          }\n        } catch (err) {\n          // eslint-disable-next-line no-console\n          console.error(\n            'An error was detected while reading a message from a websocket'\n          );\n          // eslint-disable-next-line no-console\n          console.error(err);\n          provider.onError?.(err as Error);\n        }\n      });\n\n      websocket.onmessage = (event) => {\n        if (provider.destroyed || !event.data) {\n          return;\n        }\n        provider.wsLastMessageReceived = time.getUnixTime();\n        receive(decodeMessage(event.data));\n      };\n\n      websocket.onclose = (ev) => {\n        // eslint-disable-next-line no-console\n        console.info('WS closed', ev);\n        messageSubscription.unsubscribe();\n        provider.ws = undefined;\n        provider.wsconnecting = false;\n        if (!provider.destroyed && provider.wsconnected) {\n          provider.wsconnected = false;\n          provider.synced = false;\n          // update awareness (all users except local left)\n          awarenessProtocol.removeAwarenessStates(\n            provider.awareness,\n            Array.from(provider.awareness.getStates().keys()).filter(\n              (client) => client !== provider.doc.clientID\n            ),\n            provider\n          );\n          provider.emit('status', [\n            {\n              status: 'disconnected',\n            },\n          ]);\n        } else {\n          provider.wsUnsuccessfulReconnects += 1;\n        }\n\n        if (provider.shouldConnect) {\n          scheduleReconnect();\n        }\n      };\n\n      websocket.onopen = () => {\n        // eslint-disable-next-line no-console\n        console.info('WS: opened');\n        provider.wsLastMessageReceived = time.getUnixTime();\n        provider.wsconnecting = false;\n        provider.wsconnected = true;\n        provider.wsUnsuccessfulReconnects = 0;\n        provider.emit('status', [\n          {\n            status: 'connected',\n          },\n        ]);\n        // always send sync step 1 when connected\n        const encoder = encoding.createEncoder();\n        encoding.writeVarUint(encoder, messageSync);\n        syncProtocol.writeSyncStep1(encoder, provider.doc);\n        provider.send(encoding.toUint8Array(encoder));\n        // broadcast local awareness state\n        if (provider.awareness.getLocalState() != null) {\n          const encoderAwarenessState = encoding.createEncoder();\n          encoding.writeVarUint(encoderAwarenessState, messageAwareness);\n          encoding.writeVarUint8Array(\n            encoderAwarenessState,\n            awarenessProtocol.encodeAwarenessUpdate(provider.awareness, [\n              provider.doc.clientID,\n            ])\n          );\n          provider.send(encoding.toUint8Array(encoderAwarenessState));\n        }\n      };\n    }\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(err);\n    if (provider.ws && provider.ws.readyState === provider.ws.OPEN) {\n      provider.ws.close();\n    }\n    provider.ws = undefined;\n    provider.wsconnecting = false;\n    scheduleReconnect();\n  }\n};\n\nconst broadcastMessage = (provider: WebsocketProvider, buf: Uint8Array) => {\n  if (provider.destroyed || provider.readOnly) {\n    return;\n  }\n  if (provider.wsconnected) {\n    try {\n      provider.send(buf);\n    } catch (err) {\n      if (\n        (err as Error).message !==\n        'WebSocket is already in CLOSING or CLOSED state'\n      ) {\n        throw err;\n      }\n    }\n  }\n};\n\nclass WebsocketProvider\n  extends Observable<string>\n  implements TWebSocketProvider\n{\n  doc: YDoc;\n  protocol: string | undefined;\n  protocolVersion: number;\n  beforeConnect: Options['beforeConnect'];\n  _WS: typeof WebSocket;\n  awareness: awarenessProtocol.Awareness;\n  url?: string;\n  readOnly: boolean;\n  shouldConnect: boolean;\n  onError?: Options['onError'];\n  ws: WebSocket | undefined;\n  wsconnected = false;\n  wsconnecting = false;\n  wsLastMessageReceived = 0;\n  wsUnsuccessfulReconnects = 0;\n  messageHandlers: MessageHandler[];\n  mux: mutex.mutex;\n  destroyed = false;\n  outUpdates: Uint8Array[] = [];\n  debouncedBroadcastUpdateMessage: () => void = debounce(\n    this.broadcastPendingUpdateMessages.bind(this),\n    debounceBroadcast\n  );\n  outAwarenessUpdates: number[] = [];\n  debouncedBroadcastAwarenessUpdateMessage: () => void = debounce(\n    this.broadcastPendingAwarenessUpdateMessages.bind(this),\n    debounceBroadcast\n  );\n\n  private _selfAwareness = false;\n  private _synced = false;\n  private _resyncInterval: 0 | ReturnType<typeof setInterval> = 0;\n  private _checkInterval: ReturnType<typeof setInterval> | undefined;\n\n  constructor(doc: YDoc, options: Options = { protocolVersion: 1 }) {\n    super();\n    const {\n      readOnly = false,\n      connect = true,\n      awareness,\n      WebSocketPolyfill = WebSocket,\n      resyncInterval = -1,\n      protocol,\n      beforeConnect,\n      onError,\n      protocolVersion,\n    } = options;\n\n    this.readOnly = readOnly;\n    this.doc = doc;\n    this.protocol = protocol;\n    this.beforeConnect = beforeConnect;\n    this._WS = WebSocketPolyfill;\n    this.onError = onError;\n    this.protocolVersion = protocolVersion;\n\n    if (!awareness) {\n      this.awareness = new awarenessProtocol.Awareness(doc);\n      this._selfAwareness = true;\n    } else {\n      this.awareness = awareness;\n    }\n\n    this.messageHandlers = messageHandlers.slice();\n    this.mux = mutex.createMutex();\n    this.shouldConnect = connect;\n\n    if (resyncInterval > 0) {\n      this._resyncInterval = setInterval(() => {\n        if (this.ws && this.wsconnected && !this.readOnly) {\n          // resend sync step 1\n          const encoder = encoding.createEncoder();\n          encoding.writeVarUint(encoder, messageSync);\n          syncProtocol.writeSyncStep1(encoder, doc);\n          try {\n            this.send(encoding.toUint8Array(encoder));\n          } catch (err) {\n            if (\n              (err as Error).message !==\n              'WebSocket is already in CLOSING or CLOSED state'\n            ) {\n              throw err;\n            }\n          }\n        }\n      }, resyncInterval);\n    }\n\n    if ('addEventListener' in global) {\n      global.addEventListener('online', this._onOfflineOnlineStatusChange);\n      global.addEventListener('offline', this._onOfflineOnlineStatusChange);\n    }\n\n    this._updateHandler = this._updateHandler.bind(this);\n    this._beforeUnloadHandler = this._beforeUnloadHandler.bind(this);\n    this._awarenessUpdateHandler = this._awarenessUpdateHandler.bind(this);\n\n    if (!this.readOnly) {\n      this.doc.on('update', this._updateHandler);\n    }\n\n    if (typeof window !== 'undefined') {\n      window.addEventListener('beforeunload', this._beforeUnloadHandler);\n    } else if (typeof process !== 'undefined') {\n      process.on('exit', () => this._beforeUnloadHandler);\n    }\n    if (!readOnly) {\n      this.awareness.on('update', this._awarenessUpdateHandler);\n    }\n    this._checkInterval = setInterval(() => {\n      if (\n        this.wsconnected &&\n        messageReconnectTimeout <\n          time.getUnixTime() - this.wsLastMessageReceived\n      ) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n        this.shouldConnect = true;\n        this.ws?.close();\n      }\n    }, messageReconnectTimeout / 10);\n\n    if (connect) {\n      this.connect();\n    }\n  }\n\n  set serverUrl(serverUrl: string | undefined) {\n    if (serverUrl) {\n      const url = new URL(serverUrl).href;\n      this.url = url;\n    }\n  }\n\n  get serverUrl(): string | undefined {\n    return this.url;\n  }\n\n  send(message: Uint8Array): void {\n    if (this.wsconnected && this.ws) {\n      this.ws.send(encodeMessage(message));\n    }\n  }\n\n  private _updateHandler(update: Uint8Array, origin: unknown) {\n    if (origin !== this && !this.readOnly && this.wsconnected) {\n      this.outUpdates.push(update);\n      this.debouncedBroadcastUpdateMessage();\n    }\n  }\n\n  private broadcastPendingUpdateMessages() {\n    const toSend = Array.from(this.outUpdates);\n    this.outUpdates = [];\n    const encoder = encoding.createEncoder();\n    encoding.writeVarUint(encoder, messageSync);\n    syncProtocol.writeUpdate(encoder, mergeUpdates(toSend));\n    if (encoding.length(encoder) > 1) {\n      broadcastMessage(this, encoding.toUint8Array(encoder));\n    }\n    this.emit('saved', [this]);\n  }\n\n  private _awarenessUpdateHandler(changes: AwarenessUpdate) {\n    const { added, updated, removed } = changes;\n    const changedClients = added.concat(updated).concat(removed);\n    this.outAwarenessUpdates = this.outAwarenessUpdates.concat(changedClients);\n    this.debouncedBroadcastAwarenessUpdateMessage();\n  }\n\n  private broadcastPendingAwarenessUpdateMessages() {\n    const changedClients = Array.from(this.outAwarenessUpdates);\n    if (changedClients.length > 0) {\n      this.outAwarenessUpdates = [];\n      const update = awarenessProtocol.encodeAwarenessUpdate(\n        this.awareness,\n        changedClients\n      );\n      const encoder = encoding.createEncoder();\n      encoding.writeVarUint(encoder, messageAwareness);\n      encoding.writeVarUint8Array(encoder, update);\n      if (encoding.length(encoder) > 1) {\n        broadcastMessage(this, encoding.toUint8Array(encoder));\n      }\n    }\n  }\n\n  private _beforeUnloadHandler() {\n    awarenessProtocol.removeAwarenessStates(\n      this.awareness,\n      [this.doc.clientID],\n      'window unload'\n    );\n  }\n\n  private _onOfflineOnlineStatusChange = () => {\n    // if the navigator turns offline, we need to close the websocket so that\n    // we know the messages are not being able to be sent\n    if (!navigator.onLine && this.ws && (this.ws.CONNECTING || this.ws?.OPEN)) {\n      this.shouldConnect = true;\n      try {\n        // eslint-disable-next-line no-console\n        console.info('WS: closing websocket because offline');\n        this.ws.close();\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.warn('Error closing websocket:', err);\n      }\n    }\n  };\n\n  get synced(): boolean {\n    return this._synced;\n  }\n\n  set synced(state: boolean) {\n    if (this._synced !== state) {\n      this._synced = state;\n      this.emit('synced', [state]);\n      this.emit('sync', [state]);\n    }\n  }\n\n  destroy(): void {\n    this.destroyed = true;\n    if (this._resyncInterval !== 0) {\n      clearInterval(this._resyncInterval);\n    }\n    if (this._checkInterval) {\n      clearInterval(this._checkInterval);\n    }\n\n    this.disconnect();\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('beforeunload', this._beforeUnloadHandler);\n    } else if (typeof process !== 'undefined') {\n      process.off('exit', () => this._beforeUnloadHandler);\n    }\n    this.awareness.off('update', this._awarenessUpdateHandler);\n    if (this._selfAwareness) {\n      this.awareness.destroy();\n    }\n\n    this.doc.off('update', this._updateHandler);\n\n    if ('removeEventListener' in global) {\n      global.removeEventListener('online', this._onOfflineOnlineStatusChange);\n      global.removeEventListener('offline', this._onOfflineOnlineStatusChange);\n    }\n\n    super.destroy();\n  }\n\n  disconnect(): void {\n    if (this.wsconnected) {\n      this.broadcastPendingUpdateMessages();\n    }\n    this.shouldConnect = false;\n    if (this.ws != null) {\n      try {\n        this.ws.close();\n      } catch (err) {\n        // do nothing\n      }\n      this.emit('status', [\n        {\n          status: 'disconnected',\n        },\n      ]);\n    }\n  }\n\n  async connect(): Promise<void> {\n    this.shouldConnect = true;\n    if (!this.wsconnected && !this.ws) {\n      await setupWS(this);\n    }\n  }\n}\n\nexport const createWebsocketProvider = (\n  doc: YDoc,\n  options: Options = { protocolVersion: 1 }\n): TWebSocketProvider => {\n  return new WebsocketProvider(doc, options);\n};\n"],"names":["asLocalEditor","editor","fn","YjsEditor","docSyncEditor","doc","store","ws","events","EventEmitter","on","emit","_provider","isLocal","source","synced","isSavedRemotely","next","event","status","err","console","error","hasLocalChanges","BehaviorSubject","onceStoreSynced","savedCount","once","destroyed","Object","assign","onLoaded","cb","offLoaded","removeListener","onSaved","offSaved","onConnected","onDestroyed","offDestroyed","destroy","removeAllListeners","connect","disconnect","removeLocalChanges","remove","Promise","resolve","setLoadedRemotely","isDocSyncEnabled","markVersion","version","sameVersion","equals","checksumRemote","md5","JSON","stringify","toSlateDoc","getArray","supportBigIntToJSON","async","fetchToken","resp","fetch","ok","Error","statusText","text","wsAddress","docId","encodeURIComponent","createDocSyncEditor","readOnly","authSecret","onError","WebSocketPolyfill","connectionParams","initialState","protocolVersion","getSession","children","YDoc","supports","IndexeddbPersistence","undefined","initialTokenTime","Date","now","isInitialTokenStale","getToken","token","beforeConnect","provider","serverUrl","url","protocol","wsp","awareness","startWebsocket","createWebsocketProvider","resyncInterval","Awareness","shared","yjsEditor","withYjs","synchronizeValue","onceSynced","update","Buffer","from","applyUpdate","setTimeout","syncEditor","cursorEditor","withCursor","normalizeNode","entry","loadedLocally","loadedRemotely","ensureInitialDocument","setupUndo","isReadOnly","getLocalNotebookUpdates","fetchUpdatesAsBuffer","captureTransaction","undoManager","UndoManager","sharedType","trackedOrigins","Set","slateYjsSymbol","captureTimeout","undo","redo","withoutCapturingUndo","beforeCapturing","length","withoutNormalizing","insertNodes","type","ELEMENT_H1","id","nanoid","at","ELEMENT_PARAGRAPH","AWARENESS","WeakMap","CursorEditor","get","invariant","updateCursor","session","selection","anchor","focus","localState","getLocalState","user","newState","email","name","setLocalState","e","set","onChange","debouncedOnChange","debounce","call","IS_REMOTE","WeakSet","LOCAL_OPERATIONS","SHARED_TYPES","isRemote","has","asRemote","wasRemote","add","delete","asLocal","ret","localOperations","operations","yjsApply","applyYjsEvents","filter","transaction","origin","observer","_editor","isHistoryEditor","withoutSavingHistory","applyRemoteYjsEvents","observeDeep","apply","op","operation","trackLocalOperations","ops","editorLocalOperations","Array","flat","applySlateOps","clear","applyLocalOperations","unobserveDeep","docDB","idb","db","autoIncrement","updatesStore","updatesStoreName","updates","mergeUpdates","fetchUpdates","idbPersistence","_mux","push","maybeWithStore","_dbref","_destroyed","transact","forEach","val","Y","lastKey","store2","cnt","store3","_dbsize","getVersionsStore","write","versionsStore","getDefined","getUpdatesStore","Observable","constructor","super","fnQueue","this","_db","whenSynced","_init","_storeUpdate","bind","currState","then","_origin","_doc","tr","local","_storeTimeoutId","clearTimeout","forceStore","storeState","_storeTimeout","off","close","versionName","toString","createdAt","versionString","parse","currentVersion","permissionDeniedHandler","reason","warn","messageHandlers","messageSync","encoder","decoder","emitSynced","encoding","syncMessageType","syncProtocol","messageQueryAwareness","_decoder","messageAwareness","awarenessProtocol","getStates","keys","_encoder","decoding","messageAuth","authProtocol","protocolHandlers","version1","version2","receiver","handlerBuilder","decodeMessage","message","readMessage","buf","Uint8Array","isAcceptableMessage","messageType","messageHandler","setupWS","scheduleReconnect","shouldConnect","timeout","Math","min","wsUnsuccessfulReconnects","wsconnecting","websocket","_WS","binaryType","wsconnected","onerror","receive","messageSubscription","subscribe","m","reply","send","onmessage","data","wsLastMessageReceived","time","onclose","ev","info","unsubscribe","client","clientID","onopen","encoderAwarenessState","readyState","OPEN","broadcastMessage","WebsocketProvider","options","broadcastPendingUpdateMessages","broadcastPendingAwarenessUpdateMessages","navigator","onLine","CONNECTING","WebSocket","_selfAwareness","mux","mutex","_resyncInterval","setInterval","global","addEventListener","_onOfflineOnlineStatusChange","_updateHandler","_beforeUnloadHandler","_awarenessUpdateHandler","window","process","_checkInterval","messageReconnectTimeout","URL","href","encodeMessage","outUpdates","debouncedBroadcastUpdateMessage","toSend","changes","added","updated","removed","changedClients","concat","outAwarenessUpdates","debouncedBroadcastAwarenessUpdateMessage","_synced","state","clearInterval","removeEventListener"],"sourceRoot":""}