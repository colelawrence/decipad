{"version":3,"file":"static/js/5169.030e485c.chunk.js","mappings":"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","sources":["../../computer/src/exprRefs/makeNamesFromIds.ts","../../computer/src/exprRefs/index.ts","../../computer/src/autocomplete/findNames.ts","../../computer/src/reporting.ts","../../computer/src/computer/getVisibleVariables.ts","../../computer/src/compute/computeProgram.ts","../../computer/src/dependencies/dependencies.ts","../../computer/src/hooks/subjectListener.ts","../../computer/src/computer/astToParseable.ts","../../computer/src/caching/dependents.ts","../../computer/src/caching/getStatementsToEvict.ts","../../computer/src/computer/ComputationRealm.ts","../../computer/src/computer/deduplicateColumnResults.ts","../../computer/src/computer/defaultComputerResults.ts","../../computer/src/computer/dependencies.ts","../../computer/src/computer/topologicalSort.ts","../../computer/src/computer/Computer.ts","../../computer/src/tools/dropWhileComputing.ts","../../computer/src/computer/parseUtils.ts","../../computer/src/computer/parseNumberWithUnit.ts","../../computer/src/utils.ts","../../editor-utils/src/getUrlComponents.ts","../../fetch/src/index.ts","../../format/src/formatUnit.ts","../../format/src/formatTypeBasic.ts","../../format/src/formatError.ts","../../format/src/formatEdgeCaseNumbers.ts","../../format/src/parseMs.ts","../../format/src/formatTime.ts","../../format/src/getCurrency.ts","../../format/src/formatNumber.ts","../../language/src/value/Unknown.ts","../../language/src/value/RuntimeError.ts","../../language/src/value/types.ts","../../language/src/type/build.ts","../../language/src/type/InferError.ts","../../language/src/type/percentages.ts","../../language/src/langPluralize.ts","../../language/src/units/currency-units.ts","../../language/src/units/angle-units.ts","../../language/src/units/length-units.ts","../../language/src/units/area-units.ts","../../language/src/units/electric-charge-units.ts","../../language/src/units/electric-current-units.ts","../../language/src/units/electrical-capacitance-units.ts","../../language/src/units/electrical-conductance-units.ts","../../language/src/units/electrical-resistance-units.ts","../../language/src/units/energy-units.ts","../../language/src/units/force-units.ts","../../language/src/units/frequency-units.ts","../../language/src/units/information-units.ts","../../language/src/units/luminous-flow-units.ts","../../language/src/units/luminous-intensity-units.ts","../../language/src/units/mass-units.ts","../../language/src/units/power-units.ts","../../language/src/units/pressure-units.ts","../../language/src/units/solid-angle-units.ts","../../language/src/units/speed-units.ts","../../language/src/units/substance-units.ts","../../language/src/units/temperature-units.ts","../../language/src/units/time-units.ts","../../language/src/units/utils.ts","../../language/src/units/voltage-units.ts","../../language/src/units/volume-units.ts","../../language/src/units/known-units.ts","../../language/src/units/expand/expansions.ts","../../language/src/units/base-units.ts","../../language/src/units/expand/expand-units.ts","../../language/src/units/expand/contract-units.ts","../../language/src/units/imprecise-conversions.ts","../../language/src/units/convert.ts","../../language/src/dimtools/getReductionPlan.ts","../../language/src/dimtools/multidimensional-utils.ts","../../language/src/dimtools/automap.ts","../../language/src/dimtools/dimSwap.ts","../../language/src/dimtools/getLabelIndex.ts","../../language/src/units/autoconvert.ts","../../language/src/units/parse.ts","../../language/src/type/units.ts","../../language/src/type/checks.ts","../../language/src/type/Type.ts","../../language/src/type/convert-to-multiplier-unit.ts","../../language/src/type/traverseType.ts","../../language/src/type/narrowing.ts","../../language/src/type/parseType.ts","../../language/src/type/serialization.ts","../../language/src/dimtools/common.ts","../../language/src/lazy/HypercubeAtIndex.ts","../../language/src/lazy/materialize.ts","../../language/src/lazy/Hypercube.ts","../../language/src/lazy/EmptyColumn.ts","../../language/src/lazy/SwappedHypercube.ts","../../language/src/lazy/lowLevelGetImpl.ts","../../language/src/lazy/ConcatenatedColumn.ts","../../language/src/lazy/index.ts","../../language/src/value/Value.ts","../../language/src/value/sequences.ts","../../language/src/value/compare-values.ts","../../language/src/lazy/ColumnSlice.ts","../../language/src/value/ValueTransforms.ts","../../language/src/date/time-quantities.ts","../../language/src/date/index.ts","../../language/src/utils.ts","../../language/src/stack/index.ts","../../language/src/infer/context.ts","../../language/src/tables/dimensionCoersion.ts","../../language/src/tables/inference.ts","../../language/src/interpreter/previous.ts","../../language/src/tables/shouldEvaluate.ts","../../language/src/tables/evaluate.ts","../../language/src/infer/sequence.ts","../../language/src/previous-ref.ts","../../language/src/matrix/getVariable.ts","../../language/src/matrix/matcher.ts","../../language/src/matrix/assignMultidim.ts","../../language/src/matrix/index.ts","../../language/src/infer/functions.ts","../../language/src/match/inferMatch.ts","../../language/src/tiered/inferTiered.ts","../../language/src/infer/index.ts","../../language/src/tables/column-assign.ts","../../language/src/categories/index.ts","../../language/src/directives/as-directive.ts","../../language/src/directives/over-directive.ts","../../language/src/directives/of-directive.ts","../../language/src/directives/directives.ts","../../language/src/directives/select-directive.ts","../../language/src/directives/index.ts","../../language/src/match/evaluateMatch.ts","../../language/src/tiered/evaluateTiered.ts","../../language/src/result/validate.ts","../../language/src/result/resultToValue.ts","../../language/src/result/index.ts","../../language/src/interpreter/evaluate.ts","../../language/src/interpreter/Realm.ts","../../language/src/interpreter/runInInterpreter.ts","../../language/src/builtins/parseFunctor.ts","../../language/src/builtins/overloadBuiltin.ts","../../language/src/builtins/dateOverloads.ts","../../language/src/interpreter/simple-expression-evaluate.ts","../../language/src/builtins/operators/math-operators.ts","../../language/src/builtins/operators/comparison-operators.ts","../../language/src/builtins/operators/equality-operators.ts","../../language/src/builtins/operators/list-operators.ts","../../language/src/builtins/table.ts","../../language/src/builtins/operators/reducer-operators.ts","../../language/src/builtins/operators/table-operators.ts","../../language/src/builtins/operators/table-grouping-operators.ts","../../language/src/builtins/operators/misc-operators.ts","../../language/src/builtins/operators/contract-operators.ts","../../language/src/builtins/operators/trignometric-operators.ts","../../language/src/builtins/operators/operators.ts","../../language/src/builtins/operators/boolean-operators.ts","../../language/src/builtins/operators/index.ts","../../language/src/builtins/callBuiltinFunctor.ts","../../language/src/builtins/callBuiltin.ts","../../language/src/builtins/constants.ts","../../language/src/grammar/containmentCounting.ts","../../language/src/grammar/tokenizer.ts","../../language/src/grammar/nearley/deci-language-grammar-generated.js","../../language/src/grammar/index.ts","../../language/src/parser/source-map-decorator.ts","../../language/src/parser/SyntaxError.ts","../../language/src/parser/parser.ts","../../language/src/parser/decilang-tag.ts","../../language/src/parser/index.ts","../../language/src/parser/utils.ts","../../language/src/run.ts","../../live-connect/src/utils/workerPolyfills.ts","../external node-commonjs \"querystring\"","../../client-config/src/default.ts","../../client-config/src/index.ts","../../import/src/utils/HttpError.ts","../../import/src/http/request.ts","../../import/src/providers/gsheets/getSheetMeta.ts","../../import/src/providers/gsheets/getSheetRequestDataFromUrl.ts","../../import/src/providers/gsheets/getDataUrlFromSheetUrl.ts","../../import/src/utils/trimSheet.ts","../../import/src/utils/sheetColumnName.ts","../../import/src/providers/gsheets/getDataRangeUrlFromSheet.ts","../../import/src/utils/sheetIslands.ts","../../import/src/utils/matrix.ts","../../import/src/providers/gsheets/importGsheet.ts","../../import/src/providers/gsheets/index.ts","../../import/src/providers/gsheets/parseGsheetsSourceUrl.ts","../../import/src/providers/decipad/index.ts","../../import/src/isRandomImportUrl.ts","../../import/src/utils/errorResult.ts","../../import/src/importFromArrow.ts","../../import/src/utils/pivot.ts","../../import/src/importFromCsv.ts","../../import/src/importFromUnknownJson.ts","../../import/src/utils/sameType.ts","../../import/src/importFromUnknown.ts","../../import/src/import.ts","../../live-connect/src/createResponse.ts","../../live-connect/src/LiveConnect.worker.ts","../../editor-utils/src/getNotebook.ts","../../fraction/src/isFractionLike.ts","../../fraction/src/min.ts","../../fraction/src/max.ts","../../fraction/src/index.ts","../../number/src/DeciNumber.ts","../../fraction/src/utils.ts","../../number/src/min.ts","../../number/src/max.ts","../../number/src/index.ts","../../parse/src/inferBoolean.ts","../../parse/src/parseDate.ts","../../parse/src/inferDate.ts","../../parse/src/inferExpression.ts","../../parse/src/inferText.ts","../../parse/src/inferNumber.ts","../../parse/src/inferType.ts","../../parse/src/utils/memoize.ts","../../parse/src/inferColumn.ts","../../parse/src/columnNameFromIndex.ts","../../parse/src/fastNumber.ts","../../parse/src/inferTable.ts","../../parse/src/utils/astNode.ts","../../parse/src/utils/dateToAST.ts","../../parse/src/parseCell.ts","../../parse/src/utils/unitToAST.ts","../../parse/src/parseSeriesStart.ts","../../parse/src/seriesIterator.ts","../../utils/src/any-mapping-to-map.ts","../../utils/src/containsNumber.ts","../../utils/src/get-defined.ts","../../utils/src/get-only.ts","../../utils/src/identity.ts","../../utils/src/lenient-zip.ts","../../utils/src/memoizePrimitive.ts","../../utils/src/thro.ts","../../utils/src/unique.ts","../../utils/src/unzip.ts","../../utils/src/varnamify.ts","../../utils/src/zip.ts","../../utils/src/bigint.ts","../external node-commonjs \"buffer\"","../external node-commonjs \"crypto\"","../external node-commonjs \"events\"","../external node-commonjs \"http\"","../external node-commonjs \"https\"","../external node-commonjs \"path\"","../external node-commonjs \"perf_hooks\"","../external node-commonjs \"process\"","../external node-commonjs \"punycode\"","../external node-commonjs \"stream\"","../external node-commonjs \"url\"","../external node-commonjs \"util\"","../external node-commonjs \"zlib\"","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/create fake namespace object","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/nonce","../webpack/runtime/require chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import {\n  mutateAst,\n  isIdentifier,\n  isExpression,\n  AST,\n  decilang,\n} from '@decipad/language';\nimport { memoizePrimitive } from '@decipad/utils';\nimport produce from 'immer';\nimport { Program, ProgramBlock } from '../types';\nimport { getDefinedSymbol, getIdentifierString } from '../utils';\nimport { assertIsExprRef, getExprRef, isExprRef } from '.';\n\n/**\n * Takes exprRef_xxxx references and replaces them with variable names\n */\nexport const replaceExprRefsWithPrettyRefs = (\n  program: Program\n): [Program, Set<string>] => {\n  // 1 + 1  --->  exprRef_1234 = 1 + 1\n  const autoAssigned = plainExpressionsToAssignments(program);\n\n  // MyVar = 1 + exprRef_4567  --->  MyVar = 1 + TheVariableName\n  // exprRef_1234 = 1  --->  Value_1 = 1\n  // exprRef_Table_Column_ID  --->  Table.Column\n  const [renamed, generatedNames] = replaceAllBlockIdReferences(\n    autoAssigned,\n    mapExprRefsToColumnAccess(program)\n  );\n\n  return [renamed, generatedNames];\n};\n\n/** Make sure every non-assignment is an assignment to a block ID */\nfunction plainExpressionsToAssignments(program: Program) {\n  return program.map(\n    produce<ProgramBlock>((block) => {\n      if (block.type === 'identified-block') {\n        const stats = block.block.args;\n\n        if (isExpression(stats[0])) {\n          // 1 + 1 --> Value_1 = 1 + 1\n          stats[0] = decilang<AST.Assign>`${{ name: getExprRef(block.id) }} = ${\n            stats[0]\n          }`;\n        } else if (\n          stats[0].type === 'assign' &&\n          !getIdentifierString(stats[0].args[0]).trim()\n        ) {\n          // Empty var names\n          stats[0].args[0].args[0] = getExprRef(block.id);\n        }\n      }\n    })\n  );\n}\n\n/**\n * Helper function to map exprRef_tableColumnId to Table.Column\n */\nfunction mapExprRefsToColumnAccess(\n  program: Program\n): Map<string, AST.PropertyAccess> {\n  return new Map(\n    program.flatMap((block) => {\n      const columnAssign = block.block?.args[0];\n      if (columnAssign?.type === 'table-column-assign') {\n        const [table, column] = columnAssign.args;\n        const asPropertyAccess = decilang<AST.PropertyAccess>`${{\n          name: table.args[0],\n        }}.${{ name: column.args[0] }}`;\n        return [[getExprRef(block.id), asPropertyAccess]];\n      }\n\n      return [];\n    })\n  );\n}\n\nfunction replaceAllBlockIdReferences(\n  program: Program,\n  tableColumnsBySmartRef: Map<string, AST.PropertyAccess>\n): [Program, Set<string>] {\n  const genVarName = makeVarNameLookup(program);\n\n  const generatedNames = new Set<string>();\n  const newProgram = program.map(\n    produce((block) => {\n      if (block.type === 'identified-block') {\n        mutateAst(block.block, (thing) => {\n          if (isIdentifier(thing)) {\n            const varName = getIdentifierString(thing);\n            if (isExprRef(varName)) {\n              /** Is this a ref to a Table.Column? */\n              const asTableDotColumn = tableColumnsBySmartRef.get(varName);\n              if (asTableDotColumn) {\n                return asTableDotColumn;\n              } else {\n                const { newName, wasGenerated } = genVarName(varName);\n                thing.args[0] = newName;\n                if (wasGenerated) {\n                  generatedNames.add(thing.args[0]);\n                }\n              }\n            }\n          }\n\n          return thing;\n        });\n      }\n    })\n  );\n\n  return [newProgram, generatedNames];\n}\n\nconst makeVarNameLookup = (program: Program) => {\n  const [idsToPretty, prettyToIds] = gatherAllVarNames(program);\n\n  let i = 0;\n\n  return memoizePrimitive((asBlockRef: string) => {\n    assertIsExprRef(asBlockRef);\n\n    // First, attempt to use the variable's non-ambiguous name\n    const prettyName = idsToPretty.get(asBlockRef);\n    if (prettyName && prettyToIds.get(prettyName)?.size === 1) {\n      return { newName: prettyName, wasGenerated: false };\n    }\n\n    // Generate a new name that's non-ambiguous\n    const prefix = prettyName ? `${prettyName}_`.replace(/_+$/, '_') : 'Value_';\n\n    let proposal;\n    do {\n      i++;\n      proposal = prefix + i;\n    } while (prettyToIds.get(proposal)?.size);\n\n    return { newName: proposal, wasGenerated: true };\n  });\n};\n\nfunction gatherAllVarNames(program: Program) {\n  const idsToPretty = new Map<string, string>();\n  const prettyToIds = new Map<string, Set<string>>();\n\n  for (const block of program) {\n    if (block.type === 'identified-block') {\n      const exprRef = getExprRef(block.id);\n      let symbol =\n        getDefinedSymbol(\n          block.block.args[0] ?? { type: 'noop', args: [] },\n          false\n        ) ?? '';\n\n      if (isExprRef(symbol)) {\n        symbol = '';\n      }\n\n      idsToPretty.set(exprRef, symbol);\n      if (symbol) {\n        mapOfSetsAdd(prettyToIds, symbol, exprRef);\n      }\n    }\n  }\n\n  return [idsToPretty, prettyToIds] as const;\n}\n\nfunction mapOfSetsAdd<MapKey, Value>(\n  map: Map<MapKey, Set<Value>>,\n  mapKey: MapKey,\n  addedValue: Value\n) {\n  const set = map.get(mapKey) ?? new Set();\n\n  map.set(mapKey, set);\n  set.add(addedValue);\n}\n","export { replaceExprRefsWithPrettyRefs as makeNamesFromIds } from './makeNamesFromIds';\n\nexport const getExprRef = (blockId: string): string => {\n  // simplify the block ID to a valid identifier\n  return `exprRef_${blockId.replace(/[^a-zA-Z0-9]/g, '_')}`;\n};\n\nexport const isExprRef = (varName: string) => varName.startsWith('exprRef_');\n\nexport const assertIsExprRef = (varName: string): string => {\n  /* istanbul ignore next */\n  if (!isExprRef(varName)) {\n    throw new Error('expected expression ref');\n  }\n  return varName;\n};\n","import { AST, AutocompleteName, serializeType } from '@decipad/language';\nimport { getDefinedSymbol } from '../utils';\nimport { ComputationRealm } from '../computer/ComputationRealm';\nimport { getExprRef } from '../exprRefs';\n\n/** Finds names accessible `inBlockId`. `isLocal` is adjusted if we're talking about local variables, and so is the column name if we're in a table (IE we don't need TableName.ColumnName) */\nexport function* findNames(\n  realm: ComputationRealm,\n  program: AST.Block[],\n  ignoreNames: Set<string>,\n  inBlockId?: string\n): Iterable<AutocompleteName> {\n  const seenSymbols = new Set<string>();\n  const { nodeTypes } = realm.inferContext;\n\n  const [ownTableName, ownVariableName] =\n    realm.inferContext.stack.getNsNameFromId(getExprRef(inBlockId ?? '')) ?? [];\n\n  for (const block of program) {\n    for (const statement of block.args) {\n      const symbol = getSymbolOrColumn(statement);\n      const type = nodeTypes.get(statement);\n\n      if (\n        !symbol ||\n        seenSymbols.has(symbol) ||\n        ignoreNames.has(symbol) ||\n        !type ||\n        block.id === inBlockId\n      ) {\n        continue;\n      }\n\n      if (statement.type === 'assign') {\n        yield {\n          kind: 'variable',\n          type: serializeType(type),\n          name: statement.args[0].args[0],\n          blockId: block.id,\n        };\n      }\n\n      if (statement.type === 'table') {\n        const [tName, ...colItems] = statement.args;\n\n        yield {\n          kind: 'variable',\n          type: serializeType(type),\n          name: tName.args[0],\n          blockId: block.id,\n        };\n\n        for (const col of colItems) {\n          const colType = nodeTypes.get(col);\n\n          if (colType) {\n            const tableName = statement.args[0].args[0];\n            const columnName = col.args[0].args[0];\n            const isLocal = ownTableName === tableName;\n            const name = isLocal ? columnName : `${tableName}.${columnName}`;\n            yield {\n              kind: 'column',\n              type: serializeType(colType),\n              name,\n              isLocal,\n            };\n          }\n        }\n      }\n\n      if (statement.type === 'table-column-assign') {\n        const tableName = statement.args[0].args[0];\n        const columnName = statement.args[1].args[0];\n        const isLocal = ownTableName === tableName;\n\n        if (ownTableName === tableName && ownVariableName === columnName) {\n          continue;\n        }\n\n        const name = isLocal ? columnName : `${tableName}.${columnName}`;\n\n        yield {\n          kind: 'column',\n          type: serializeType(type),\n          name,\n          blockId: block.id,\n          isLocal,\n        };\n      }\n\n      if (statement.type === 'function-definition') {\n        yield {\n          kind: 'function',\n          type: serializeType(type),\n          name: statement.args[0].args[0],\n          blockId: block.id,\n        };\n      }\n    }\n  }\n}\n\nconst getSymbolOrColumn = (stat: AST.Statement) => {\n  const symbol = getDefinedSymbol(stat);\n\n  if (symbol && stat.type === 'table-column-assign') {\n    return `${symbol}.${stat.args[1].args[0]}`;\n  } else {\n    return symbol;\n  }\n};\n","type ReporterFn = (error: Error) => void;\n\nlet captureExceptionFn: ReporterFn | undefined;\n\nexport const captureException: ReporterFn = (error) => {\n  if (typeof test === 'undefined') {\n    // eslint-disable-next-line no-console\n    console.error(error);\n  }\n\n  if (captureExceptionFn != null) {\n    captureExceptionFn(error);\n  }\n};\n\n/**\n * Call this with Sentry's captureException function\n *\n * The computer exposes this instead of importing Sentry, because\n * there are multiple versions of captureException for browser, node\n * and whatnot.\n */\nexport function setErrorReporter(reporterFn: ReporterFn) {\n  captureExceptionFn = reporterFn;\n}\n","import type { AST, Context } from '@decipad/language';\nimport { getExprRef } from '../exprRefs';\nimport { getDefinedSymbol } from '../utils';\n\nexport interface VisibleVariables {\n  global: ReadonlySet<string>;\n  local: ReadonlySet<string>;\n}\n\nexport const getVisibleVariables = (\n  program: AST.Block[],\n  blockId: string,\n  inferContext: Context\n): VisibleVariables => {\n  const index = program.findIndex((block) => block.id === blockId);\n  if (index === -1 || program.length === 0) {\n    return {\n      global: new Set(),\n      local: new Set(),\n    };\n  }\n\n  const localSymbol = getDefinedSymbol(program[index].args[0]);\n\n  const globalVars = new Set<string>();\n  const localVars = new Set<string>();\n\n  for (const block of program) {\n    const {\n      id: blockId,\n      args: [stat],\n    } = block;\n\n    globalVars.add(getExprRef(blockId));\n\n    const sym = getDefinedSymbol(stat);\n    if (sym) {\n      globalVars.add(sym);\n\n      const type = inferContext.stack.get(sym, 'global');\n      if (type?.columnNames != null) {\n        for (const col of type.columnNames) {\n          // Columns are visible within a table\n          if (sym === localSymbol) {\n            localVars.add(col);\n          }\n          globalVars.add(`${sym}.${col}`);\n        }\n      }\n    }\n  }\n\n  return {\n    global: globalVars,\n    local: localVars,\n  };\n};\n","import {\n  AST,\n  buildType as t,\n  Context,\n  evaluateStatement,\n  inferStatement,\n  RuntimeError,\n  serializeResult,\n  validateResult,\n  Value,\n} from '@decipad/language';\nimport { getDefined, zip } from '@decipad/utils';\nimport { captureException } from '../reporting';\nimport { IdentifiedResult } from '../types';\nimport { getStatement } from '../utils';\nimport { CacheContents, ComputationRealm } from '../computer/ComputationRealm';\nimport { getVisibleVariables } from '../computer/getVisibleVariables';\nimport { getExprRef } from '../exprRefs';\n\n/*\n - Skip cached stuff\n - Infer this statement\n - Evaluate the statement if it's not a type error\n */\nconst computeStatement = async (\n  program: AST.Block[],\n  blockId: string,\n  realm: ComputationRealm\n): Promise<[IdentifiedResult, Value | undefined]> => {\n  const cachedResult = realm.getFromCache(blockId);\n  let value: Value | undefined;\n\n  if (cachedResult) {\n    return [getDefined(cachedResult.result), cachedResult.value];\n  }\n\n  const statement = getStatement(program, blockId);\n\n  realm.inferContext.statementId = getExprRef(blockId);\n  const [valueType, usedNames] = await inferWhileRetrievingNames(\n    realm.inferContext,\n    statement\n  );\n\n  if (!(valueType.errorCause != null && !valueType.functionness)) {\n    realm.interpreterRealm.statementId = getExprRef(blockId);\n    value = await evaluateStatement(realm.interpreterRealm, statement);\n  }\n\n  if (value) {\n    validateResult(valueType, value.getData());\n  }\n\n  const variableName =\n    statement.type === 'assign' || statement.type === 'table'\n      ? statement.args[0].args[0]\n      : undefined;\n\n  const result: IdentifiedResult = {\n    type: 'computer-result',\n    id: blockId,\n    get result() {\n      if (statement.type === 'table') {\n        const type = getDefined(\n          realm.inferContext.stack.get(getDefined(variableName))\n        );\n        const value = realm.interpreterRealm.stack.get(\n          getDefined(variableName)\n        );\n        return serializeResult(type, value?.getData());\n      }\n      return serializeResult(valueType, value?.getData());\n    },\n    get visibleVariables() {\n      return getVisibleVariables(program, blockId, realm.inferContext);\n    },\n    usedNames,\n  };\n  return [result, value];\n};\n\nexport const resultFromError = (\n  error: Error,\n  blockId: string\n): IdentifiedResult => {\n  // Not a user-facing error, so let's hide internal details\n  const message = error.message.replace(\n    /^panic: (.+)$/,\n    'Internal Error: $1. Please contact support'\n  );\n\n  if (!(error instanceof RuntimeError)) {\n    captureException(error);\n  }\n\n  return {\n    type: 'computer-result',\n    id: blockId,\n    result: serializeResult(t.impossible(message), null),\n    usedNames: [],\n  };\n};\n\nexport const computeProgram = async (\n  program: AST.Block[],\n  realm: ComputationRealm\n): Promise<IdentifiedResult[]> => {\n  realm.inferContext.previousStatement = undefined;\n  realm.interpreterRealm.previousStatementValue = undefined;\n\n  // console.log('compute program', program.map(prettyPrintAST));\n\n  let resultsToCache: CacheContents[] = [];\n  for (const block of program) {\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      const [result, value] = await computeStatement(program, block.id, realm);\n\n      realm.inferContext.previousStatement = result.result.type;\n      realm.interpreterRealm.previousStatementValue = value;\n\n      resultsToCache.push({ result, value });\n    } catch (err) {\n      resultsToCache.push({ result: resultFromError(err as Error, block.id) });\n      realm.inferContext.previousStatement = undefined;\n      realm.interpreterRealm.previousStatementValue = undefined;\n    }\n  }\n\n  // copying the result triggers the getter from the identified result,\n  // ... effectively freezing the type\n  // We can only do this after computing the whole program.\n  resultsToCache = resultsToCache.map((result) => ({\n    result: { ...result.result },\n    value: result.value,\n  }));\n\n  for (const [block, result] of zip(program, resultsToCache)) {\n    realm.addToCache(block.id, result);\n  }\n  // same here:\n  return resultsToCache.map((resultToCache) => resultToCache.result);\n};\n\nconst inferWhileRetrievingNames = async (\n  ctx: Context,\n  statement: AST.Statement\n) => {\n  try {\n    ctx.usedNames = [];\n    const valueType = await inferStatement(ctx, statement);\n    const { usedNames } = ctx;\n    return [valueType, usedNames] as const;\n  } finally {\n    ctx.usedNames = undefined;\n  }\n};\n","import { AST } from '..';\nimport type { Computer } from '../computer/Computer';\nimport { getExprRef } from '../exprRefs';\nimport { BlocksInUseInformation, Program } from '../types';\n\nexport const programDependencies = (\n  computer: Computer,\n  program: Program,\n  ...blockIds: string[]\n): BlocksInUseInformation[] => {\n  const allVarNames: string[] = [];\n  const varNames = new Map<string, string>();\n  blockIds.flatMap((id) => {\n    const result = computer.getBlockIdResult$.get(id);\n    const block = program.find((p) => p.id === id)?.block;\n    if (!(result?.type !== 'computer-result' || !block)) {\n      const blockSymbols = getDefinedSymbols(block);\n      blockSymbols.forEach((symbol) => {\n        if (symbol !== '') {\n          if (!symbol.startsWith('exprRef_')) {\n            allVarNames.push(symbol);\n          }\n          varNames.set(symbol, id);\n        }\n      });\n    }\n  });\n\n  const programDependencyGraph = program\n    .map((p) => {\n      const usedInBlockId = p.id;\n      const stat = p.block?.args.at(0);\n      const result = computer.getBlockIdResult$.get(p.id);\n      if (!stat || result?.type !== 'computer-result') {\n        return [];\n      }\n\n      return (\n        result.usedNames\n          ?.map(([ns, name]) => (ns ? `${ns}.${name}` : name))\n          ?.filter((varName) => varNames.has(varName))\n          ?.map((varName: string) => {\n            const inBlockId = varNames.get(varName);\n            return { varName, inBlockId, usedInBlockId };\n          }) || []\n      );\n    })\n    .flatMap((a) => a);\n\n  return allVarNames.flatMap((currentName) => {\n    const allMatchingVarName = programDependencyGraph.filter(\n      (obj) => obj.varName === currentName\n    );\n    if (allMatchingVarName && allMatchingVarName.length !== 0) {\n      const { varName, inBlockId } = allMatchingVarName[0];\n      return {\n        varName,\n        inBlockId,\n        usedInBlockId: allMatchingVarName.map(\n          (blockInfo) => blockInfo.usedInBlockId\n        ),\n      };\n    } else {\n      return { varName: currentName, usedInBlockId: [] };\n    }\n  });\n};\n\nexport const blocksInUse = (\n  computer: Computer,\n  program: Program,\n  ...blockIds: string[]\n): BlocksInUseInformation[] => {\n  const blocksInUseForBlockIds = programDependencies(\n    computer,\n    program,\n    ...blockIds\n  );\n  return blocksInUseForBlockIds.filter(\n    (blockInfo) => blockInfo.usedInBlockId.length !== 0\n  );\n};\n\nexport const isInUse = (\n  computer: Computer,\n  program: Program,\n  ...blockIds: string[]\n): boolean => {\n  return blocksInUse(computer, program, ...blockIds).length !== 0;\n};\n\nconst getDefinedSymbols = (block: AST.Block) =>\n  block.args\n    .flatMap((stat) => {\n      switch (stat.type) {\n        case 'assign':\n          return [stat.args[0].args[0]];\n        case 'table':\n          return [stat.args[0].args[0]];\n        case 'categories':\n          return [stat.args[0].args[0]];\n        case 'function-definition':\n          return [stat.args[0].args[0]];\n        case 'table-column-assign':\n          return [`${stat.args[0].args[0]}.${stat.args[1].args[0]}`];\n        default:\n          return [];\n      }\n    })\n    .concat(getExprRef(block.id ?? ''));\n","import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector';\nimport { dequal } from 'dequal';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport { identity } from '@decipad/utils';\n\n/**\n * Multipurpose listener helper.\n *\n * - .observe() is an rxjs Observable\n * - .use() and .useWithSelector() are react hooks\n * - .get() just gets the value once\n */\nexport interface ListenerHelper<Args extends unknown[], Ret> {\n  observe(...a: Args): Observable<Ret>;\n  observeWithSelector<T>(selector: (item: Ret) => T, ...a: Args): Observable<T>;\n  use(...a: Args): Ret;\n  useWithSelector<T>(selector: (item: Ret) => T, ...a: Args): T;\n  get(...a: Args): Ret;\n}\n\nexport function listenerHelper<\n  SubjectContents,\n  MoreArgs extends unknown[],\n  Ret\n>(\n  subject: BehaviorSubject<SubjectContents>,\n  select: (a: SubjectContents, ...m: MoreArgs) => Ret\n): ListenerHelper<MoreArgs, Ret> {\n  const rootSubscribe = (callback: () => void) => {\n    const sub = subject.subscribe(callback);\n    return () => sub.unsubscribe();\n  };\n\n  const rootGet = () => subject.getValue();\n\n  const get = (...a: MoreArgs) => select(subject.getValue(), ...a);\n\n  const observe = (...a: MoreArgs) =>\n    subject.pipe(\n      map((item) => select(item, ...a)),\n      distinctUntilChanged((cur, next) => dequal(cur, next))\n    );\n\n  const observeWithSelector = <T>(\n    pick: (item: Ret) => T,\n    ...a: MoreArgs\n  ): Observable<T> =>\n    subject.pipe(\n      map((item) => pick(select(item, ...a))),\n      distinctUntilChanged((cur, next) => dequal(cur, next))\n    );\n\n  const use = (...a: MoreArgs) => useWithSelector(identity, ...a);\n\n  const useWithSelector = <T>(pick: (item: Ret) => T, ...a: MoreArgs): T =>\n    useSyncExternalStoreWithSelector(\n      rootSubscribe,\n      rootGet,\n      rootGet,\n      (item) => pick(select(item, ...a)),\n      dequal\n    );\n\n  return { get, observe, observeWithSelector, use, useWithSelector };\n}\n","import {\n  Time,\n  AST,\n  getDateFromAstForm,\n  stringifyDate,\n  SerializedType,\n} from '@decipad/language';\n\nexport interface Parseable {\n  varName?: string;\n  kind: Exclude<SerializedType['kind'], 'date'>;\n}\n\nexport interface ParseableDate {\n  varName?: string;\n  kind: 'date';\n  dateStr: string;\n  dateGranularity: Time.Specificity;\n}\n\n/**\n * Given an AST assignment Statement, it returns the type of the value being assigned. For now it\n * serves a specific purpose for literal values such as booleans, strings, dates, numbers and\n * numbers with units.\n */\nexport function astToParseable(\n  ast: AST.Statement,\n  depth = 0\n): Parseable | ParseableDate | undefined {\n  if (ast.type === 'assign') {\n    const [ident, exp] = ast.args;\n    const ret = astToParseable(exp);\n    return ret ? { ...ret, varName: ident.args[0] } : undefined;\n  }\n\n  if (ast.type === 'literal') {\n    switch (ast.args[0]) {\n      case 'boolean':\n        return { kind: 'boolean' };\n      case 'number':\n        return { kind: 'number' };\n      case 'string':\n        return { kind: 'string' };\n    }\n  }\n\n  if (ast.type === 'date') {\n    const [utcDate, granularity] = getDateFromAstForm(ast.args);\n\n    const dateStr = stringifyDate(utcDate, granularity);\n\n    return {\n      kind: 'date',\n      dateStr,\n      dateGranularity: granularity,\n    };\n  }\n\n  if (ast.type === 'function-call') {\n    const [fname, funArgs] = ast.args;\n\n    switch (fname.args[0]) {\n      case 'implicit*':\n      case '/':\n      case '^':\n      case 'per':\n      case 'for': {\n        const [left, right] = funArgs.args.map((a) =>\n          astToParseable(a, depth + 1)\n        );\n\n        if (left?.kind === 'number' && right?.kind === 'number') {\n          return { kind: 'number' };\n        }\n        return;\n      }\n    }\n  }\n\n  if (ast.type === 'ref' && depth > 0) {\n    return { kind: 'number' };\n  }\n\n  return undefined;\n}\n","import { previousRefSymbols } from '@decipad/language';\nimport { getDefined } from '@decipad/utils';\nimport { AST } from '..';\nimport {\n  iterProgram,\n  findSymbolsUsed,\n  getDefinedSymbol,\n  getStatement,\n  getSymbolsDefinedInBlocks,\n} from '../utils';\n\nexport const getDependents = (\n  program: AST.Block[],\n  dependentsOf: string[],\n  initialSymbols = new Set<string>(),\n  secondPass = false\n): string[] => {\n  const dependents: string[] = [];\n  const dependencySymbols = new Set([\n    ...getSymbolsDefinedInBlocks(program, dependentsOf),\n    ...initialSymbols,\n  ]);\n\n  iterProgram(program, (stmt, blockId) => {\n    const usedSymbols = findSymbolsUsed(stmt);\n\n    const isDependent =\n      usedSymbols.some((sym) => dependencySymbols.has(sym)) ||\n      dependencySymbols.has(getDefinedSymbol(stmt) ?? '');\n    if (isDependent) {\n      // Mark as dependent\n      dependents.push(blockId);\n\n      // Place the symbol if any in the dependency bag so its uses are identified\n      const sym = getDefinedSymbol(getStatement(program, blockId));\n      if (sym != null) {\n        dependencySymbols.add(sym);\n      }\n    }\n    for (const s of previousRefSymbols) {\n      dependencySymbols.add(s);\n    }\n  });\n\n  // Perform a second pass, wherein we know what tables are dependents and check *their* dependencies.\n  // This is because today, tables must be evaluated wholesale.\n  if (!secondPass) {\n    const tableNames = getTablesInBlockIds(program, dependents);\n    const checkSymbols = new Set([...tableNames, ...dependencySymbols]);\n    return getDependents(program, dependents, checkSymbols, true);\n  }\n\n  return dependents;\n};\n\nfunction getTablesInBlockIds(program: AST.Block[], blockIdsToCheck: string[]) {\n  const tables = new Set<string>();\n  for (const blockId of blockIdsToCheck) {\n    const stmt = getStatement(program, blockId);\n    if (stmt.type === 'table' || stmt.type === 'table-column-assign') {\n      tables.add(getDefined(getDefinedSymbol(stmt)));\n    }\n  }\n  return tables;\n}\n","import { dequal } from 'dequal';\nimport { AST, ExternalDataMap } from '@decipad/language';\nimport { getDependents } from './dependents';\nimport {\n  findSymbolsUsed,\n  getAllSymbolsDefined,\n  getDefinedSymbol,\n  getExistingBlockIds,\n  iterProgram,\n  setIntersection,\n} from '../utils';\n\nconst getChangedMapKeys = <T>(\n  oldMap: Map<string, T>,\n  newMap: Map<string, T>\n): string[] => {\n  const allKeys = new Set(\n    Array.from(oldMap.keys()).concat(Array.from(newMap.keys()))\n  );\n\n  return Array.from(allKeys).filter((key) => {\n    const oldVal = oldMap.get(key);\n    const newVal = newMap.get(key);\n\n    return !dequal(oldVal, newVal);\n  });\n};\n\nconst mapify = (blocks: AST.Block[]) => new Map(blocks.map((b) => [b.id, b]));\nexport const getChangedBlocks = (\n  oldBlocks: AST.Block[],\n  newBlocks: AST.Block[]\n) => new Set(getChangedMapKeys(mapify(oldBlocks), mapify(newBlocks)));\n\n/**\n * Find reassigned variables, variables being used before being defined\n */\nexport const findSymbolErrors = (program: AST.Block[]) => {\n  const reassigned = new Set<string>();\n  const maybeUsedBeforeDef = new Set<string>();\n  const seenDefinitions = new Set<string>();\n\n  iterProgram(program, (stmt) => {\n    const sym = getDefinedSymbol(stmt, true);\n\n    for (const usedSym of findSymbolsUsed(stmt)) {\n      if (sym === usedSym) continue;\n\n      if (!seenDefinitions.has(usedSym)) {\n        maybeUsedBeforeDef.add(usedSym);\n      }\n    }\n\n    if (sym != null) {\n      if (seenDefinitions.has(sym)) {\n        reassigned.add(sym);\n      }\n\n      seenDefinitions.add(sym);\n    }\n  });\n\n  // It's only used before def, if it's actually defined\n  const usedBeforeDef = setIntersection(maybeUsedBeforeDef, seenDefinitions);\n\n  return new Set([...reassigned, ...usedBeforeDef]);\n};\n\nexport const findSymbolsAffectedByChange = (\n  oldBlocks: AST.Block[],\n  newBlocks: AST.Block[]\n) => {\n  const changedBlockIds = getChangedBlocks(oldBlocks, newBlocks);\n\n  const codeWhichChanged = Array.from(oldBlocks)\n    .concat(Array.from(newBlocks))\n    .filter(\n      (block) =>\n        changedBlockIds.has(block.id) ||\n        !oldBlocks.some((b) => b.id === block.id)\n    );\n  const affectedSymbols = new Set(getAllSymbolsDefined(codeWhichChanged));\n\n  return affectedSymbols;\n};\n\nexport interface GetStatementsToEvictArgs {\n  oldBlocks: AST.Block[];\n  newBlocks: AST.Block[];\n  oldExternalData?: ExternalDataMap;\n  newExternalData?: ExternalDataMap;\n}\n\nexport const getStatementsToEvict = ({\n  oldBlocks,\n  newBlocks,\n  oldExternalData = new Map(),\n  newExternalData = new Map(),\n}: GetStatementsToEvictArgs) => {\n  const changedBlockIds = getChangedBlocks(oldBlocks, newBlocks);\n\n  const dirtyLocs = new Set(getExistingBlockIds(oldBlocks, changedBlockIds));\n\n  const dirtySymbols = new Set([\n    ...getChangedMapKeys(oldExternalData, newExternalData),\n    ...findSymbolsAffectedByChange(oldBlocks, newBlocks),\n    ...findSymbolErrors(oldBlocks),\n    ...findSymbolErrors(newBlocks),\n  ]);\n\n  const dependentsOfBlocksAndSymbols = getDependents(\n    oldBlocks,\n    Array.from(dirtyLocs),\n    dirtySymbols\n  );\n\n  for (const dep of dependentsOfBlocksAndSymbols) {\n    dirtyLocs.add(dep);\n  }\n\n  const toEvict = oldBlocks.flatMap((b) => (dirtyLocs.has(b.id) ? b.id : []));\n\n  return toEvict;\n};\n","import {\n  AST,\n  ColumnLike,\n  ExternalDataMap,\n  isColumnLike,\n  makeContext as makeInferContext,\n  Realm,\n  stringifyDate,\n  Table,\n  Type,\n  Value,\n} from '@decipad/language';\nimport {\n  getStatementsToEvict,\n  GetStatementsToEvictArgs,\n} from '../caching/getStatementsToEvict';\nimport type { IdentifiedResult } from '../types';\nimport { getDefinedSymbol, getStatement } from '../utils';\n\nexport type CacheContents = {\n  result: IdentifiedResult;\n  value?: Value;\n};\n\nexport class ComputationRealm {\n  inferContext = makeInferContext();\n  interpreterRealm = new Realm(this.inferContext);\n  locCache = new Map<string, CacheContents>();\n  errorLocs = new Set<string>();\n\n  setExternalData(externalData: ExternalDataMap) {\n    this.interpreterRealm.externalData = externalData;\n    this.inferContext.externalData = externalData;\n  }\n\n  evictCache({ oldBlocks, ...rest }: GetStatementsToEvictArgs) {\n    for (const loc of this.errorLocs) {\n      this.evictStatement(oldBlocks, loc);\n    }\n\n    for (const blockId of getStatementsToEvict({ oldBlocks, ...rest })) {\n      this.evictStatement(oldBlocks, blockId);\n    }\n  }\n\n  evictStatement(program: AST.Block[], blockId: string) {\n    this.errorLocs.delete(blockId);\n    this.locCache.delete(blockId);\n\n    const sym = getDefinedSymbol(getStatement(program, blockId));\n    if (sym) {\n      this.interpreterRealm.stack.delete(sym, 'global');\n      this.inferContext.stack.delete(sym, 'global');\n      this.interpreterRealm.functions.delete(sym);\n      this.inferContext.functionDefinitions.delete(sym);\n    }\n  }\n\n  getFromCache(loc: string) {\n    return this.locCache.get(loc) ?? null;\n  }\n\n  /** Retrieve labels (first column) for each table, indexed by table name. */\n  getIndexLabels(): Map<string, string[]> {\n    const labels = new Map();\n\n    const addLabels = (name: string, column?: ColumnLike, cellType?: Type) => {\n      if (!column || !cellType) {\n        return;\n      }\n\n      const data = column.getData();\n\n      if (cellType.type === 'string' || cellType.type === 'number') {\n        labels.set(\n          name,\n          (data as string[]).map((s) => String(s))\n        );\n      }\n\n      const { date } = cellType;\n      if (date) {\n        labels.set(\n          name,\n          (data as bigint[]).map((d) => stringifyDate(d, date))\n        );\n      }\n    };\n\n    for (const [\n      name,\n      type,\n    ] of this.inferContext.stack.globalVariables.entries()) {\n      const table = this.interpreterRealm.stack.get(name, 'global');\n\n      if (table instanceof Table) {\n        addLabels(name, table.columns[0], type.columnTypes?.[0]);\n      } else if (table != null && isColumnLike(table)) {\n        addLabels(name, table, type.cellType ?? undefined);\n      }\n    }\n\n    return labels;\n  }\n\n  addToCache(loc: string, result: CacheContents) {\n    if (result.result?.result?.type?.kind !== 'type-error') {\n      this.locCache.set(loc, result);\n    } else {\n      this.errorLocs.add(loc);\n    }\n  }\n}\n","import type { ColumnDesc } from './Computer';\n\nexport const deduplicateColumnResults = (\n  acc: ColumnDesc[],\n  column: ColumnDesc\n): ColumnDesc[] => {\n  // find duplicate\n  const existsPos = acc.findIndex(\n    (existingCol) =>\n      existingCol.tableName === column.tableName &&\n      existingCol.columnName === column.columnName\n  );\n  if (existsPos >= 0) {\n    const existsColumn = acc[existsPos];\n    if (!existsColumn.blockId && column.blockId) {\n      acc.splice(existsPos, 1);\n      acc.push(column);\n    } else {\n      // do nothing, as the existing block has more information\n    }\n  } else {\n    // no matching column, just add it\n    acc.push(column);\n  }\n  return acc;\n};\n","import { NotebookResults } from '../types';\n\nexport const defaultComputerResults: NotebookResults = {\n  blockResults: {},\n  indexLabels: new Map(),\n};\n","import { unique } from '@decipad/utils';\nimport { AST } from '..';\nimport { getIdentifierString } from '../utils';\n\nexport type TableNamespaces = Map<string, Set<string>>;\n\n/** Finds what `node` depends on. `namespaces` can be built in the `findAllTables` function.\n * If we're in a table context (e.g. `Table.Col1 = 1`), then we can use the `namespaces` to\n * find out what columns are available in the table.\n *\n * Table columns are denoted as TableName::ColumnName\n */\nexport const dependencies = (\n  initialNode: AST.Node,\n  namespaces: TableNamespaces = new Map()\n): string[] => {\n  if (initialNode.type === 'block') {\n    // We need to get to the statement level\n    return unique(\n      initialNode.args.flatMap((node) => dependencies(node, namespaces))\n    );\n  }\n\n  const localNames = getLocalNames(initialNode, namespaces) ?? new Set();\n  const localTableName = ((node: AST.Node) => {\n    if (node.type === 'table') {\n      return getIdentifierString(node.args[0]);\n    }\n    if (node.type === 'table-column-assign') {\n      return getIdentifierString(node.args[0]);\n    }\n    return undefined;\n  })(initialNode);\n\n  function findRefs(node: AST.Node): string[] {\n    switch (node.type) {\n      case 'argument-names':\n      case 'catdef':\n      case 'coldef':\n      case 'date':\n      case 'def':\n      case 'tabledef':\n      case 'externalref':\n      case 'funcdef':\n      case 'generic-identifier':\n      case 'literal':\n      case 'noop': {\n        return [];\n      }\n      case 'block':\n      case 'argument-list':\n      case 'column-items':\n      case 'generic-list':\n      case 'matrix-matchers':\n      case 'range':\n      case 'table-column-assign':\n      case 'table-spread': {\n        return unique(node.args.flatMap(findRefs));\n      }\n      case 'assign':\n      case 'table':\n      case 'categories': {\n        return unique(node.args.slice(1).flatMap(findRefs));\n      }\n      case 'column':\n      case 'sequence': {\n        return findRefs(node.args[0]);\n      }\n      case 'property-access': {\n        const [table, column] = node.args;\n        if (table.type === 'ref') {\n          return unique([...findRefs(table), `${table.args[0]}::${column}`]);\n        }\n\n        // TODO no idea what table this is, let's just do all of them\n        // In the future we can improve this by making sure\n        // That all column names are globally unique!\n        const allPossiblePropertyAccesses = [...namespaces].flatMap(\n          ([table, columns]) => {\n            return columns.has(column) ? [`${table}::${column}`] : [];\n          }\n        );\n        return unique([...allPossiblePropertyAccesses, ...findRefs(table)]);\n      }\n      case 'directive': {\n        const [, ...args] = node.args;\n        return unique(args.flatMap(findRefs));\n      }\n      case 'funcref': {\n        return node.args;\n      }\n      case 'function-call': {\n        const [funcName, argList] = node.args;\n        return [\n          ...findRefs(funcName),\n          ...unique(argList.args.flatMap(findRefs)),\n        ];\n      }\n      case 'function-definition': {\n        const [name, args, body] = node.args;\n        const argNames = findRefs(args);\n        const bodyDeps = findRefs(body);\n        const externalBodyDeps = bodyDeps.filter(\n          (dep) => !argNames.includes(dep)\n        );\n        return [...findRefs(name), ...externalBodyDeps];\n      }\n      case 'matrix-assign': {\n        const [, where, assignee] = node.args;\n        return unique([...findRefs(where), ...findRefs(assignee)]);\n      }\n      case 'matrix-ref':\n      case 'match':\n      case 'matchdef':\n      case 'tiered':\n      case 'tiered-def': {\n        return unique(node.args.flatMap(findRefs));\n      }\n      case 'ref': {\n        if (localNames.has(node.args[0])) {\n          if (localTableName != null) {\n            return [`${localTableName}::${node.args[0]}`];\n          } else {\n            // Ignore function arguments\n            return [];\n          }\n        }\n        return node.args;\n      }\n      case 'tablepartialdef': {\n        return node.args;\n      }\n      case 'table-column': {\n        const [, column] = node.args;\n        return findRefs(column);\n      }\n    }\n  }\n  return findRefs(initialNode);\n};\n\nexport const getDefinedEntity = (statement?: AST.Statement) => {\n  switch (statement?.type) {\n    case 'assign':\n    case 'function-definition':\n    case 'table': {\n      return getIdentifierString(statement.args[0]);\n    }\n\n    case 'table-column-assign': {\n      return `${getIdentifierString(statement.args[0])}::${getIdentifierString(\n        statement.args[1]\n      )}`;\n    }\n\n    default: {\n      return undefined;\n    }\n  }\n};\n\nconst blocksToStatements = (blocksOrStmts: AST.Node[]): AST.Node[] =>\n  blocksOrStmts.flatMap((node) => {\n    if (node.type === 'block') {\n      return node.args;\n    } else {\n      return [node];\n    }\n  });\n\n/** Find tables, and update the namespaces available */\nexport function findAllTables(nodes: AST.Node[]) {\n  const namespaces: TableNamespaces = new Map();\n\n  function namespaceAdd(nsName: string, toAdd: string[]) {\n    let ns = namespaces.get(nsName);\n    if (ns == null) {\n      ns = new Set();\n      namespaces.set(nsName, ns);\n    }\n\n    for (const name of toAdd) {\n      ns.add(name);\n    }\n  }\n\n  for (const node of blocksToStatements(nodes)) {\n    if (node.type === 'table') {\n      const ns = getIdentifierString(node.args[0]);\n      const colNames = getTableColNames(node);\n\n      namespaceAdd(ns, colNames);\n    }\n    if (node.type === 'table-column-assign') {\n      const [tableName, colName] = node.args;\n      const ns = getIdentifierString(tableName);\n\n      namespaceAdd(ns, [getIdentifierString(colName)]);\n    }\n  }\n\n  return namespaces;\n}\n\nfunction getTableColNames(table: AST.Table) {\n  return table.args.flatMap((colDef) => {\n    if (colDef.type === 'table-column') {\n      return getIdentifierString(colDef.args[0]);\n    } else {\n      return [];\n    }\n  });\n}\n\nfunction getLocalNames(\n  nodeOrBlock: AST.Node,\n  namespaces: TableNamespaces\n): Set<string> | null {\n  const names = [];\n\n  for (const node of blocksToStatements([nodeOrBlock])) {\n    if (node.type === 'table') {\n      names.push(getIdentifierString(node.args[0]));\n      names.push(...getTableColNames(node));\n    }\n    if (node.type === 'table-column-assign') {\n      const tableName = getIdentifierString(node.args[0]);\n\n      names.push(...(namespaces.get(tableName) ?? new Set()));\n    }\n    if (node.type === 'function-definition') {\n      names.push(...node.args[1].args.map(getIdentifierString));\n    }\n    if (node.type === 'tiered-def') {\n      names.push('slice', 'tier');\n    }\n  }\n\n  return names.length > 0 ? new Set(names) : null;\n}\n","import { getDefined } from '@decipad/utils';\nimport { isAssignment } from '@decipad/language';\nimport { IdentifiedBlock, IdentifiedError, ProgramBlock } from '../types';\nimport { getIdentifierString } from '../utils';\nimport { dependencies, TableNamespaces, findAllTables } from './dependencies';\n\ninterface Node {\n  entity: string | null;\n  temporaryMark: boolean;\n  permanentMark: boolean;\n  edges?: Node[];\n  value: IdentifiedBlock;\n}\n\ntype EntityNodeMap = Map<string, Node[]>;\n\nconst badBlock = (block: ProgramBlock): block is IdentifiedError => {\n  return block.type === 'identified-error';\n};\n\nconst goodBlock = (block: ProgramBlock): block is IdentifiedBlock => {\n  return block.type !== 'identified-error';\n};\n\nconst blockEntity = ({ block }: IdentifiedBlock): string | null => {\n  if (block.args.length < 1) {\n    return null;\n  }\n  const statement = block.args[0];\n  if (!statement || !isAssignment(statement)) {\n    return null;\n  }\n  // we have a statement\n  const arg0 = statement.args[0];\n  return getIdentifierString(arg0);\n};\n\nconst blockToNode = (block: IdentifiedBlock): Node => {\n  return {\n    entity: blockEntity(block),\n    temporaryMark: false,\n    permanentMark: false,\n    value: block,\n  };\n};\n\nconst notSelf = (entity: string) => (node: Node | undefined) =>\n  !node || node.entity !== entity;\n\nconst drawEdges = (\n  node: Node,\n  allNodes: EntityNodeMap,\n  namespaces: TableNamespaces\n): void => {\n  const deps = dependencies(node.value.block, namespaces);\n  let edges = deps.flatMap((dep) => allNodes.get(dep)).filter(Boolean);\n  const { entity } = node;\n  if (entity != null) {\n    edges = edges.filter(notSelf(entity)) as Node[];\n  }\n  node.edges = edges as Node[];\n};\n\nconst identifiedErrorFromNode = (id: string): IdentifiedError => ({\n  type: 'identified-error',\n  id,\n  errorKind: 'dependency-cycle',\n});\n\nexport const topologicalSort = (blocks: ProgramBlock[]): ProgramBlock[] => {\n  const errored = blocks.filter(badBlock);\n  const sorted: IdentifiedBlock[] = [];\n\n  const goodBlocks = blocks.filter(goodBlock);\n  const nodes = goodBlocks.map(blockToNode);\n\n  const identifiersToNode = nodes.reduce<EntityNodeMap>((map, node) => {\n    if (node.entity !== null) {\n      const existing = map.get(node.entity) ?? [];\n      map.set(node.entity, existing.concat(node));\n    }\n\n    return map;\n  }, new Map());\n\n  const visit = (n: Node): void | boolean => {\n    if (n.permanentMark) {\n      return;\n    }\n    if (n.temporaryMark) {\n      // Circular dep\n      const errorNode = identifiedErrorFromNode(n.value.id);\n      if (!n.permanentMark) {\n        n.permanentMark = true;\n        errored.push(errorNode);\n      }\n\n      return true;\n    }\n    n.temporaryMark = true;\n\n    for (const edge of getDefined(n.edges)) {\n      const error = visit(edge);\n      if (error) {\n        if (!n.permanentMark) {\n          n.permanentMark = true;\n          errored.push(identifiedErrorFromNode(n.value.id));\n        }\n        return error;\n      }\n    }\n\n    n.temporaryMark = false;\n    n.permanentMark = true;\n    sorted.push(n.value);\n  };\n\n  const depNamespaces = findAllTables(goodBlocks.map((b) => b.block));\n  for (const node of nodes) {\n    drawEdges(node, identifiersToNode, depNamespaces);\n  }\n\n  for (const node of nodes) {\n    visit(node);\n  }\n\n  return [...sorted, ...errored];\n};\n","import {\n  DeciNumberRep,\n  formatError,\n  formatNumber,\n  formatUnit,\n} from '@decipad/format';\nimport {\n  AST,\n  AutocompleteName,\n  deserializeType,\n  ErrSpec,\n  evaluateStatement,\n  ExternalDataMap,\n  inferExpression,\n  linearizeType,\n  parseExpression,\n  parseExpressionOrThrow,\n  Result,\n  SerializedType,\n  SerializedTypes,\n  serializeType,\n  Unit,\n} from '@decipad/language';\nimport DeciNumber from '@decipad/number';\nimport { anyMappingToMap, getDefined, identity, zip } from '@decipad/utils';\nimport { dequal } from 'dequal';\nimport produce from 'immer';\nimport Queue from 'queue';\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport {\n  combineLatestWith,\n  concatMap,\n  distinctUntilChanged,\n  map,\n  shareReplay,\n  switchMap,\n  throttleTime,\n} from 'rxjs/operators';\nimport { findNames } from '../autocomplete/findNames';\nimport { computeProgram } from '../compute/computeProgram';\nimport {\n  blocksInUse,\n  isInUse,\n  programDependencies,\n} from '../dependencies/dependencies';\nimport { getExprRef, makeNamesFromIds } from '../exprRefs';\nimport { listenerHelper } from '../hooks';\nimport { captureException } from '../reporting';\nimport { dropWhileComputing } from '../tools/dropWhileComputing';\nimport type {\n  ComputeRequest,\n  ComputeRequestWithExternalData,\n  IdentifiedError,\n  IdentifiedResult,\n  NotebookResults,\n  Program,\n  ProgramBlock,\n  UserParseError,\n} from '../types';\nimport { getDefinedSymbol, getGoodBlocks, getIdentifierString } from '../utils';\nimport { astToParseable } from './astToParseable';\nimport { ComputationRealm } from './ComputationRealm';\nimport { deduplicateColumnResults } from './deduplicateColumnResults';\nimport { defaultComputerResults } from './defaultComputerResults';\nimport { updateChangedProgramBlocks } from './parseUtils';\nimport { topologicalSort } from './topologicalSort';\n\nexport { getUsedIdentifiers } from './getUsedIdentifiers';\nexport type { TokenPos } from './getUsedIdentifiers';\n\nexport interface ColumnDesc {\n  tableName: string;\n  columnName: string;\n  result: Result.Result<'column'>;\n  blockId?: string;\n}\n\nexport interface DimensionExplanation {\n  indexedBy: string | undefined;\n  labels: readonly string[] | undefined;\n  dimensionLength: number;\n}\n\ninterface ComputerOpts {\n  requestDebounceMs: number;\n}\n\ntype ParseErrorMap = Map<string, UserParseError>;\n\nexport class Computer {\n  private locale = 'en-US';\n  private latestProgram: ProgramBlock[] = [];\n  private latestExternalData: ExternalDataMap = new Map();\n  computationRealm = new ComputationRealm();\n  public readonly requestDebounceMs: number;\n  private externalData = new BehaviorSubject<ExternalDataMap>(new Map());\n  private automaticallyGeneratedNames = new Set<string>();\n\n  /** @deprecated Imperative parse errors */\n  private imperativeParseErrors = new BehaviorSubject<ParseErrorMap>(new Map());\n\n  // streams\n  private readonly computeRequests = new Subject<ComputeRequest>();\n  public results = new BehaviorSubject<NotebookResults>(defaultComputerResults);\n\n  constructor({ requestDebounceMs = 100 }: Partial<ComputerOpts> = {}) {\n    this.requestDebounceMs = requestDebounceMs;\n    this.wireRequestsToResults();\n  }\n\n  public pushCompute(req: ComputeRequest): void {\n    this.computeRequests.next(req);\n  }\n\n  /**\n   * Wire our computeRequests stream to the \"results\" stream.\n   * Timing is handled here too (debouncing, throttling)\n   * And the externalData stream (containing imports) is integrated here.\n   */\n  private wireRequestsToResults() {\n    this.computeRequests\n      .pipe(\n        combineLatestWith(this.externalData),\n        // Debounce to give React an easier time\n        throttleTime(this.requestDebounceMs, undefined, {\n          leading: false,\n          trailing: true,\n        }),\n        map(([computeReq, externalData]) => ({ ...computeReq, externalData })),\n        // Make sure the new request is actually different\n        distinctUntilChanged((prevReq, req) => dequal(prevReq, req)),\n        // Compute me some computes!\n        dropWhileComputing((req) => this.computeRequest(req)),\n        switchMap((item) => (item == null ? [] : [item])),\n        shareReplay(1)\n      )\n      .subscribe(this.results);\n  }\n\n  getVarBlockId(varName: string) {\n    const mainIdentifier = varName.includes('.') // table.name\n      ? varName.split('.')[0]\n      : varName;\n\n    return this.latestProgram.find((p) => {\n      if (varName === getExprRef(p.id)) {\n        return true;\n      } else if (p.type === 'identified-block' && p.block.args.length > 0) {\n        return getDefinedSymbol(p.block.args[0]) === mainIdentifier;\n      } else {\n        return false;\n      }\n    })?.id;\n  }\n\n  results$ = listenerHelper(this.results, identity);\n\n  getBlockIdResult$ = listenerHelper(\n    this.results,\n    (\n      results,\n      blockId?: string | null\n    ): Readonly<IdentifiedError> | Readonly<IdentifiedResult> | undefined =>\n      results.blockResults[blockId ?? '']\n  );\n\n  getVarBlockId$ = listenerHelper(this.results, (_, varName: string) =>\n    this.getVarBlockId(varName)\n  );\n\n  getVarResult$ = listenerHelper(this.results, (results, varName: string) => {\n    const blockId = this.getVarBlockId(varName);\n    return blockId ? results.blockResults[blockId] : undefined;\n  });\n\n  getAllColumnsIndexedBy$ = listenerHelper(\n    this.results,\n    (results, tableName: string) => {\n      return Object.values(results.blockResults).flatMap((br) => {\n        if (\n          br.type === 'computer-result' &&\n          br.result.type.kind === 'column' &&\n          br.result.type.indexedBy === tableName\n        ) {\n          return [br];\n        }\n        return [];\n      });\n    }\n  );\n\n  getSymbolDefinedInBlock(blockId: string): string | undefined {\n    const parsed = this.latestProgram.find((p) => p.id === blockId);\n    if (parsed && parsed.type === 'identified-block') {\n      const firstNode = parsed.block.args[0];\n      if (firstNode) {\n        const symbol = getDefinedSymbol(firstNode);\n        if (symbol) {\n          if (!this.automaticallyGeneratedNames.has(symbol)) {\n            return symbol;\n          }\n        }\n      }\n    } else if (parsed?.type === 'identified-error') {\n      return parsed.definesVariable;\n    }\n    return undefined;\n  }\n\n  getSymbolOrColumnName$ = listenerHelper(\n    this.results,\n    (_, blockId: string) => {\n      const programBlock = this.latestProgram.find((p) => p.id === blockId);\n      return (\n        programBlock?.definesTableColumn?.join('.') ||\n        programBlock?.definesVariable ||\n        this.getSymbolDefinedInBlock(blockId)\n      );\n    }\n  );\n\n  isInUse$ = listenerHelper(this.results, (_, ...blockIds: string[]) =>\n    this.isInUse(...blockIds)\n  );\n\n  /** Is this blockId used in some expression elsewhere? */\n  isInUse(...blockIds: string[]) {\n    return isInUse(this, this.latestProgram, ...blockIds);\n  }\n\n  /** Information about block usage */\n  blocksInUse$ = listenerHelper(this.results, (_, ...blockIds: string[]) =>\n    this.blocksInUse(...blockIds)\n  );\n\n  blocksInUse(...blockIds: string[]) {\n    return blocksInUse(this, this.latestProgram, ...blockIds);\n  }\n\n  programDependencies$ = listenerHelper(\n    this.results,\n    (_, ...blockIds: string[]) => this.programDependencies(...blockIds)\n  );\n\n  programDependencies(...blockIds: string[]) {\n    return programDependencies(this, this.latestProgram, ...blockIds);\n  }\n\n  getSymbolDefinedInBlock$ = listenerHelper(\n    this.results,\n    (_, blockId: string) => this.getSymbolDefinedInBlock(blockId)\n  );\n\n  getParseableTypeInBlock(blockId: string) {\n    const parsed = this.latestProgram.find((p) => p.id === blockId);\n    if (parsed && parsed.type === 'identified-block') {\n      return astToParseable(parsed.block.args[0]);\n    }\n    return null;\n  }\n\n  getParseableTypeInBlock$ = listenerHelper(\n    this.results,\n    (_, blockId: string) => this.getParseableTypeInBlock(blockId)\n  );\n\n  /**\n   * Get names for the autocomplete, and information about them\n   */\n  getNamesDefined(inBlockId?: string): AutocompleteName[] {\n    const program = getGoodBlocks(this.latestProgram);\n    const toIgnore = new Set(this.automaticallyGeneratedNames);\n    return Array.from(\n      findNames(this.computationRealm, program, toIgnore, inBlockId)\n    );\n  }\n\n  getNamesDefined$ = listenerHelper(this.results, (_, inBlockId?: string) =>\n    this.getNamesDefined(inBlockId)\n  );\n\n  getFunctionDefinition(funcName: string): AST.FunctionDefinition | undefined {\n    return this.computationRealm.inferContext.functionDefinitions.get(funcName);\n  }\n\n  getFunctionDefinition$ = listenerHelper(this.results, (_, funcName: string) =>\n    this.getFunctionDefinition(funcName)\n  );\n\n  /** Does `name` exist? Ignores a block ID if you pass the second argument */\n  variableExists(name: string, inBlockId?: string) {\n    return this.latestProgram.some((p) => {\n      // Skip own block\n      if (p.id === inBlockId) {\n        return false;\n      }\n\n      if (p.definesVariable && p.definesVariable === name) {\n        return true;\n      }\n\n      if (p.type === 'identified-block' && p.block.args.length > 0) {\n        return getDefinedSymbol(p.block.args[0], false) === name;\n      } else {\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Finds a Column, and identifies its 1 or more dimensions in an array.\n   *\n   * The array contains how many values each dimension has.\n   */\n  explainDimensions$ = listenerHelper(\n    this.results,\n    (\n      results,\n      result: Result.Result<'column'>\n    ): DimensionExplanation[] | undefined => {\n      // We now have a column or matrix\n\n      const getDeepLengths = (value: Result.OneResult): number[] =>\n        Array.isArray(value) ? [value.length, ...getDeepLengths(value[0])] : [];\n\n      const dimensions = linearizeType(deserializeType(result.type));\n\n      dimensions.pop(); // remove tip\n\n      const deepLengths = getDeepLengths(result.value);\n\n      return zip(dimensions, deepLengths).map(([type, dimensionLength]) => {\n        return {\n          indexedBy: type.indexedBy ?? undefined,\n          labels: results.indexLabels.get(type.indexedBy ?? ''),\n          dimensionLength,\n        };\n      });\n    }\n  );\n\n  getAllTables$ = listenerHelper(this.results, (results) => {\n    return Object.entries(results.blockResults).flatMap(([id, b]) => {\n      if (!b.result) return [];\n\n      if (b.result.type.kind === 'table') {\n        return { id, tableName: b.result.type.indexName || '' };\n      }\n      return [];\n    });\n  });\n\n  public getAllColumns$ = listenerHelper(\n    this.results,\n    (results, filterForBlockId?: string): ColumnDesc[] => {\n      return Object.values(results.blockResults)\n        .flatMap((b) => {\n          if (b.result?.type.kind === 'table') {\n            if (filterForBlockId && b.id !== filterForBlockId) {\n              return [];\n            }\n            // external data results in a single table\n            if (this.latestExternalData.has(b.id)) {\n              const extData = getDefined(this.latestExternalData.get(b.id));\n              if (extData.type.kind !== 'table') {\n                return [];\n              }\n              return b.result.type.columnNames.map(\n                (columnName, columnIndex) => {\n                  const result = {\n                    type: {\n                      kind: 'column',\n                      cellType: (extData.type as SerializedTypes.Table)\n                        .columnTypes[columnIndex],\n                    },\n                    value: (extData.value as Result.Result<'table'>['value'])[\n                      columnIndex\n                    ],\n                  } as Result.Result<'column'>;\n                  const tableName = this.getSymbolDefinedInBlock(b.id);\n                  return {\n                    tableName: tableName ?? 'unnamed',\n                    columnName,\n                    result,\n                  };\n                }\n              );\n            } else {\n              const statement = this.latestProgram.find((p) => p.id === b.id)\n                ?.block?.args[0];\n              if (\n                (statement?.type !== 'table' && statement?.type !== 'assign') ||\n                !b.result?.value ||\n                !b.result?.type\n              ) {\n                return [];\n              }\n              const tableName = getIdentifierString(statement.args[0]);\n              return b.result.type.columnNames.map(\n                (columnName, columnIndex) => {\n                  const result = {\n                    type: {\n                      kind: 'column',\n                      cellType: (\n                        b.result.type as Result.Result<'table'>['type']\n                      ).columnTypes[columnIndex],\n                    },\n                    value: (b.result.value as Result.Result<'table'>['value'])[\n                      columnIndex\n                    ],\n                  } as Result.Result<'column'>;\n                  return {\n                    tableName,\n                    columnName,\n                    result,\n                  };\n                }\n              );\n            }\n          } else if (b.result?.type.kind === 'column') {\n            const statement = this.latestProgram.find((p) => p.id === b.id)\n              ?.block?.args[0];\n            if (statement?.type !== 'table-column-assign') {\n              return [];\n            }\n\n            const tableName = getIdentifierString(statement.args[0]);\n            if (filterForBlockId) {\n              const blockId = this.getVarBlockId(tableName);\n              if (blockId !== filterForBlockId) {\n                return [];\n              }\n            }\n            const columnName = getIdentifierString(statement.args[1]);\n            return [\n              {\n                tableName,\n                columnName,\n                result: b.result as Result.Result<'column'>,\n                blockId: b.id,\n              },\n            ];\n          }\n\n          return [];\n        })\n        .reduce(deduplicateColumnResults, []);\n    }\n  );\n\n  public getColumnNameDefinedInBlock$ = listenerHelper(\n    this.results,\n    (results, blockId: string): string | undefined => {\n      const block = results.blockResults[blockId];\n      if (block?.result?.type.kind === 'column') {\n        const statement = this.latestProgram.find((p) => p.id === block.id)\n          ?.block?.args[0];\n        if (statement?.type === 'table-column-assign') {\n          return getIdentifierString(statement.args[1]);\n        }\n      }\n      return undefined;\n    }\n  );\n\n  expressionResultFromText$(decilang: string) {\n    const exp = parseExpressionOrThrow(decilang);\n\n    return this.results.pipe(\n      concatMap(async () => this.expressionResult(exp)),\n      distinctUntilChanged((cur, next) => dequal(cur, next))\n    );\n  }\n\n  private computationQueue = new Queue({\n    concurrency: 1,\n    autostart: true,\n  });\n  private enqueueComputation<T>(\n    fn: () => Promise<T>,\n    priority = false\n  ): Promise<T> {\n    return new Promise((resolve, reject) => {\n      if (priority) {\n        this.computationQueue.unshift(() => fn().then(resolve, reject));\n      } else {\n        this.computationQueue.push(() => fn().then(resolve, reject));\n      }\n    });\n  }\n\n  async expressionResult(expression: AST.Expression): Promise<Result.Result> {\n    return this.enqueueComputation(async () => {\n      const type = await inferExpression(\n        this.computationRealm.inferContext,\n        expression\n      );\n\n      if (type.errorCause) {\n        return { value: null, type: serializeType(type) };\n      }\n\n      try {\n        const value = await evaluateStatement(\n          this.computationRealm.interpreterRealm,\n          expression\n        );\n\n        return {\n          value: value.getData(),\n          type: serializeType(type),\n        };\n      } catch (err) {\n        return {\n          value: null,\n          type: {\n            kind: 'type-error',\n            errorCause: {\n              errType: 'free-form',\n              message: (err as Error).message,\n            },\n          },\n        };\n      }\n    });\n  }\n\n  async expressionType(expression: AST.Expression): Promise<SerializedType> {\n    return this.enqueueComputation(async () => {\n      const type = await inferExpression(\n        this.computationRealm.inferContext,\n        expression\n      );\n      return serializeType(type);\n    });\n  }\n\n  /** Take stock of new program (came from editorToProgram) and update caching */\n  private ingestComputeRequest({\n    program,\n    externalData,\n  }: ComputeRequestWithExternalData) {\n    const newParse = updateChangedProgramBlocks(program, this.latestProgram);\n    const sortedParse = topologicalSort(newParse);\n    const newExternalData = anyMappingToMap(externalData ?? new Map());\n\n    this.computationRealm.evictCache({\n      oldBlocks: getGoodBlocks(this.latestProgram),\n      newBlocks: getGoodBlocks(sortedParse),\n      oldExternalData: this.latestExternalData,\n      newExternalData,\n    });\n\n    this.computationRealm.setExternalData(newExternalData);\n    this.latestExternalData = newExternalData;\n    this.latestProgram = sortedParse;\n\n    return sortedParse;\n  }\n\n  public async computeRequest(\n    req: ComputeRequestWithExternalData\n  ): Promise<NotebookResults | null> {\n    return this.enqueueComputation(async () => {\n      /* istanbul ignore catch */\n      try {\n        const [programWithPrettyNames, automaticallyGeneratedNames] =\n          makeNamesFromIds(req.program);\n        this.automaticallyGeneratedNames = automaticallyGeneratedNames;\n        this.computationRealm.inferContext.autoGeneratedVarNames =\n          automaticallyGeneratedNames;\n\n        const blocks = this.ingestComputeRequest({\n          ...req,\n          program: programWithPrettyNames,\n        });\n        const goodBlocks = getGoodBlocks(blocks);\n\n        const computeResults = await computeProgram(\n          goodBlocks,\n          this.computationRealm\n        );\n\n        const updates: (IdentifiedError | IdentifiedResult)[] = [];\n\n        for (const block of blocks) {\n          if (block.type === 'identified-error') {\n            updates.push(block);\n          }\n        }\n\n        updates.push(...computeResults);\n\n        return {\n          blockResults: Object.fromEntries(\n            updates.map((result) => [result.id, result])\n          ),\n          indexLabels: this.computationRealm.getIndexLabels(),\n        };\n      } catch (error) {\n        console.error(error);\n        this.reset();\n        captureException(error as Error);\n        return null;\n      }\n    }, true);\n  }\n\n  public pushExternalDataUpdate(key: string, value: Result.Result): void {\n    const newValue = new Map(this.externalData.getValue());\n    newValue.set(key, value);\n    this.externalData.next(newValue);\n  }\n\n  public pushExternalDataDelete(key: string): void {\n    const newValue = new Map(this.externalData.getValue());\n    newValue.delete(key);\n    this.externalData.next(newValue);\n  }\n\n  /**\n   * Reset computer's state -- called when it panicks\n   */\n  reset() {\n    this.latestProgram = [];\n    this.latestExternalData = new Map();\n    this.computationRealm = new ComputationRealm();\n    this.results = new BehaviorSubject<NotebookResults>(defaultComputerResults);\n    this.computationQueue = new Queue({\n      concurrency: 1,\n      autostart: true,\n    });\n    this.wireRequestsToResults();\n  }\n\n  getStatement(blockId: string): AST.Statement | undefined {\n    const block = this.latestProgram.find(\n      (block) => block.id === blockId\n    )?.block;\n\n    return block?.args[0];\n  }\n\n  /**\n   * Get a unique identifier that starts with `prefix` and is not already in use.\n   *\n   * If `attemptNumberless` is true, then the first proposal will be `prefix` and\n   * not `prefix1`.\n   */\n  getAvailableIdentifier(\n    prefix: string,\n    start: number,\n    attemptNumberless = false\n  ): string {\n    const existingVars = new Set([\n      ...this.computationRealm.inferContext.stack.globalVariables.keys(),\n      ...this.computationRealm.inferContext.externalData.keys(),\n      ...this.latestProgram.map((block) => block.definesVariable),\n    ]);\n    let num = start;\n    const firstProposal = prefix;\n    if (attemptNumberless && !existingVars.has(firstProposal)) {\n      return firstProposal;\n    }\n    const nextProposal = () => `${prefix}${num}`;\n    let proposal = nextProposal();\n    while (existingVars.has(proposal)) {\n      num += 1;\n      proposal = nextProposal();\n    }\n    return proposal;\n  }\n\n  /**\n   * Parses a unit from text.\n   * NOTE: Don't use with '%', percentages are NOT units. I will crash\n   */\n  async getUnitFromText(text: string): Promise<Unit[] | null> {\n    if (text.trim() === '%') {\n      throw new Error('% is not a unit!');\n    }\n\n    const ast = parseExpression(text).solution;\n    if (!ast) {\n      return null;\n    }\n    const expr = await this.enqueueComputation(() =>\n      inferExpression(this.computationRealm.inferContext, ast)\n    );\n    return expr.unit;\n  }\n\n  getLatestProgram(): Readonly<Program> {\n    return this.latestProgram;\n  }\n\n  /** @deprecated */\n  private updateImperativeParseError(\n    updater: (map: ParseErrorMap) => void\n  ): void {\n    const nextValue = produce(this.imperativeParseErrors.getValue(), updater);\n    this.imperativeParseErrors.next(nextValue);\n  }\n\n  /** @deprecated */\n  imperativelySetParseError(id: string, error: UserParseError): void {\n    this.updateImperativeParseError((map) => {\n      map.set(id, error);\n    });\n  }\n\n  /** @deprecated */\n  imperativelyUnsetParseError(id: string): void {\n    this.updateImperativeParseError((map) => {\n      map.delete(id);\n    });\n  }\n\n  /** @deprecated */\n  hasImperativelySetParseError(id: string): boolean {\n    return this.imperativeParseErrors.getValue().has(id);\n  }\n\n  /** @deprecated */\n  getImperativeParseError$ = listenerHelper(\n    this.imperativeParseErrors,\n    (errors, blockId: string) => errors.get(blockId)\n  );\n\n  // locale\n\n  setLocale(locale: string) {\n    this.locale = locale;\n  }\n\n  formatNumber(type: SerializedTypes.Number, value: DeciNumber): DeciNumberRep {\n    return formatNumber(\n      this.locale,\n      type.unit,\n      value,\n      type.numberFormat,\n      type.numberError === 'month-day-conversion'\n    );\n  }\n\n  formatUnit(unit: Unit[], value?: DeciNumber): string {\n    return formatUnit(this.locale, unit, value);\n  }\n\n  formatError(error: ErrSpec): string {\n    return formatError(this.locale, error);\n  }\n}\n","import { Observable, OperatorFunction } from 'rxjs';\n\n/**\n * rxjs operator that calls a slow function with its inputs,\n * and ignores further inputs while the function is working.\n *\n * Except for the latest input that was ignored, which gets\n * computed after the function is done.\n *\n * Essentially it works as a queue of 1\n */\nexport const dropWhileComputing =\n  <TIn, TOut>(fn: (inp: TIn) => Promise<TOut>): OperatorFunction<TIn, TOut> =>\n  (inputs: Observable<TIn>): Observable<TOut> => {\n    let latestDroppedCompute: TIn | undefined;\n    let computing = false;\n\n    return new Observable((outputSub) => {\n      const inputSub = inputs.subscribe({\n        next: function computeInput(inp) {\n          if (inputSub.closed) return;\n\n          if (!computing) {\n            computing = true;\n            const doneComputing = () => {\n              computing = false;\n\n              if (latestDroppedCompute != null) {\n                const newInp = latestDroppedCompute;\n                latestDroppedCompute = undefined;\n                computeInput(newInp);\n              }\n            };\n\n            fn(inp).then(\n              (fnResult) => {\n                if (inputSub.closed) return;\n\n                outputSub.next(fnResult);\n                doneComputing();\n              },\n              (err) => {\n                if (inputSub.closed) return;\n\n                outputSub.error(err);\n                doneComputing();\n              }\n            );\n          } else {\n            latestDroppedCompute = inp;\n          }\n        },\n        complete: () => outputSub.complete(),\n        error: (x) => outputSub.error(x),\n      });\n\n      return () => {\n        inputSub.unsubscribe();\n      };\n    });\n  };\n","import { dequal } from 'dequal';\nimport { astNode, parseBlock } from '@decipad/language';\nimport { Program, ProgramBlock } from '../types';\n\n/**\n * For each item, returns the same AST if the block didn't change.\n */\nexport const updateChangedProgramBlocks = (\n  program: Program,\n  previousBlocks: ProgramBlock[] = []\n): ProgramBlock[] => {\n  return program.map((block) => {\n    const prev = previousBlocks.find((prev) => prev.id === block.id);\n\n    if (prev && dequal(block, prev)) {\n      return prev;\n    } else {\n      return block;\n    }\n  });\n};\n\n/** Create a program for the computer when the source string has multiple statements\n * The computer doesn't normally support this but sometimes we need it\n */\nexport const createProgramFromMultipleStatements = (\n  source: string\n): Program => {\n  const { error, solution } = parseBlock(source);\n  return error\n    ? [\n        {\n          type: 'identified-error',\n          errorKind: 'parse-error',\n          id: '1',\n          source,\n          error,\n        },\n      ]\n    : solution.args.map((stat, index) => ({\n        type: 'identified-block',\n        id: String(index),\n        source: '',\n        block: { ...astNode('block', stat), id: String(index) },\n      }));\n};\n","import { tokenRules } from '@decipad/language';\n\nconst captureNumberAndExpression = new RegExp(\n  `^(${tokenRules.main.number.match.source})(.+)?$`\n);\n\nexport function parseNumberWithUnit(source: string): [number, string] | null {\n  const match = source.match(captureNumberAndExpression);\n  if (!match) {\n    return null;\n  }\n\n  const [, number, rest] = match;\n  const parsedNumber = Number(number);\n\n  if (Number.isNaN(parsedNumber)) {\n    return null;\n  }\n\n  return [parsedNumber, rest ?? ''];\n}\n","import { AST, SyntaxError, BracketError, walkAst } from '@decipad/language';\nimport { getDefined } from '@decipad/utils';\nimport { TableColumnAssign } from 'libs/language/src/parser/ast-types';\nimport { IdentifiedError, IdentifiedResult, ProgramBlock } from './types';\n\nexport const getStatement = (\n  program: AST.Block[],\n  blockId: string\n): AST.Statement => {\n  return getDefined(\n    program.find((b) => b.id === blockId)?.args[0],\n    `ComputationGraph: Could not find code line at ${blockId}`\n  );\n};\n\nexport const iterProgram = (\n  program: AST.Block[],\n  fn: (stmt: AST.Statement, loc: string) => void\n) => {\n  program.forEach(({ id: blockId, args: statements }) => {\n    fn(statements[0], blockId);\n  });\n};\n\nexport const getExistingBlockIds = (\n  blocks: AST.Block[],\n  blockIds: Set<string>\n): string[] =>\n  blocks.flatMap((block) => (blockIds.has(block.id) ? [block.id] : []));\n\nexport const getIdentifierString = (ident: AST.Identifier): string =>\n  ident.args[0];\n\nexport const getDefinedSymbol = (\n  stmt: AST.Statement,\n  findIncrementalDefinitions = true\n) => {\n  switch (stmt.type) {\n    case 'function-definition':\n    case 'assign':\n    case 'table':\n    case 'categories':\n      return getIdentifierString(stmt.args[0]);\n    case 'matrix-assign':\n      return findIncrementalDefinitions\n        ? getIdentifierString(stmt.args[0])\n        : null;\n    case 'table-column-assign':\n      return findIncrementalDefinitions\n        ? getIdentifierString(stmt.args[0])\n        : null;\n    default:\n      return null;\n  }\n};\n\nexport const getColumnNameFromTableColumnAssign = (\n  colAss: TableColumnAssign\n) => {\n  return getIdentifierString(colAss.args[1]);\n};\n\nexport const getGoodBlocks = (parsed: ProgramBlock[]) =>\n  parsed.flatMap((b) => {\n    if (b.type === 'identified-block') return [b.block];\n    else return [];\n  });\n\nexport const getAllSymbolsDefined = (blocks: AST.Block[]) =>\n  blocks.flatMap((block) =>\n    block.args.flatMap((statement) => {\n      const sym = getDefinedSymbol(statement);\n      if (sym != null) return [sym];\n      else return [];\n    })\n  );\n\nexport function* getSymbolsDefinedInBlocks(\n  program: AST.Block[],\n  blockIds: string[]\n) {\n  for (const loc of blockIds) {\n    const sym = getDefinedSymbol(getStatement(program, loc));\n    if (sym != null) yield sym;\n  }\n}\n\nconst getReferredSymbol = (node: AST.Node) => {\n  switch (node.type) {\n    case 'ref':\n    case 'funcref':\n    case 'externalref':\n      return getIdentifierString(node);\n    default:\n      return null;\n  }\n};\n\nexport const findSymbolsUsed = (stmt: AST.Statement) => {\n  const symbols: string[] = [];\n\n  walkAst(stmt, (node) => {\n    const sym = getReferredSymbol(node);\n    if (sym != null) symbols.push(sym);\n  });\n\n  if (stmt.type === 'matrix-assign' || stmt.type === 'table-column-assign') {\n    symbols.push(getDefined(getDefinedSymbol(stmt)));\n  }\n\n  return symbols;\n};\n\nexport const setIntersection = <T>(setA: Set<T>, setB: Set<T>) =>\n  new Set([...setA].filter((itemA) => setB.has(itemA)));\n\nexport const isSyntaxError = (error: unknown): error is SyntaxError =>\n  error instanceof Object &&\n  'message' in error &&\n  ('token' in error || 'isEmptyExpressionError' in error);\n\nexport const isBracketError = (error: unknown): error is BracketError => {\n  return (\n    error instanceof Object &&\n    'type' in error &&\n    ('close' in error || 'open' in error)\n  );\n};\n\nexport const isTypeError = (\n  error?: IdentifiedResult | IdentifiedError | null\n): error is IdentifiedResult & {\n  type: { kind: 'type-error' };\n} => {\n  return Boolean(\n    error &&\n      error.type === 'computer-result' &&\n      error.result.type.kind === 'type-error'\n  );\n};\n\nexport const hasBracketError = (\n  error: unknown\n): error is { bracketError: BracketError } => {\n  return (\n    error instanceof Object &&\n    'bracketError' in error &&\n    isBracketError((error as { bracketError: BracketError }).bracketError)\n  );\n};\n\nexport const identifiedErrorToMessage = (error: IdentifiedError): string => {\n  switch (error.errorKind) {\n    case 'parse-error': {\n      return error.error.message;\n    }\n    case 'dependency-cycle': {\n      return \"Number's value depends on itself\";\n    }\n  }\n};\n","import { getDefined } from '@decipad/utils';\n\ntype GetURLComponentsResult = {\n  docId: string;\n  blockId: string;\n};\n\nexport const getURLComponents = (source: string): GetURLComponentsResult => {\n  const url = new URL(source);\n  const docIdMatch = getDefined(\n    url.pathname.match(/^\\/n\\/(.*)/),\n    `Could not find notebook id from URL${url}`\n  );\n  const blockId = url.hash.slice(1);\n  let docId = decodeURIComponent(\n    getDefined(docIdMatch[1], `no doc id on URL ${url}`)\n  );\n  if (docId.indexOf(':') >= 0) {\n    docId = docId.slice(docId.indexOf(':') + 1);\n  }\n\n  return { docId, blockId };\n};\n","export function fetch(\n  _url: string | URL,\n  init?: RequestInit\n): ReturnType<typeof global.fetch> {\n  let url: URL;\n  if (typeof _url === 'string') {\n    const base =\n      'window' in global && 'location' in window\n        ? window.location.origin\n        : process.env.DECI_APP_URL_BASE || 'http://localhost:3000';\n    url = new URL(_url, base);\n  } else {\n    url = _url;\n  }\n  const { href } = url;\n  return global.fetch(href, init);\n}\n","/* eslint-disable no-param-reassign */\nimport DeciNumber, { N, ONE, TWO } from '@decipad/number';\nimport {\n  getUnitByName,\n  pluralizeUnit,\n  prettyForSymbol,\n  simplifyUnits,\n  singular,\n  Unit,\n  unitIsSymbol,\n} from '@decipad/language';\nimport produce from 'immer';\nimport type { DeciNumberPart } from './formatNumber';\n\nconst numberToSubOrSuperscript: Record<string, string[]> = {\n  '0': ['', ''], // subscript not used for now\n  '1': ['', ''],\n  '2': ['', ''],\n  '3': ['', ''],\n  '4': ['', ''],\n  '5': ['', ''],\n  '6': ['', ''],\n  '7': ['', ''],\n  '8': ['', ''],\n  '9': ['', ''],\n  '+': ['', ''], // minus\n  '-': ['', ''], // minus\n  '.': ['', ''], // dot\n  '/': ['/', ''], // slash\n};\n\nconst multipliersToPrefixes = {\n  1e-30: ['q', 'quecto'],\n  1e-27: ['r', 'ronto'],\n  1e-24: ['y', 'yocto'],\n  1e-21: ['z', 'zepto'],\n  1e-18: ['a', 'atto'],\n  1e-15: ['f', 'femto'],\n  1e-12: ['p', 'pico'],\n  1e-9: ['n', 'nano'],\n  0.000001: ['', 'micro'], // 1e-6\n  0.001: ['m', 'milli'], // 1e-3\n  0.01: ['c', 'centi'], // 1e-2\n  0.1: ['d', 'deci'], // 1e-1\n  1: ['', ''],\n  10: ['da', 'deca'], // 1e1\n  100: ['h', 'hecto'], // 1e2\n  1000: ['k', 'kilo'], // 1e3\n  1000000: ['M', 'mega'], // 1e6\n  1000000000: ['G', 'giga'], // 1e9\n  1000000000000: ['T', 'tera'], // 1e12\n  1000000000000000: ['P', 'peta'], // 1e15\n  1000000000000000000: ['E', 'exa'], // 1e18\n  1e21: ['Z', 'zetta'],\n  1e24: ['Y', 'yotta'],\n  1e27: ['R', 'ronna'],\n  1e30: ['Q', 'quetta'],\n} as const;\n\ntype AvailablePrefixes = keyof typeof multipliersToPrefixes;\n\nfunction scriptFromNumber(n: string): string {\n  return numberToSubOrSuperscript[n]?.[1] || n;\n}\n\nconst byExp = (u1: Unit, u2: Unit): number => Number(N(u2.exp).sub(u1.exp));\n\nconst produceExp = (unit: Unit, makePositive = false): Unit => {\n  return produce(unit, (u) => {\n    u.unit = singular(u.unit);\n    if (makePositive) {\n      u.exp = N(u.exp).abs();\n    }\n  });\n};\n\nconst isInteger = (f: DeciNumber): boolean => {\n  return f.d === 1n;\n};\n\nexport function prettyENumbers(\n  exponent: string,\n  show10 = false,\n  coefficient = '1'\n): string {\n  return `${+coefficient === 1 ? '' : coefficient}${\n    show10 ? ' 10' : ''\n  }${exponent.replace('+', '').replace(/./g, scriptFromNumber)}`.trim();\n}\nexport interface UnitPart {\n  type:\n    | 'unit'\n    | 'unit-literal'\n    | 'unit-exponent'\n    | 'unit-quality'\n    | 'unit-group'\n    | 'unit-prefix';\n  value: string;\n  originalValue?: string; // for values that are prettified\n  base?: string; // for unit conversions in the ui\n}\n\nconst stringifyUnit = (\n  unit: Unit,\n  prettify = true,\n  ignoreExp = false\n): UnitPart[] => {\n  const symbol = singular(unit.unit.toLowerCase());\n  const fullUnit = getUnitByName(symbol);\n  const pretty = prettyForSymbol[symbol];\n  const base =\n    fullUnit?.superBaseQuantity === 'currency'\n      ? 'currency'\n      : fullUnit?.baseQuantity || 'user-defined-unit';\n  const isSymbol = unitIsSymbol(symbol);\n  const multiPrefix = unit.multiplier ? N(unit.multiplier).valueOf() : 1;\n  const prefix = multipliersToPrefixes[multiPrefix as AvailablePrefixes];\n\n  const result: UnitPart[] = [];\n\n  if (prefix != null) {\n    if (isSymbol) {\n      result.push({\n        type: 'unit-prefix',\n        value: prefix[0],\n      });\n    } else {\n      result.push({\n        type: 'unit-prefix',\n        value: prefix[1],\n      });\n    }\n  } else {\n    let multiplierString = multiPrefix.toString();\n    if (!multiplierString.includes('e')) {\n      const asNumber = +multiplierString;\n      multiplierString = asNumber.toExponential().toString();\n    }\n    const [coefficient, exponent] = multiplierString.toString().split('e');\n    result.push({\n      type: 'unit-exponent',\n      originalValue: multiPrefix.toString(),\n      value: prettyENumbers(exponent, true, coefficient),\n    });\n    result.push({\n      type: 'unit-literal',\n      value: ' ',\n    });\n  }\n\n  if (prettify && pretty) {\n    result.push({\n      type: 'unit',\n      originalValue: unit.baseSuperQuantity === 'currency' ? pretty : unit.unit,\n      value: pretty,\n      base,\n    });\n  } else {\n    result.push({\n      type: 'unit',\n      value: unit.unit,\n      base,\n    });\n  }\n\n  const exp = N(unit.exp);\n\n  if (!exp.equals(ONE)) {\n    const strExp = isInteger(exp)\n      ? exp.toString()\n      : `${[Math.sign(Number(exp.s)) === -1 && '-', exp.n, '/', exp.d]\n          .filter(Boolean)\n          .join('')}`;\n\n    const prettyExp = prettyENumbers(strExp);\n\n    //\n    // when we say per kg, it means kg^-1\n    // however we already sorted this previously\n    // and dont want to show the exponent twice\n    //\n    if (!ignoreExp) {\n      if (prettify) {\n        result.push({\n          type: 'unit-exponent',\n          value: prettyExp,\n          originalValue: strExp,\n        });\n      } else {\n        result.push({\n          type: 'unit-exponent',\n          originalValue: strExp,\n          value: `^${strExp}`,\n        });\n      }\n    }\n  }\n\n  if (unit.quality) {\n    result.push({\n      type: 'unit-quality',\n      originalValue: unit.quality,\n      value: ` of ${unit.quality}`,\n    });\n  }\n\n  // 1 multipliers dont affect strings so we remove useless\n  // declarations\n  return result.filter((x) => x.value !== '');\n};\n\nexport const formatUnitArgs = (\n  units: Unit[] | null,\n  value?: DeciNumber,\n  prettify = true,\n  previousLength = 0\n) => {\n  const unitsLength = units?.length ?? 0 + previousLength;\n  return (units ?? []).reduce((parts: UnitPart[], unit: Unit) => {\n    if (parts.length > 0) {\n      let prefix: string;\n      //\n      // when you have two units you show\n      // meter per second\n      // but when you have more previousLength = 0\n      // you use international system like `m.s-1`\n      //\n      if (unitsLength === 2 && N(unit.exp).compare(N(-1)) === 0) {\n        if (prettify) {\n          if (unitIsSymbol(unit.unit)) {\n            parts.push({\n              type: 'unit-group',\n              value: '/',\n            });\n          } else {\n            parts.push({ type: 'unit-literal', value: ' ' });\n            parts.push({\n              type: 'unit-group',\n              value: 'per',\n            });\n            parts.push({ type: 'unit-literal', value: ' ' });\n          }\n        }\n        stringifyUnit(produceExp(unit, true), prettify).forEach((x) =>\n          parts.push(x)\n        );\n      } else {\n        prefix = prettify ? '' : '*';\n        parts.push({\n          type: 'unit-group',\n          value: prefix,\n        });\n        stringifyUnit(produceExp(unit), prettify).forEach((x) => parts.push(x));\n      }\n    } else if (unitsLength === 1 && N(unit.exp).compare(N(-1)) === 0) {\n      parts.push({ type: 'unit-literal', value: ' ' });\n      parts.push({\n        type: 'unit-group',\n        value: 'per',\n      });\n      parts.push({ type: 'unit-literal', value: ' ' });\n      stringifyUnit(pluralizeUnit(unit, 1), prettify, true).forEach((x) =>\n        parts.push(x)\n      );\n    } else {\n      stringifyUnit(\n        pluralizeUnit(\n          unit,\n          units && unitsLength > 2 ? 2 : value?.valueOf() || 2\n        ),\n        prettify\n      ).forEach((x) => parts.push(x));\n    }\n    return parts;\n  }, []);\n};\n\nfunction fixSpaces(partsOfUnit: UnitPart[]) {\n  return partsOfUnit\n    .reduce(\n      //\n      // we want to join strings with a space, but with expecting\n      // for multipliers, e.g. `km` not `k m`\n      //\n      (p, d, i, a) =>\n        p +\n        (i > 0 &&\n        (a[i - 1].type === 'unit-prefix' || // `km` not `k m`\n          d.type === 'unit-exponent' || // 2^420 not 2 ^420\n          d.type === 'unit-literal' ||\n          (a[i + 1] && a[i + 1].type === 'unit-literal') ||\n          a[i - 1].type === 'unit-literal') // `1 meter per second` not `1 meter  per  second`\n          ? ''\n          : ' ') +\n        d.value,\n      ''\n    )\n    .trim();\n}\n\nexport function formatUnitAsParts(\n  _locale: string,\n  units: Unit[],\n  value: DeciNumber = TWO,\n  prettify = true,\n  previousLength = 0\n): DeciNumberPart {\n  const simplified = simplifyUnits(units) || units;\n  const sortedUnits = [...simplified].sort(byExp);\n  const unitParts = formatUnitArgs(\n    sortedUnits,\n    value,\n    prettify,\n    previousLength\n  );\n  return {\n    type: 'unit',\n    value: fixSpaces(unitParts),\n    partsOf: unitParts as UnitPart[],\n  };\n}\n\nexport function formatUnit(\n  locale: string,\n  units: Unit[],\n  value: DeciNumber = TWO,\n  prettify = true,\n  previousLength = 0\n): string {\n  const parts = formatUnitAsParts(\n    locale,\n    units,\n    value,\n    prettify,\n    previousLength\n  );\n  if (parts.partsOf) {\n    return parts.partsOf.map((x) => x.value).join('');\n  }\n  throw new Error('This should not happen its a typescript imposition');\n}\n\nfunction isUserDefinedUnit(unit: Unit | null): boolean {\n  if (!unit) {\n    return false;\n  }\n  const fullUnit = getUnitByName(unit.unit);\n  return (\n    unit != null &&\n    !fullUnit?.baseQuantity &&\n    N(unit.exp).equals(ONE) &&\n    N(unit.multiplier).equals(ONE)\n  );\n}\n\nexport function isUserDefined(unit: Unit[] | null): boolean {\n  if (unit?.length === 1) {\n    return isUserDefinedUnit(unit[0]);\n  }\n  return false;\n}\n\nfunction simpleFormatUnitPart(unit: Unit): string {\n  const multiplier = N(unit.multiplier).valueOf();\n  const multiplierStr =\n    multipliersToPrefixes[\n      multiplier as keyof typeof multipliersToPrefixes\n    ]?.[0] ?? `${multiplier} * `;\n  const exp = N(unit.exp).valueOf();\n  const expStr = exp === 1 ? '' : `^${exp}`;\n  const value = `${multiplierStr}${unit.unit}${expStr}`;\n  return value;\n}\n\nexport function simpleFormatUnit(units: Unit[]): string {\n  return units.reduce(\n    (str, u) =>\n      str ? `${str} * ${simpleFormatUnitPart(u)}` : simpleFormatUnitPart(u),\n    ''\n  );\n}\n","import { SerializedType } from '@decipad/language';\nimport { formatUnit } from './formatUnit';\n\nexport const formatTypeToBasicString = (\n  locale: string,\n  type: SerializedType\n): string => {\n  switch (type.kind) {\n    case 'type-error':\n      throw new Error('toBasicString: errors not supported');\n    case 'number':\n      return type.unit ? formatUnit(locale, type.unit) : 'number';\n    case 'date':\n      return `date(${type.date})`;\n    default:\n      return type.kind;\n  }\n};\n","import { ErrSpec, serializeType } from '@decipad/language';\nimport { formatTypeToBasicString } from './formatTypeBasic';\nimport { formatUnit } from './formatUnit';\n\n// istanbul ignore next\nexport const formatError = (locale: string, spec: ErrSpec): string => {\n  switch (spec.errType) {\n    case 'free-form': {\n      return spec.message;\n    }\n    case 'missing-variable': {\n      const [name] = spec.missingVariable;\n      return `The variable ${name} is missing`;\n    }\n    case 'missing-formula': {\n      return `The formula ${spec.formulaName}() does not exist`;\n    }\n    case 'expected-but-got': {\n      const [expected, got] = spec.expectedButGot.map((t) =>\n        typeof t === 'string'\n          ? t\n          : formatTypeToBasicString(locale, serializeType(t))\n      );\n\n      return `This operation requires a ${expected} and a ${got} was entered`;\n    }\n    case 'expected-primitive': {\n      const got = formatTypeToBasicString(locale, serializeType(spec.butGot));\n\n      return `This operation requires a primitive value (string, number, boolean or date) and a ${got} was entered`;\n    }\n    case 'expected-unit': {\n      return 'This operation requires compatible units';\n    }\n    case 'expected-arg-count': {\n      const [fname, expected, got] = spec.expectedArgCount;\n\n      return `The function ${fname} requires ${expected} parameters and ${got} parameters were entered`;\n    }\n    case 'unexpected-empty-column': {\n      return `Unexpected empty column`;\n    }\n    case 'forbidden-inside-function': {\n      const opType = { table: 'Table', category: 'Category' }[\n        spec.forbiddenThing\n      ];\n      return `${opType} operations are forbidden inside functions`;\n    }\n    case 'mismatched-specificity': {\n      const { expectedSpecificity, gotSpecificity } = spec;\n      return `Expected time specific up to the ${expectedSpecificity}, but got ${gotSpecificity}`;\n    }\n    case 'column-contains-inconsistent-type': {\n      const { cellType, got } = spec;\n      return `Column cannot contain both ${formatTypeToBasicString(\n        locale,\n        serializeType(cellType)\n      )} and ${formatTypeToBasicString(locale, serializeType(got))}`;\n    }\n    case 'bad-overloaded-builtin-call': {\n      const gotArgTypes = spec.gotArgTypes\n        .map((argType) =>\n          formatTypeToBasicString(locale, serializeType(argType))\n        )\n        .join(', ');\n      return `The function ${spec.functionName} cannot be called with (${gotArgTypes})`;\n    }\n    case 'cannot-convert-between-units': {\n      return `Don't know how to convert between units ${formatUnit(\n        locale,\n        spec.fromUnit\n      )} and ${formatUnit(locale, spec.toUnit)}`;\n    }\n    case 'formula-cannot-call-itself': {\n      return `${spec.fname}() cannot be used in its own definition`;\n    }\n    case 'cannot-convert-to-unit': {\n      return `Cannot convert to unit ${formatUnit(locale, spec.toUnit)}`;\n    }\n    case 'unknown-category': {\n      return `Unknown category ${spec.dimensionId}`;\n    }\n    case 'duplicated-table-column': {\n      return `The column ${spec.columnName} already exists in this table`;\n    }\n    case 'expected-table-and-associated-column': {\n      return `Expected table and associated column`;\n    }\n    case 'duplicated-name': {\n      return `This name is already being used. You cannot have duplicated names`;\n    }\n    case 'complex-expression-exponent': {\n      return `Complex expressions not supported in exponents`;\n    }\n    case 'sequence-step-zero': {\n      return `Sequence step must not be zero`;\n    }\n    case 'invalid-sequence-step': {\n      const dir = spec.start < spec.end ? 'ascending' : 'descending';\n      const stepSignal = Math.sign(spec.by) > 0 ? 'positive' : 'negative';\n      return `Invalid step in sequence: sequence is ${dir} but step is ${stepSignal}`;\n    }\n    case 'no-previous-statement': {\n      return 'No previous statement';\n    }\n    case 'need-one-only-one-unit': {\n      return 'Need one and only one unit';\n    }\n    case 'unknown-reference': {\n      return 'Unknown reference';\n    }\n    case 'retired-feature': {\n      return \"You're using a feature that's been retired\";\n    }\n  }\n};\n","import DeciNumber, { N, ZERO } from '@decipad/number';\nimport type { DeciNumberPart } from './formatNumber';\n\nexport const large = N(1_000_000_000_000_000_000_000n);\nexport const small = N(1n, 1_000_000_000_000_000_000_000n);\n\nexport const isEdgeCaseNumber = (\n  f: DeciNumber\n): 'small' | 'large' | undefined => {\n  const abs = f.abs();\n\n  if (abs.compare(large) >= 0) {\n    return 'large';\n  }\n  if (!abs.equals(ZERO) && abs.compare(small) <= 0) {\n    return 'small';\n  }\n  return undefined;\n};\n\nexport const formatEdgeCaseNumber = (\n  f: DeciNumber,\n  places: number\n): DeciNumberPart[] => {\n  const result = f.toString(places);\n\n  const repeating = result.match(/^(\\d+)\\.(\\d*\\(\\d+\\))$/);\n  if (repeating) {\n    const [, integer, fraction] = repeating;\n    return [\n      { type: 'integer', value: integer },\n      { type: 'decimal', value: '.' },\n      {\n        type: 'fraction',\n        value: fraction.replace(/[()]/g, '').repeat(4).slice(0, places),\n      },\n      { type: 'ellipsis', value: '...' },\n    ];\n  }\n\n  const simpleDecimal = result.match(/^(\\d+)\\.(\\d+)$/);\n  if (simpleDecimal) {\n    const [, integer, fraction] = simpleDecimal;\n    return [\n      { type: 'integer', value: integer },\n      { type: 'decimal', value: '.' },\n      { type: 'fraction', value: fraction },\n    ];\n  }\n\n  return [{ type: 'integer', value: result }];\n};\n","/* eslint-disable no-param-reassign */\n// MIT License\n//\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nimport pluralize from 'pluralize';\nimport type { DeciNumberPart } from './formatNumber';\n\n//\nexport interface Options {\n  secondsDecimalDigits?: number;\n  timeDecimalDigits?: number;\n  keepDecimalsOnWholeTime?: boolean;\n  verbose?: boolean;\n  separateTime?: boolean;\n  formatSubTime?: boolean;\n  colonNotation?: boolean;\n}\n\nexport function parseMilliseconds(milliseconds: number) {\n  return {\n    days: Math.trunc(milliseconds / 86_400_000),\n    hours: Math.trunc(milliseconds / 3_600_000) % 24,\n    minutes: Math.trunc(milliseconds / 60_000) % 60,\n    seconds: Math.trunc(milliseconds / 1_000) % 60,\n    milliseconds: Math.trunc(milliseconds) % 1_000,\n    microseconds: Math.trunc(milliseconds * 1_000) % 1_000,\n    nanoseconds: Math.trunc(milliseconds * 1e6) % 1_000,\n  };\n}\n\nexport function parseMonths(months: number) {\n  return {\n    millennium: Math.trunc(months / 12_000),\n    century: Math.trunc(months / 1_200) % 10,\n    decade: Math.trunc(months / 120) % 10,\n    year: Math.trunc(months / 12) % 10,\n  };\n}\n\nconst SECOND_ROUNDING_EPSILON = 0.000_000_1;\n\nexport default function prettyTime(\n  time: number,\n  options: Options\n): DeciNumberPart[] {\n  if (options.colonNotation) {\n    options.formatSubTime = false;\n    options.separateTime = false;\n    options.verbose = false;\n  }\n\n  const result: DeciNumberPart[] = [];\n\n  const floorDecimals = (value: number, decimalDigits: number) => {\n    const flooredInterimValue = Math.floor(\n      value * 10 ** decimalDigits + SECOND_ROUNDING_EPSILON\n    );\n    const flooredValue = Math.round(flooredInterimValue) / 10 ** decimalDigits;\n    return flooredValue.toFixed(decimalDigits);\n  };\n\n  const add = (\n    value: number,\n    long: string,\n    short: string,\n    valueString: string = value.toString()\n  ) => {\n    if (\n      (result.length === 0 || !options.colonNotation) &&\n      value === 0 &&\n      !(options.colonNotation && short === 'm')\n    ) {\n      return;\n    }\n\n    let prefix;\n    let suffix;\n    if (options.colonNotation) {\n      prefix = result.length > 0 ? ':' : '';\n      suffix = '';\n      const wholeDigits = valueString.includes('.')\n        ? valueString.split('.')[0].length\n        : valueString.length;\n      const minLength = result.length > 0 ? 2 : 1;\n      valueString =\n        '0'.repeat(Math.max(0, minLength - wholeDigits)) + valueString;\n      if (prefix.trim() !== '') {\n        result.push({\n          type: 'unit',\n          value: prefix.trim(),\n          originalValue: suffix || long,\n        });\n      }\n    } else {\n      prefix = '';\n      suffix = options.verbose ? pluralize(long, value) : short;\n    }\n\n    result.push({ type: 'integer', value: valueString });\n\n    if (!options.colonNotation) {\n      result.push({\n        type: 'unit',\n        value: suffix || long,\n      });\n      result.push({ type: 'literal', value: ' ' });\n    }\n  };\n\n  const parsed = parseMilliseconds(time);\n\n  add(Math.trunc(parsed.days / 365), 'year', 'y');\n  add(parsed.days % 365, 'day', 'd');\n  add(parsed.hours, 'hour', 'h');\n  add(parsed.minutes, 'minute', 'm');\n\n  if (\n    options.separateTime ||\n    options.formatSubTime ||\n    (!options.colonNotation && time < 1000)\n  ) {\n    add(parsed.seconds, 'second', 's');\n    if (options.formatSubTime) {\n      add(parsed.milliseconds, 'millisecond', 'ms');\n      add(parsed.microseconds, 'microsecond', 's');\n      add(parsed.nanoseconds, 'nanosecond', 'ns');\n    } else {\n      const millisecondsAndBelow =\n        parsed.milliseconds +\n        parsed.microseconds / 1000 +\n        parsed.nanoseconds / 1e6;\n\n      const millisecondsDecimalDigits =\n        typeof options.timeDecimalDigits === 'number'\n          ? options.timeDecimalDigits\n          : 0;\n\n      const roundedMiliseconds =\n        millisecondsAndBelow >= 1\n          ? Math.round(millisecondsAndBelow)\n          : Math.ceil(millisecondsAndBelow);\n\n      const millisecondsString = millisecondsDecimalDigits\n        ? millisecondsAndBelow.toFixed(millisecondsDecimalDigits)\n        : roundedMiliseconds;\n\n      add(\n        Number.parseFloat(millisecondsString.toString()),\n        'millisecond',\n        'ms',\n        millisecondsString.toString()\n      );\n    }\n  } else {\n    const seconds = (time / 1000) % 60;\n    const secondsDecimalDigits =\n      typeof options.secondsDecimalDigits === 'number'\n        ? options.secondsDecimalDigits\n        : 1;\n    const secondsFixed = floorDecimals(seconds, secondsDecimalDigits);\n    const secondsString = options.keepDecimalsOnWholeTime\n      ? secondsFixed\n      : secondsFixed.replace(/\\.0+$/, '');\n    add(Number.parseFloat(secondsString), 'second', 's', secondsString);\n  }\n\n  return result;\n}\n\nexport function prettifyTimeMs(\n  time: number,\n  options: Options = {}\n): DeciNumberPart[] {\n  const partsOf = prettyTime(time, options);\n  return partsOf.filter((v, i) => {\n    if (i === partsOf.length - 1) {\n      return v.value !== ' ';\n    }\n    return true;\n  });\n}\n","import DeciNumber, { ONE, N } from '@decipad/number';\nimport {\n  areUnitsConvertible,\n  convertBetweenUnits,\n  normalizeUnitName,\n  parseUnit,\n  Unit,\n} from '@decipad/language';\nimport pluralize from 'pluralize';\nimport type { IntermediateDeciNumber } from './formatNumber';\nimport { Options, prettifyTimeMs as getPrettyPartsOfTime } from './parseMs';\n\nconst ms = [parseUnit('millisecond')] as Unit[];\n\nexport function fromTimeUnitToTimeBase(\n  unit: Unit[],\n  n: DeciNumber\n): [DeciNumber, boolean] {\n  const unitLargerThanDay =\n    unit[0].baseQuantity === 'month' ||\n    normalizeUnitName(unit[0].unit) === 'week';\n  if (unitLargerThanDay) {\n    return [n, false];\n  }\n  if (areUnitsConvertible(unit, ms)) {\n    return [convertBetweenUnits(n, unit, ms), true];\n  }\n  throw new Error('Invalid conversion to non time unit');\n}\n\nexport function formatTime(\n  locale: string,\n  units: Unit[],\n  n: DeciNumber,\n  args: Partial<Options>,\n  formatAnyUnit: (\n    loc: string,\n    un: Unit[],\n    nu: DeciNumber\n  ) => IntermediateDeciNumber\n): IntermediateDeciNumber {\n  const [inMsTF, simplify] = fromTimeUnitToTimeBase(units, n);\n  const value = inMsTF.valueOf();\n\n  const unitStr = pluralize(units[0].unit, n.valueOf());\n  const asStringPrecise = `${n.valueOf()} ${unitStr}`;\n\n  if (!simplify || value === 0) {\n    return {\n      ...formatAnyUnit(locale, units, n),\n      asStringPrecise,\n    };\n  }\n  return {\n    asStringPrecise,\n    isPrecise: true,\n    partsOf: getPrettyPartsOfTime(\n      value,\n      value < 1 ? { ...args, formatSubTime: true, verbose: false } : args\n    ),\n    value: inMsTF.div(N(1000)).valueOf(),\n  };\n}\n\nexport function isTimeUnit(units: Unit[]): boolean {\n  const unit = units[0];\n  return (\n    units?.length === 1 &&\n    unit != null &&\n    (unit.baseQuantity === 'second' || unit.baseQuantity === 'month') &&\n    N(unit.exp).equals(ONE)\n  );\n}\n","import { ONE, N } from '@decipad/number';\nimport { CurrencyUnits, getUnitByName, Unit } from '@decipad/language';\nimport { getDefined } from '@decipad/utils';\n\nfunction isCurrencyUnit(unit: Unit | null): boolean {\n  return (\n    unit != null &&\n    unit.baseSuperQuantity === 'currency' &&\n    N(unit.exp).equals(ONE)\n  );\n}\n\nexport function hasCurrency(unit: Unit[] | null): number {\n  if (!unit) {\n    return -1;\n  }\n  return unit.findIndex((arg) => isCurrencyUnit(arg));\n}\n\nexport function getCurrency(unit: Unit[]): Unit {\n  const currencyIndex = unit.findIndex(isCurrencyUnit);\n  const currencyUnit = getDefined(\n    (currencyIndex >= 0 && unit[currencyIndex]) || undefined\n  );\n  const currencyFromIdx = getUnitByName(currencyUnit.unit);\n\n  return {\n    ...currencyUnit,\n    // avoid names like `$`, always use a standard currency identifier\n    ...(currencyFromIdx ? { baseQuantity: currencyFromIdx.baseQuantity } : {}),\n  };\n}\n\nexport function getPrettyCurrency(unit: string): string {\n  const unitDef = CurrencyUnits.units.filter((x) => x.baseQuantity === unit);\n  if (unitDef[0] && unitDef[0].pretty) {\n    return unitDef[0].pretty;\n  }\n  return unit;\n}\n","import DeciNumber, { N, ONE, ZERO } from '@decipad/number';\nimport {\n  AST,\n  convertToMultiplierUnit,\n  DEFAULT_PRECISION,\n  MAX_PRECISION,\n  normalizeUnits,\n  safeNumberForPrecision,\n  Unit,\n} from '@decipad/language';\nimport produce from 'immer';\nimport pluralize from 'pluralize';\nimport {\n  formatEdgeCaseNumber,\n  isEdgeCaseNumber,\n} from './formatEdgeCaseNumbers';\nimport { formatTime, isTimeUnit } from './formatTime';\nimport {\n  formatUnitAsParts,\n  isUserDefined,\n  prettyENumbers,\n  UnitPart,\n} from './formatUnit';\nimport { getCurrency, getPrettyCurrency, hasCurrency } from './getCurrency';\n\nconst DEFAULT_NUMBER_OPTIONS: Intl.NumberFormatOptions = {\n  maximumFractionDigits: 2,\n  minimumFractionDigits: 0,\n  notation: 'compact',\n  compactDisplay: 'long', // 18 thousand instead of 18K\n};\nconst DEFAULT_CURRENCY_OPTIONS: Intl.NumberFormatOptions = {\n  maximumFractionDigits: 2,\n  minimumFractionDigits: 0,\n  compactDisplay: 'long', // 18 thousand instead of 18K\n  style: 'currency',\n  currencyDisplay: 'narrowSymbol',\n};\nconst LONG_NUMBER_OPTIONS: Intl.NumberFormatOptions = {\n  maximumFractionDigits: 20,\n  minimumFractionDigits: 0,\n  notation: 'scientific',\n};\nconst OTHER_LONG_NUMBER_OPTIONS: Intl.NumberFormatOptions = {\n  maximumFractionDigits: 20,\n  minimumFractionDigits: 0,\n  notation: 'standard',\n};\n\nexport type DeciNumberPart = (\n  | Intl.NumberFormatPart\n  | { type: 'ellipsis'; value: string }\n  | { type: 'roughly'; value: string }\n) & {\n  originalValue?: string;\n  partsOf?: UnitPart[];\n};\n\nexport type DeciNumberRep = {\n  isPrecise: boolean;\n  value: number;\n  asString: string;\n  asStringPrecise: string;\n  partsOf: DeciNumberPart[];\n};\n\nexport type IntermediateDeciNumber = Omit<DeciNumberRep, 'asString'>;\n\nfunction beautifyExponents(partsOf: DeciNumberPart[]): DeciNumberPart[] {\n  const unclean = partsOf.reduce((acc, e) => {\n    return acc || (e.type === 'exponentInteger' && e.value === '0');\n  }, false);\n\n  const ret = partsOf\n    .filter((e) => {\n      if (!unclean) return true;\n      return !(e.type === 'exponentInteger' || e.type === 'exponentSeparator');\n    })\n    .map((e): DeciNumberPart => {\n      switch (e.type) {\n        case 'exponentSeparator': {\n          return {\n            type: 'exponentSeparator',\n            originalValue: e.value,\n            value: '10',\n          };\n        }\n        case 'exponentInteger':\n        case 'exponentMinusSign': {\n          return {\n            type: e.type,\n            originalValue: e.value,\n            value: prettyENumbers(e.value),\n          };\n        }\n        default: {\n          return e;\n        }\n      }\n    });\n\n  return ret;\n}\n\nexport function partsToString(partsOf: DeciNumberPart[]): string {\n  return partsOf\n    .reduce(\n      //\n      // we want to join strings with a space, but with exception\n      // for multipliers, e.g. `km` not `k m`\n      //\n      (p, d) =>\n        (p + (d.type === 'unit' ? ' ' : '')).replace(/  +/g, ' ') + d.value,\n      ''\n    )\n    .trim();\n}\n\nconst N_LARGE_NUMBER_MIN = N(1_000_000_000_000_000n);\n\nfunction isLargeNumber(x: DeciNumber): boolean {\n  return x.compare(N_LARGE_NUMBER_MIN) > 0;\n}\n\nconst N_10K = N(10_000);\n\nfunction isLessThan10k(x: DeciNumber): boolean {\n  const r = x.compare(N_10K) < 0;\n  return r;\n}\n\nexport const getIsPrecise = (\n  n: DeciNumber,\n  places = 2,\n  largeNumbersGetAbbreviated = true\n): boolean => {\n  // eslint-disable-next-line no-param-reassign\n  n = n.abs();\n\n  // Is this fraction equal to itself rounded?\n  if (!n.equals(n.round(places))) {\n    return false;\n  }\n\n  if (!largeNumbersGetAbbreviated) {\n    return true;\n  }\n\n  // else, 1 100 001 will be displayed as 1.1M, the 1-off is imprecision. Let's go\n\n  const [integerStr, fractionStr] = n.toString().split('.');\n\n  if (integerStr.length <= 3) {\n    return true;\n  }\n\n  if (fractionStr) {\n    // The number is larger than 999 so it's at least going to use K.\n    // When K is used the fractional part disappears.\n    return false;\n  }\n\n  // 678_000 is not rounded but 67_800 is :'(\n  if (/^\\d\\d\\d0*$/.test(integerStr)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst formatToParts = (\n  locale: string,\n  args: Intl.NumberFormatOptions,\n  n: DeciNumber,\n  mapParts: (num: DeciNumberPart[]) => DeciNumberPart[]\n): IntermediateDeciNumber => {\n  const [value, useSafeN] = safeNumberForPrecision(n);\n\n  const places = args.maximumFractionDigits ?? DEFAULT_PRECISION;\n  // todo: review, is this enough? @pgte\n\n  let partsOf: DeciNumberPart[];\n  let isPrecise: boolean;\n\n  if (isEdgeCaseNumber(n)) {\n    // Number is too large or too small for floats\n    const placeholder = 99;\n    partsOf = new Intl.NumberFormat(locale, args)\n      .formatToParts(placeholder)\n      .flatMap((part): DeciNumberPart[] => {\n        if (part.type === 'integer' && part.value === String(placeholder)) {\n          return formatEdgeCaseNumber(n, places);\n        }\n        return [part];\n      });\n    isPrecise = getIsPrecise(n, places, false);\n  } else {\n    partsOf = new Intl.NumberFormat(locale, args).formatToParts(useSafeN);\n    isPrecise = getIsPrecise(n, places, args.notation !== 'standard');\n  }\n\n  if (!isPrecise) {\n    partsOf = [{ type: 'roughly', value: '' }, ...partsOf];\n  }\n\n  let asStringPrecise;\n  if (Math.abs(useSafeN) > Number.MAX_SAFE_INTEGER) {\n    asStringPrecise = partsToString(formatEdgeCaseNumber(n, MAX_PRECISION));\n  } else {\n    const fmt = new Intl.NumberFormat(\n      locale,\n      Math.abs(useSafeN) > 1e10 || Math.abs(useSafeN) < 1 / 1e10\n        ? LONG_NUMBER_OPTIONS\n        : OTHER_LONG_NUMBER_OPTIONS\n    );\n    asStringPrecise = partsToString(\n      beautifyExponents(fmt.formatToParts(useSafeN))\n    );\n  }\n\n  return { isPrecise, partsOf: mapParts(partsOf), value, asStringPrecise };\n};\n\nfunction formatCurrency(locale: string, unit: Unit[], fraction: DeciNumber) {\n  const currency = getCurrency(unit);\n\n  const numberFormatOptions: Intl.NumberFormatOptions = {\n    ...DEFAULT_CURRENCY_OPTIONS,\n    currency: (currency.baseQuantity || currency.unit).toLocaleUpperCase(),\n    notation: isLargeNumber(fraction)\n      ? 'engineering'\n      : isLessThan10k(fraction)\n      ? 'standard'\n      : 'compact',\n  };\n\n  return formatToParts(locale, numberFormatOptions, fraction, (parts) =>\n    parts.map((u) => {\n      if (u.type === 'currency') {\n        return { type: 'currency', value: getPrettyCurrency(u.value) };\n      }\n      return u;\n    })\n  );\n}\n\nconst N_10 = N(10);\nconst N_ONE_CENT = N(1, 100);\n\nfunction formatUnitless(\n  locale: string,\n  fraction: DeciNumber\n): IntermediateDeciNumber {\n  const isNotMultipleOf10 = !fraction.mod(N_10).equals(ZERO);\n  const enginneringNotation =\n    isLargeNumber(fraction) ||\n    (isNotMultipleOf10 && fraction.compare(N_ONE_CENT) < 0);\n  const formattingOptions: Intl.NumberFormatOptions = {\n    ...DEFAULT_NUMBER_OPTIONS,\n    ...(enginneringNotation\n      ? { notation: 'engineering' }\n      : isLessThan10k(fraction)\n      ? { notation: 'standard' }\n      : {}),\n  };\n\n  return formatToParts(locale, formattingOptions, fraction, (x) => x);\n}\n\nfunction formatUserDefinedUnit(\n  locale: string,\n  unit: Unit[],\n  fraction: DeciNumber\n) {\n  const args: Intl.NumberFormatOptions = { ...DEFAULT_NUMBER_OPTIONS };\n\n  if (isLargeNumber(fraction)) {\n    args.notation = 'engineering';\n  }\n  if (isLessThan10k(fraction)) {\n    args.notation = 'standard';\n  }\n  args.style = 'unit';\n  // NumberFormat doesnt accept crazy units\n  // so we need to provide one that it does, and then pluralize it\n  args.unit = 'meter';\n\n  return formatToParts(locale, args, fraction, (parts) =>\n    parts.map((u) => {\n      const [, valOf] = safeNumberForPrecision(fraction);\n      if (u.type === 'unit') {\n        return {\n          type: 'unit',\n          value: pluralize(unit[0].unit, valOf),\n        };\n      }\n      return u;\n    })\n  );\n}\n\nexport function formatAnyUnit(\n  locale: string,\n  units: Unit[],\n  fraction: DeciNumber\n) {\n  const args = { ...DEFAULT_NUMBER_OPTIONS };\n\n  // dont show smart `thousand` instead of K if things are too big\n  if (units && units.length > 1) {\n    args.compactDisplay = 'short';\n  }\n\n  if (isLargeNumber(fraction)) {\n    args.notation = 'engineering';\n  }\n\n  if (isLessThan10k(fraction)) {\n    args.notation = 'standard';\n  }\n\n  return formatToParts(locale, args, fraction, (parts) => {\n    return [...parts, formatUnitAsParts(locale, units, fraction)];\n  });\n}\n\nfunction formatAnyCurrency(\n  locale: string,\n  units: Unit[],\n  fraction: DeciNumber\n) {\n  const currencyIndex = hasCurrency(units);\n  const currencyUnit: Unit[] = [units[currencyIndex]];\n\n  const unitsWithoutCurrency = [...units];\n  unitsWithoutCurrency.splice(currencyIndex, 1);\n\n  const otherUnitsMult = unitsWithoutCurrency.reduce(\n    (ac, current) => ac.mul(current.multiplier),\n    ONE\n  );\n\n  const partsOfUnits =\n    unitsWithoutCurrency.length > 0\n      ? formatAnyUnit(locale, unitsWithoutCurrency, ONE).partsOf.filter(\n          (e, i) => !(i === 0 && e.value === '1')\n        )\n      : [];\n\n  const partsOfCurrency = formatCurrency(\n    locale,\n    produce(currencyUnit, (cu) => {\n      // eslint-disable-next-line no-param-reassign\n      cu[0].multiplier = ONE;\n    }),\n    fraction.mul(otherUnitsMult)\n  );\n\n  return {\n    ...partsOfCurrency,\n    partsOf: partsOfCurrency.partsOf.concat(partsOfUnits),\n  };\n}\n\n//\n// dear reader, my dear reader\n//\n// if you take something from my book, let it be this:\n// 1000 meters with multiplier of 1000 means, 1000 meters, displayed as km\n//\n// it does not, i repeat\n// it does absolu-banana-lutely does not mean 1000 km.\n// you will loose countless hours of coding if you dont believe me\n// and you will literally\n// go\n// ...\n// bananas....\n//\nexport function formatNumber(\n  locale: string,\n  unit: Unit[] | null | undefined,\n  number: DeciNumber,\n  numberFormat: AST.NumberFormat | null = undefined,\n  imprecise = false\n): DeciNumberRep {\n  const fraction = N(number);\n\n  if (numberFormat === 'percentage') {\n    const mulFraction = fraction.mul(N(100));\n    const formatted = formatNumber(locale, null, mulFraction);\n    const partsOf: DeciNumberPart[] = [\n      ...formatted.partsOf,\n      { type: 'literal', value: '%' },\n    ];\n    return {\n      ...formatted,\n      partsOf,\n      asString: partsToString(partsOf),\n    };\n  }\n\n  let deciNumber: IntermediateDeciNumber;\n  if (unit) {\n    const units = normalizeUnits(unit) as Unit[];\n\n    if (hasCurrency(units) !== -1) {\n      deciNumber = formatAnyCurrency(locale, units, fraction);\n    } else if (isUserDefined(units)) {\n      deciNumber = formatUserDefinedUnit(locale, units, fraction);\n    } else if (isTimeUnit(units)) {\n      deciNumber = formatTime(\n        locale,\n        units,\n        fraction,\n        { verbose: true },\n        formatAnyUnit\n      );\n    } else {\n      const scaledToUnit = convertToMultiplierUnit(fraction, units);\n      deciNumber = formatAnyUnit(locale, units, scaledToUnit);\n    }\n  } else {\n    deciNumber = formatUnitless(locale, fraction);\n  }\n\n  let { partsOf } = deciNumber;\n  partsOf = beautifyExponents(partsOf);\n\n  if (imprecise && partsOf[0]?.type !== 'roughly') {\n    partsOf = [{ type: 'roughly', value: '' }, ...partsOf];\n  }\n\n  return { ...deciNumber, asString: partsToString(partsOf), partsOf };\n}\n","export const Unknown = Symbol('unknown');\n","import type { InferError } from '..';\n\nexport class RuntimeError extends Error {\n  public inferError: InferError | undefined;\n\n  constructor(message: string | InferError) {\n    if (typeof message === 'string') {\n      super(message);\n    } else {\n      super('Type error');\n      this.inferError = message;\n    }\n  }\n}\n","import { DeepReadonly } from 'utility-types';\nimport { Interpreter } from '..';\nimport { Dimension } from '../lazy';\nimport type {\n  UnknownValue,\n  NumberValue,\n  StringValue,\n  BooleanValue,\n  DateValue,\n  Range,\n  Table,\n  Row,\n} from './index';\n\nexport interface Value {\n  getData(): Interpreter.OneResult;\n}\n\nexport interface ColumnLike extends Value {\n  values: DeepReadonly<Value[]>;\n  atIndex(i: number): DeepReadonly<Value>;\n  rowCount: number;\n  getData(): Interpreter.OneResult;\n  lowLevelGet(...keys: number[]): Value;\n  /** Useful when filtering or sorting.\n   * By default the identity function is used and no index changes are assumed to exist */\n  indexToLabelIndex?: (index: number) => number;\n  dimensions: Dimension[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isColumnLike = (thing: any): thing is ColumnLike => {\n  const col = thing as ColumnLike;\n  return typeof col === 'object' && typeof col?.lowLevelGet === 'function';\n};\n\nexport const getColumnLike = (\n  thing: Value,\n  message = 'panic: expected column-like value'\n): ColumnLike => {\n  if (!isColumnLike(thing)) {\n    throw new Error(message);\n  }\n  return thing;\n};\n\nexport type NonColumn =\n  | typeof UnknownValue\n  | NumberValue\n  | StringValue\n  | BooleanValue\n  | Range\n  | DateValue\n  | Table\n  | Row;\n","import { N } from '@decipad/number';\nimport { getDefined } from '@decipad/utils';\nimport produce from 'immer';\nimport { InferError, PrimitiveTypeName, Type } from '.';\nimport type { AST, Time } from '..';\nimport { timeUnitFromUnit } from '../date';\nimport { Unit } from './unit-type';\n\nconst primitive = (type: PrimitiveTypeName) =>\n  produce(new Type(), (t) => {\n    t.type = type;\n  });\n\nexport const number = (\n  unit: Unit[] | null = null,\n  numberFormat: Type['numberFormat'] | undefined = undefined,\n  numberError: Type['numberError'] | undefined = undefined\n) =>\n  produce(primitive('number'), (t) => {\n    if (unit != null && numberFormat != null) {\n      throw new Error('Cannot specify both unit and numberFormat');\n    }\n    t.unit = unit?.length ? unit : null;\n    t.numberFormat = numberFormat ?? null;\n    t.numberError = numberError ?? null;\n  });\n\nexport const string = () => primitive('string');\n\nexport const boolean = () => primitive('boolean');\n\nexport const range = (rangeContents: Type) =>\n  produce(new Type(), (t) => {\n    t.rangeOf = rangeContents;\n  });\n\nexport const date = (specificity: Time.Specificity) =>\n  produce(new Type(), (t) => {\n    t.date = specificity;\n  });\n\nexport const timeQuantity = (timeUnit: Unit | string) =>\n  produce(primitive('number'), (numberType) => {\n    numberType.unit = [\n      {\n        unit: timeUnitFromUnit(timeUnit),\n        exp: N(1),\n        multiplier: N(1),\n        known: true,\n      },\n    ];\n  });\n\ninterface BuildTableArgs {\n  indexName?: string | null;\n  columnTypes: Type[];\n  columnNames: string[];\n}\n\nexport const table = ({\n  indexName,\n  columnTypes,\n  columnNames,\n}: BuildTableArgs) => {\n  return produce(new Type(), (t) => {\n    t.indexName = indexName ?? null;\n    t.columnTypes = columnTypes;\n    t.columnNames = columnNames;\n  });\n};\n\nexport const row = (\n  cells: Type[],\n  cellNames: string[],\n  rowIndexName: string | null = null\n) => {\n  const rowT = produce(new Type(), (t) => {\n    t.rowCellTypes = cells;\n    t.rowCellNames = cellNames;\n    t.rowIndexName = rowIndexName;\n  });\n\n  const errored = rowT.rowCellTypes?.find((t) => t.errorCause != null);\n\n  if (errored != null) {\n    return rowT.withErrorCause(getDefined(errored.errorCause));\n  } else {\n    return rowT;\n  }\n};\n\nexport const column = (\n  cellType: Type,\n  _columnSize?: number | 'unknown',\n  indexedBy?: string | null,\n  atParentIndex?: number | null\n) => {\n  const colT = produce(new Type(), (t) => {\n    t.indexedBy = indexedBy ?? null;\n    t.cellType = cellType;\n    t.columnSize = 'unknown';\n    t.atParentIndex = atParentIndex ?? null;\n  });\n\n  if (cellType.errorCause != null) {\n    return colT.withErrorCause(cellType.errorCause);\n  } else {\n    return colT;\n  }\n};\n\nexport const functionPlaceholder = (\n  name: string,\n  argCount: number | undefined\n) =>\n  produce(new Type(), (fType) => {\n    fType.functionness = true;\n    fType.functionName = name;\n    fType.functionArgCount = argCount;\n  });\n\nexport const nothing = () =>\n  produce(new Type(), (nothingType) => {\n    nothingType.nothingness = true;\n  });\n\nexport const anything = () =>\n  produce(new Type(), (anyType) => {\n    anyType.anythingness = true;\n  });\n\nexport const impossible = (\n  errorCause: string | InferError,\n  inNode: AST.Node | null = null\n): Type =>\n  produce(new Type(), (impossibleType) => {\n    if (typeof errorCause === 'string') {\n      errorCause = new InferError(errorCause);\n    }\n\n    impossibleType.errorCause = errorCause;\n    impossibleType.node = inNode;\n  });\n","import { immerable } from 'immer';\nimport type { Time, Unit } from '..';\nimport type { Type } from './Type';\n\nexport type ErrSpec =\n  | {\n      errType: 'free-form';\n      message: string;\n    }\n  | {\n      errType: 'missing-variable';\n      missingVariable: [name: string];\n    }\n  | {\n      errType: 'missing-formula';\n      formulaName: string;\n    }\n  | {\n      errType: 'expected-but-got';\n      expectedButGot: [Type | string, Type | string];\n    }\n  | {\n      errType: 'expected-primitive';\n      butGot: Type;\n    }\n  | {\n      errType: 'expected-arg-count';\n      expectedArgCount: [string, number, number];\n    }\n  | {\n      errType: 'expected-unit';\n      expectedUnit: [Unit[] | null, Unit[] | null];\n    }\n  | { errType: 'unexpected-empty-column' }\n  | {\n      errType: 'forbidden-inside-function';\n      forbiddenThing: 'table' | 'category';\n    }\n  | {\n      errType: 'mismatched-specificity';\n      expectedSpecificity: Time.Specificity;\n      gotSpecificity: Time.Specificity;\n    }\n  | {\n      errType: 'column-contains-inconsistent-type';\n      cellType: Type;\n      got: Type;\n    }\n  | {\n      errType: 'bad-overloaded-builtin-call';\n      functionName: string;\n      gotArgTypes: Type[];\n    }\n  | {\n      errType: 'cannot-convert-between-units';\n      fromUnit: Unit[];\n      toUnit: Unit[];\n    }\n  | {\n      errType: 'formula-cannot-call-itself';\n      fname: string;\n    }\n  | {\n      errType: 'cannot-convert-to-unit';\n      toUnit: Unit[];\n    }\n  | {\n      errType: 'unknown-category';\n      dimensionId: string | number;\n    }\n  | {\n      errType: 'duplicated-table-column';\n      columnName: string;\n    }\n  | {\n      errType: 'expected-table-and-associated-column';\n      gotTable?: Type;\n      gotColumn?: Type;\n    }\n  | {\n      errType: 'duplicated-name';\n      duplicatedName: string;\n    }\n  | {\n      errType: 'complex-expression-exponent';\n    }\n  | {\n      errType: 'sequence-step-zero';\n    }\n  | {\n      errType: 'invalid-sequence-step';\n      start: number;\n      end: number;\n      by: number;\n    }\n  | {\n      errType: 'no-previous-statement';\n    }\n  | {\n      errType: 'need-one-only-one-unit';\n    }\n  | {\n      errType: 'unknown-reference';\n    }\n  | {\n      errType: 'retired-feature';\n      featureName: string;\n    };\n\n// exhaustive switch\nexport class InferError extends Error {\n  [immerable] = true;\n\n  spec: ErrSpec;\n  pathToError: ('range' | 'column')[] = [];\n\n  constructor(spec: string | ErrSpec) {\n    if (typeof spec === 'string') {\n      spec = {\n        errType: 'free-form',\n        message: spec,\n      };\n    }\n    super(`Inference Error: ${spec.errType}`);\n    this.spec = spec;\n  }\n\n  static missingVariable(varName: string) {\n    return new InferError({\n      errType: 'missing-variable',\n      missingVariable: [varName],\n    });\n  }\n\n  static missingFormula(formulaName: string) {\n    return new InferError({\n      errType: 'missing-formula',\n      formulaName,\n    });\n  }\n\n  static expectedButGot(\n    expected: Type | string,\n    got: Type | string\n  ): InferError {\n    return new InferError({\n      errType: 'expected-but-got',\n      expectedButGot: [expected, got],\n    });\n  }\n\n  static expectedPrimitive(butGot: Type): InferError {\n    return new InferError({ errType: 'expected-primitive', butGot });\n  }\n\n  static expectedArgCount(\n    fname: string,\n    expected: number,\n    got: number\n  ): InferError {\n    return new InferError({\n      errType: 'expected-arg-count',\n      expectedArgCount: [fname, expected, got],\n    });\n  }\n\n  static expectedUnit(expected: Unit[] | null, got: Unit[] | null) {\n    return new InferError({\n      errType: 'expected-unit',\n      expectedUnit: [expected, got],\n    });\n  }\n\n  static unexpectedEmptyColumn() {\n    return new InferError({\n      errType: 'unexpected-empty-column',\n    });\n  }\n\n  static forbiddenInsideFunction(forbiddenThing: 'table' | 'category') {\n    return new InferError({\n      errType: 'forbidden-inside-function',\n      forbiddenThing,\n    });\n  }\n\n  static mismatchedSpecificity(\n    expectedSpecificity: Time.Specificity,\n    gotSpecificity: Time.Specificity\n  ) {\n    return new InferError({\n      errType: 'mismatched-specificity',\n      expectedSpecificity,\n      gotSpecificity,\n    });\n  }\n\n  static columnContainsInconsistentType(cellType: Type, got: Type) {\n    return new InferError({\n      errType: 'column-contains-inconsistent-type',\n      cellType,\n      got,\n    });\n  }\n\n  static badOverloadedBuiltinCall(functionName: string, gotArgTypes: Type[]) {\n    return new InferError({\n      errType: 'bad-overloaded-builtin-call',\n      functionName,\n      gotArgTypes,\n    });\n  }\n\n  static cannotConvertBetweenUnits(fromUnit: Unit[], toUnit: Unit[]) {\n    return new InferError({\n      errType: 'cannot-convert-between-units',\n      fromUnit,\n      toUnit,\n    });\n  }\n\n  static formulaCannotCallItself(fname: string): string | InferError {\n    return new InferError({ errType: 'formula-cannot-call-itself', fname });\n  }\n\n  static cannotConvertToUnit(toUnit: Unit[]) {\n    return new InferError({\n      errType: 'cannot-convert-to-unit',\n      toUnit,\n    });\n  }\n\n  static unknownCategory(dimensionId: number | string) {\n    return new InferError({\n      errType: 'unknown-category',\n      dimensionId,\n    });\n  }\n\n  static duplicateTableColumn(columnName: string) {\n    return new InferError({\n      errType: 'duplicated-table-column',\n      columnName,\n    });\n  }\n\n  static expectedTableAndAssociatedColumn(\n    gotTable?: Type | null,\n    gotColumn?: Type | null\n  ) {\n    return new InferError({\n      errType: 'expected-table-and-associated-column',\n      gotTable: gotTable ?? undefined,\n      gotColumn: gotColumn ?? undefined,\n    });\n  }\n\n  static duplicatedName(duplicatedName: string) {\n    return new InferError({\n      errType: 'duplicated-name',\n      duplicatedName,\n    });\n  }\n\n  static complexExpressionExponent() {\n    return new InferError({\n      errType: 'complex-expression-exponent',\n    });\n  }\n\n  static sequenceStepZero() {\n    return new InferError({\n      errType: 'sequence-step-zero',\n    });\n  }\n\n  static invalidSequenceStep(start: number, end: number, by: number) {\n    return new InferError({\n      errType: 'invalid-sequence-step',\n      start,\n      end,\n      by,\n    });\n  }\n\n  static noPreviousStatement() {\n    return new InferError({\n      errType: 'no-previous-statement',\n    });\n  }\n\n  static needOneAndOnlyOneUnit() {\n    return new InferError({\n      errType: 'need-one-only-one-unit',\n    });\n  }\n\n  static retiredFeature(featureName: string) {\n    return new InferError({\n      errType: 'retired-feature',\n      featureName,\n    });\n  }\n\n  get url() {\n    if (this.spec.errType === 'retired-feature') {\n      return `/docs/basic-concepts/retired-features#${this.spec.featureName}`;\n    }\n    return `/docs/basic-concepts/language-errors#${this.spec.errType}`;\n  }\n}\n","import { produce } from 'immer';\nimport type { AST } from '..';\nimport type { Type } from '.';\n\nexport const onlyOneIsPercentage = (\n  me: AST.NumberFormat | null,\n  other: AST.NumberFormat | null\n) => {\n  if (me === 'percentage' && other === 'percentage') {\n    return false;\n  }\n  if (me === 'percentage' || other === 'percentage') {\n    return true;\n  }\n  return false;\n};\n\nexport const propagatePercentage = (me: Type, other: Type) => {\n  if (onlyOneIsPercentage(me.numberFormat, other.numberFormat)) {\n    return produce(me, (m) => {\n      m.numberFormat = null;\n    });\n  }\n  return me;\n};\n","import pluralize, { singular, plural, addIrregularRule } from 'pluralize';\n\naddIrregularRule('calorie', 'calories');\naddIrregularRule('celsius', 'celsius');\naddIrregularRule('siemens', 'siemens');\naddIrregularRule('are', 'ares');\naddIrregularRule('s', 's');\naddIrregularRule('h', 'h');\naddIrregularRule('psi', 'psi');\naddIrregularRule('kph', 'kph');\naddIrregularRule('mph', 'mph');\naddIrregularRule('u', 'u');\naddIrregularRule('lumen', 'lumen');\naddIrregularRule('scarab', 'scarab');\naddIrregularRule('previous', 'previous');\n\n// easter eggs\naddIrregularRule('lol', 'lulz');\naddIrregularRule('lul', 'lulz');\naddIrregularRule('omegalul', 'omegalulz');\naddIrregularRule('UwU', 'UwU');\naddIrregularRule('OwO', 'OwO');\n\nfunction pluralizeBigint(str: string, n: number | bigint = 2n) {\n  return pluralize(str, Number(n));\n}\n\nexport default pluralizeBigint;\n\nexport { singular, plural, addIrregularRule };\n","import { identity } from '../utils';\nimport type { UnitOfMeasure } from './known-units';\n\nconst superBaseQuantity = 'currency';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'euro',\n    symbols: ['', 'eur'],\n    baseQuantity: 'EUR',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'usdollar',\n    symbols: ['$', 'usd'],\n    aliases: ['dollar'],\n    baseQuantity: 'USD',\n    pretty: '$',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'britishpound',\n    symbols: ['', 'gbp'],\n    baseQuantity: 'GBP',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'swedishkrona',\n    symbols: ['sek'],\n    baseQuantity: 'SEK',\n    pretty: 'kr',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'scarab',\n    symbols: ['', 'xxx'],\n    baseQuantity: 'XXX',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'norwegiankrona',\n    symbols: ['nok'],\n    baseQuantity: 'NOK',\n    pretty: 'kr',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'japanyen',\n    symbols: ['yen', 'jpy'],\n    baseQuantity: 'JPY',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'chinayuan',\n    symbols: ['yuan', 'cny'],\n    baseQuantity: 'CNY',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'philippinepeso',\n    symbols: ['', 'piso', 'php'],\n    baseQuantity: 'PHP',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'indianrupee',\n    symbols: ['', 'rupee', 'inr'],\n    baseQuantity: 'INR',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'russianruble',\n    symbols: ['', 'ruble', 'rub'],\n    baseQuantity: 'RUB',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'turkishlira',\n    symbols: ['', 'tl', 'try'],\n    baseQuantity: 'TRY',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'southkoreanwon',\n    symbols: ['', 'won', 'krw'],\n    baseQuantity: 'KRW',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'thaibaht',\n    symbols: ['', 'baht', 'thb'],\n    baseQuantity: 'THB',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'polishzoty',\n    symbols: ['z', 'zoty', 'pln'],\n    baseQuantity: 'PLN',\n    pretty: 'z',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'israelinewshekel',\n    symbols: ['', 'newshekel', 'ils'],\n    baseQuantity: 'ILS',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'UAEdirham',\n    symbols: ['.', 'dirham', 'aed'],\n    baseQuantity: 'AED',\n    pretty: '.',\n    toBaseQuantity: identity,\n    superBaseQuantity,\n    fromBaseQuantity: identity,\n  },\n  {\n    name: 'saudiriyal',\n    symbols: ['', 'riyal', 'sar'],\n    baseQuantity: 'SAR',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'australiandollar',\n    symbols: ['A$', 'AUD$', 'aud'],\n    baseQuantity: 'AUD',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'canadiandollar',\n    symbols: ['C$', 'CAN$', 'cad'],\n    baseQuantity: 'CAD',\n    pretty: 'C$',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'swissfranc',\n    symbols: ['chf'],\n    baseQuantity: 'CHF',\n    pretty: 'chf',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'hongkongdollar',\n    symbols: ['HK$', 'hkd'],\n    baseQuantity: 'HKD',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'newzealanddollar',\n    symbols: ['NZ$', 'nzd'],\n    baseQuantity: 'NZD',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'singaporedollar',\n    symbols: ['S$', 'sgd'],\n    baseQuantity: 'SGD',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'southafricanrand',\n    symbols: ['rand', 'zar'],\n    baseQuantity: 'ZAR',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'brazilianreal',\n    symbols: ['real', 'reais', 'R$', 'brl'],\n    baseQuantity: 'BRL',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'newtaiwandollar',\n    symbols: ['NT$', 'twd'],\n    baseQuantity: 'TWD',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'danishkrone',\n    symbols: ['dkk'],\n    baseQuantity: 'DKK',\n    pretty: 'kr',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'indonesianrupiah',\n    symbols: ['rp', 'idr', 'rupiah'],\n    baseQuantity: 'IDR',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'hungarianforint',\n    symbols: ['huf', 'forint'],\n    baseQuantity: 'HUF',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'czechkoruna',\n    symbols: ['K', 'czk'],\n    baseQuantity: 'CZK',\n    pretty: 'K',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'chileanpeso',\n    symbols: ['CLP$', 'clp'],\n    baseQuantity: 'CLP',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'colombianpeso',\n    symbols: ['COL$', 'cop'],\n    baseQuantity: 'COP',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'malaysianringgit',\n    symbols: ['rm', 'ringgit', 'myr'],\n    baseQuantity: 'MYR',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'romanianleu',\n    symbols: ['leu', 'ron'],\n    baseQuantity: 'RON',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'cryptobitcoin',\n    symbols: ['', 'bitcoin', 'btc'],\n    baseQuantity: 'BTC',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'cryptoethereum',\n    symbols: ['', 'ether', 'eth'],\n    baseQuantity: 'ETH',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n  {\n    name: 'ukrainianhryvnia',\n    symbols: ['', 'ua', 'uah'],\n    baseQuantity: 'UAH',\n    pretty: '',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n    superBaseQuantity,\n  },\n];\n","import DeciNumber, { N } from '@decipad/number';\nimport { identity, invert } from '../utils';\nimport type { UnitOfMeasure } from './known-units';\n\nconst PI = N(3141592653589793, 10 ** 15);\n\nconst degreeToRadian = (deg: DeciNumber): DeciNumber => deg.mul(PI).div(N(180));\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'radian',\n    symbols: ['r', 'rad'],\n    pretty: 'rad',\n    baseQuantity: 'angle',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n  {\n    name: 'degree',\n    symbols: [''],\n    pretty: '',\n    baseQuantity: 'angle',\n    toBaseQuantity: degreeToRadian,\n    fromBaseQuantity: invert(degreeToRadian),\n  },\n];\n","import { N } from '@decipad/number';\nimport type { UnitOfMeasure } from './known-units';\nimport { identity, invert } from '../utils';\n\nexport const oneInch = N(254, 10 ** 4);\nexport const oneFoot = oneInch.mul(N(12));\nexport const oneYard = oneFoot.mul(N(3));\nexport const oneMile = oneYard.mul(N(1_760));\nconst oneFurlong = N(201_168, 1e3);\nconst oneNauticalmile = N(1_852);\nconst oneNauticalleague = N(5_556);\nconst oneAngstrom = N(1, 1e10);\nconst oneBohr = N(529_177_210_903, 1e21);\nconst oneAttometre = N(1, 1e18);\nconst oneFermi = N(1, 1e15);\nconst oneSmoot = N(1_702, 1e3);\nconst oneAstronomicalunit = N(149_597_870_700);\nconst oneLightsecond = N(299_792_458);\nconst oneLightyear = N(9_460_730_472_580_800);\n\ntype Converter = UnitOfMeasure['toBaseQuantity'];\n\nconst inch: Converter = (x) => x.mul(oneInch);\nconst foot: Converter = (x) => x.mul(oneFoot);\nconst yard: Converter = (x) => x.mul(oneYard);\nconst furlong: Converter = (x) => x.mul(oneFurlong);\nconst mile: Converter = (x) => x.mul(oneMile);\nconst nauticalmile: Converter = (x) => x.mul(oneNauticalmile);\nconst nauticalleague: Converter = (x) => x.mul(oneNauticalleague);\nconst angstrom: Converter = (x) => x.mul(oneAngstrom);\nconst bohr: Converter = (x) => x.mul(oneBohr);\nconst attometre: Converter = (x) => x.mul(oneAttometre);\nconst fermi: Converter = (x) => x.mul(oneFermi);\nconst smoot: Converter = (x) => x.mul(oneSmoot);\nconst astronomicalunit: Converter = (x) => x.mul(oneAstronomicalunit);\nconst lightsecond: Converter = (x) => x.mul(oneLightsecond);\nconst lightminute: Converter = (x) => lightsecond(x).mul(N(60));\nconst lighthour: Converter = (x) => lightminute(x).mul(N(60));\nconst lightday: Converter = (x) => lighthour(x).mul(N(24));\nconst lightyear: Converter = (x) => x.mul(oneLightyear);\nconst chain: Converter = (x) => x.mul(oneFoot).mul(N(66));\nconst fathom: Converter = (x) => x.mul(oneFoot).mul(N(6));\nconst link: Converter = (x) => x.mul(oneFoot).mul(N(66)).div(N(1e2));\nconst marathon: Converter = (x) => x.mul(N(42_195));\n// eslint-disable-next-line @typescript-eslint/no-loss-of-precision\nconst parsec: Converter = (x) => x.mul(N(30_856_775_814_913_673));\nconst point: Converter = (x) => x.mul(oneInch).div(N(72_272)).mul(N(1e3));\nconst twip: Converter = (x) => x.mul(oneInch).div(N(1_440));\nconst rope: Converter = (x) => x.mul(N(6_096)).div(N(1e3));\nconst rod: Converter = (x) => x.mul(N(50_292)).div(N(1e4));\nconst league: Converter = (x) => x.mul(N(4_828));\nconst hand: Converter = (x) => x.mul(N(1_016)).div(N(1e4));\nconst pica: Converter = (x) =>\n  x.mul(N(12)).mul(oneInch).div(N(72_272)).mul(N(1e3));\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'meter',\n    symbols: ['m'],\n    aliases: ['metre'],\n    baseQuantity: 'length',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  0.0254 m\n    name: 'inch',\n    symbols: ['in'],\n    baseQuantity: 'length',\n    toBaseQuantity: inch,\n    fromBaseQuantity: invert(inch),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  0.3048 m\n    name: 'foot',\n    baseQuantity: 'length',\n    symbols: ['ft'],\n    toBaseQuantity: foot,\n    fromBaseQuantity: invert(foot),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  0.9144 m\n    name: 'yard',\n    symbols: ['yd'],\n    baseQuantity: 'length',\n    toBaseQuantity: yard,\n    fromBaseQuantity: invert(yard),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    // = 201.168 m\n    name: 'furlong',\n    symbols: ['fur'],\n    baseQuantity: 'length',\n    toBaseQuantity: furlong,\n    fromBaseQuantity: invert(furlong),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  1609.344 m\n    name: 'mile',\n    symbols: ['mi'],\n    baseQuantity: 'length',\n    toBaseQuantity: mile,\n    fromBaseQuantity: invert(mile),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  1852 m\n    name: 'nauticalmile',\n    symbols: ['nmi'],\n    baseQuantity: 'length',\n    pretty: 'nautical mile',\n    toBaseQuantity: nauticalmile,\n    fromBaseQuantity: invert(nauticalmile),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    // = 5556 m\n    name: 'nauticalleague',\n    symbols: ['nl'],\n    baseQuantity: 'length',\n    pretty: 'nautical league',\n    toBaseQuantity: nauticalleague,\n    fromBaseQuantity: invert(nauticalleague),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  0.1 nm\n    name: 'angstrom',\n    baseQuantity: 'length',\n    symbols: [''],\n    pretty: '',\n    toBaseQuantity: angstrom,\n    fromBaseQuantity: invert(angstrom),\n  },\n  {\n    // https://physics.nist.gov/cgi-bin/cuu/Value?bohrrada0\n    //  5.29177210903 x 10e-11 m\n    name: 'bohr',\n    symbols: ['a0', 'a'],\n    pretty: 'a',\n    baseQuantity: 'length',\n    toBaseQuantity: bohr,\n    fromBaseQuantity: invert(bohr),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  110e18 m\n    name: 'attometre',\n    baseQuantity: 'length',\n    symbols: ['am'],\n    toBaseQuantity: attometre,\n    fromBaseQuantity: invert(attometre),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  110e15 m\n    name: 'fermi',\n    baseQuantity: 'length',\n    symbols: ['fm'],\n    toBaseQuantity: fermi,\n    fromBaseQuantity: invert(fermi),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Smoot\n    // 1.702 m\n    name: 'smoot',\n    baseQuantity: 'length',\n    toBaseQuantity: smoot,\n    fromBaseQuantity: invert(smoot),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  149597870700 m\n    name: 'astronomicalunit',\n    symbols: ['au'],\n    baseQuantity: 'length',\n    pretty: 'astronomic alunit',\n    toBaseQuantity: astronomicalunit,\n    fromBaseQuantity: invert(astronomicalunit),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Light-second\n    //  299792458 m\n    name: 'lightsecond',\n    symbols: ['ls'],\n    baseQuantity: 'length',\n    pretty: 'light second',\n    toBaseQuantity: lightsecond,\n    fromBaseQuantity: invert(lightsecond),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  60 light-seconds\n    name: 'lightminute',\n    baseQuantity: 'length',\n    pretty: 'light minute',\n    toBaseQuantity: lightminute,\n    fromBaseQuantity: invert(lightminute),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  60 light-minutes\n    name: 'lighthour',\n    symbols: ['lh'],\n    baseQuantity: 'length',\n    pretty: 'light hour',\n    toBaseQuantity: lighthour,\n    fromBaseQuantity: invert(lighthour),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  24 light-hours\n    name: 'lightday',\n    symbols: ['ld'],\n    pretty: 'light day',\n    baseQuantity: 'length',\n    toBaseQuantity: lightday,\n    fromBaseQuantity: invert(lightday),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  9.460730472580810e15 m\n    name: 'lightyear',\n    symbols: ['ly'],\n    pretty: 'light year',\n    baseQuantity: 'length',\n    toBaseQuantity: lightyear,\n    fromBaseQuantity: invert(lightyear),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  20.11684 m\n    //  66 ft (US)  4 rods\n    name: 'chain',\n    baseQuantity: 'length',\n    symbols: ['ch'],\n    toBaseQuantity: chain,\n    fromBaseQuantity: invert(chain),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    // = 1.8288 m\n    //  6 ft (US)\n    name: 'fathom',\n    baseQuantity: 'length',\n    symbols: ['ftm'],\n    toBaseQuantity: fathom,\n    fromBaseQuantity: invert(fathom),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  1100 ch  0.66 ft (US)  7.92 in\n    //  0.2011684 m\n    name: 'link',\n    baseQuantity: 'length',\n    symbols: ['lnk'],\n    toBaseQuantity: link,\n    fromBaseQuantity: invert(link),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Marathon\n    //  42195 m\n    name: 'marathon',\n    baseQuantity: 'length',\n    toBaseQuantity: marathon,\n    fromBaseQuantity: invert(marathon),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Parsec\n    //  30856775814913673 m\n    name: 'parsec',\n    baseQuantity: 'length',\n    symbols: ['pc'],\n    toBaseQuantity: parsec,\n    fromBaseQuantity: invert(parsec),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  0.000351450 m\n    //  172.272 in\n    name: 'point',\n    baseQuantity: 'length',\n    symbols: ['pt'],\n    toBaseQuantity: point,\n    fromBaseQuantity: invert(point),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    // = 1.7638105 m\n    //  11440 in\n    name: 'twip',\n    baseQuantity: 'length',\n    symbols: ['twp'],\n    toBaseQuantity: twip,\n    fromBaseQuantity: invert(twip),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Rope_(unit)\n    // = 6.096 m\n    //  20 ft (US)\n    name: 'rope',\n    baseQuantity: 'length',\n    toBaseQuantity: rope,\n    fromBaseQuantity: invert(rope),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    // = 5.0292 m\n    name: 'rod',\n    baseQuantity: 'length',\n    symbols: ['rd'],\n    toBaseQuantity: rod,\n    fromBaseQuantity: invert(rod),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  4828 m\n    name: 'league',\n    baseQuantity: 'length',\n    symbols: ['lea'],\n    toBaseQuantity: league,\n    fromBaseQuantity: invert(league),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  0.1016 m\n    //  4 in (US)\n    name: 'hand',\n    baseQuantity: 'length',\n    toBaseQuantity: hand,\n    fromBaseQuantity: invert(hand),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Pica_(typography)\n    //  12 points\n    name: 'pica',\n    baseQuantity: 'length',\n    toBaseQuantity: pica,\n    fromBaseQuantity: invert(pica),\n  },\n];\n","import { N } from '@decipad/number';\nimport type { UnitOfMeasure } from './known-units';\nimport { identity, invert } from '../utils';\nimport { oneMile, oneYard, oneFoot, oneInch } from './length-units';\n\nconst oneAcre = N(40_468_564_224);\n\ntype Converter = UnitOfMeasure['toBaseQuantity'];\n\nconst squarekilometre: Converter = (x) => x.mul(N(1_000_000));\nconst squaremile: Converter = (x) => x.mul(oneMile).mul(oneMile);\nconst squareyard: Converter = (x) => x.mul(oneYard).mul(oneYard);\nconst squarefoot: Converter = (x) => x.mul(oneFoot).mul(oneFoot);\nconst squareinch: Converter = (x) => x.mul(oneInch).mul(oneInch);\nconst acre: Converter = (x) => x.mul(oneAcre).div(N(1e7));\nconst barony: Converter = (x) => x.mul(oneAcre).div(N(1e7)).mul(N(4_000));\nconst barn: Converter = (x) => x.div(N(1e29));\nconst are: Converter = (x) => x.mul(N(100));\nconst ha: Converter = (x) => x.mul(N(10_000));\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'squaremeter',\n    symbols: ['m2', 'm'],\n    pretty: 'm',\n    baseQuantity: 'area',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  10e6 m2\n    name: 'squarekilometre',\n    symbols: ['km2', 'km'],\n    pretty: 'km',\n    baseQuantity: 'area',\n    toBaseQuantity: squarekilometre,\n    fromBaseQuantity: invert(squarekilometre),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  2.58998811033610e6 m2\n    //  1 m  1 m\n    name: 'squaremile',\n    symbols: ['mi2', 'mi', 'sqmi'],\n    pretty: 'mi',\n    baseQuantity: 'area',\n    toBaseQuantity: squaremile,\n    fromBaseQuantity: invert(squaremile),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  0.83612736 m2\n    //  1 yd  1 yd\n    name: 'squareyard',\n    symbols: ['yd2', 'yd', 'sqyd'],\n    pretty: 'yd',\n    baseQuantity: 'area',\n    toBaseQuantity: squareyard,\n    fromBaseQuantity: invert(squareyard),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  9.29030410e2 m2\n    //  1 ft  1 ft\n    name: 'squarefoot',\n    symbols: ['ft2', 'ft', 'sqft'],\n    pretty: 'ft',\n    baseQuantity: 'area',\n    toBaseQuantity: squarefoot,\n    fromBaseQuantity: invert(squarefoot),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  6.451610e4 m2\n    //  1 inch  1 inch\n    name: 'squareinch',\n    symbols: ['in2', 'in', 'sqin'],\n    pretty: 'in',\n    baseQuantity: 'area',\n    toBaseQuantity: squareinch,\n    fromBaseQuantity: invert(squareinch),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  4046.8564224 m2\n    //  1 ch  10 ch = 4840 sq yd\n    name: 'acre',\n    symbols: ['ac'],\n    baseQuantity: 'area',\n    toBaseQuantity: acre,\n    fromBaseQuantity: invert(acre),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  100 m2\n    name: 'are',\n    baseQuantity: 'area',\n    toBaseQuantity: are,\n    fromBaseQuantity: invert(are),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  10000 m2\n    name: 'hectare',\n    symbols: ['ha'],\n    baseQuantity: 'area',\n    toBaseQuantity: ha,\n    fromBaseQuantity: invert(ha),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  1.61874256896107 m2\n    //  4000 ac\n    name: 'barony',\n    baseQuantity: 'area',\n    toBaseQuantity: barony,\n    fromBaseQuantity: invert(barony),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  10e28 m2\n    name: 'barn',\n    symbols: ['b'],\n    baseQuantity: 'area',\n    toBaseQuantity: barn,\n    fromBaseQuantity: invert(barn),\n  },\n];\n","import type { UnitOfMeasure } from './known-units';\nimport { identity } from '../utils';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'coulomb',\n    symbols: ['c'],\n    pretty: 'C',\n    baseQuantity: 'electric charge',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n];\n","import type { UnitOfMeasure } from './known-units';\nimport { identity } from '../utils';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'ampere',\n    symbols: ['a'],\n    pretty: 'A',\n    baseQuantity: 'electric current',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n];\n","import type { UnitOfMeasure } from './known-units';\nimport { identity } from '../utils';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'farad',\n    symbols: ['f'],\n    pretty: 'F',\n    baseQuantity: 'electrical capacitance',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n];\n","import type { UnitOfMeasure } from './known-units';\nimport { identity } from '../utils';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'siemens',\n    baseQuantity: 'electrical conductance',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n];\n","import type { UnitOfMeasure } from './known-units';\nimport { identity } from '../utils';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'ohm',\n    symbols: [''],\n    pretty: '',\n    baseQuantity: 'electrical resistance',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n];\n","import { N } from '@decipad/number';\nimport type { UnitOfMeasure } from './known-units';\nimport { identity, invert } from '../utils';\n\ntype Converter = UnitOfMeasure['toBaseQuantity'];\nconst calorie: Converter = (x) => x.mul(N(4184)).div(N(1000));\nconst wh: Converter = (x) => x.mul(N(3_600));\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'joule',\n    symbols: ['j'],\n    pretty: 'J',\n    baseQuantity: 'energy',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n  {\n    name: 'calorie',\n    symbols: ['cal'],\n    baseQuantity: 'energy',\n    toBaseQuantity: calorie,\n    fromBaseQuantity: invert(calorie),\n  },\n  {\n    name: 'watthour',\n    symbols: ['wh'],\n    pretty: 'Wh',\n    baseQuantity: 'energy',\n    toBaseQuantity: wh,\n    fromBaseQuantity: invert(wh),\n  },\n];\n","import type { UnitOfMeasure } from './known-units';\nimport { identity } from '../utils';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'newton',\n    symbols: ['n'],\n    pretty: 'N',\n    baseQuantity: 'force',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n];\n","import { identity } from '../utils';\nimport type { UnitOfMeasure } from './known-units';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'hertz',\n    symbols: ['hz'],\n    pretty: 'Hz',\n    baseQuantity: 'frequency',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n];\n","import { N } from '@decipad/number';\nimport type { UnitOfMeasure } from './known-units';\nimport { identity, invert } from '../utils';\n\ntype Converter = UnitOfMeasure['toBaseQuantity'];\nconst byte: Converter = (x) => x.mul(N(8));\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'bit',\n    baseQuantity: 'information',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n  {\n    name: 'byte',\n    pretty: 'B',\n    baseQuantity: 'information',\n    toBaseQuantity: byte,\n    fromBaseQuantity: invert(byte),\n  },\n];\n","import type { UnitOfMeasure } from './known-units';\nimport { identity } from '../utils';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'lumen',\n    symbols: ['lm'],\n    baseQuantity: 'luminous flow',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n];\n","import type { UnitOfMeasure } from './known-units';\nimport { identity } from '../utils';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'candela',\n    symbols: ['ca'],\n    baseQuantity: 'luminous intensity',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n];\n","import { N } from '@decipad/number';\nimport type { UnitOfMeasure } from './known-units';\nimport { identity, invert } from '../utils';\n\nconst N16 = N(16);\nconst N26 = N(26);\nconst N_1E4 = N(1e4);\nconst N_1_000_000 = N(1_000_000);\nconst N1E9 = N(1e9);\nconst N_28_349_523_125 = N(28_349_523_125);\nconst N_10_160_469_088 = N(10_160_469_088);\n\ntype Converter = UnitOfMeasure['toBaseQuantity'];\nconst pound: Converter = (x) => x.mul(N_28_349_523_125).div(N1E9).mul(N16);\nconst ounce: Converter = (x) => x.mul(N_28_349_523_125).div(N1E9);\nconst tonne: Converter = (x) => x.mul(N_1_000_000);\nconst oz: Converter = (x) => x.mul(N26);\nconst ton: Converter = (x) => x.mul(N_10_160_469_088).div(N_1E4);\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'gram',\n    symbols: ['g', 'gr'],\n    baseQuantity: 'mass',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n  {\n    name: 'pound',\n    symbols: ['lbav'],\n    baseQuantity: 'mass',\n    toBaseQuantity: pound,\n    fromBaseQuantity: invert(pound),\n  },\n  {\n    name: 'ounce',\n    baseQuantity: 'mass',\n    symbols: ['ozav'],\n    toBaseQuantity: ounce,\n    fromBaseQuantity: invert(ounce),\n  },\n  {\n    name: 'ounce_us_food_nutrition_labbeling',\n    baseQuantity: 'mass',\n    symbols: ['oz'],\n    toBaseQuantity: oz,\n    fromBaseQuantity: invert(oz),\n  },\n  {\n    name: 'tonne',\n    baseQuantity: 'mass',\n    toBaseQuantity: tonne,\n    fromBaseQuantity: invert(tonne),\n  },\n  {\n    name: 'ton',\n    baseQuantity: 'mass',\n    toBaseQuantity: ton,\n    fromBaseQuantity: invert(ton),\n  },\n];\n","import { identity } from '../utils';\nimport type { UnitOfMeasure } from './known-units';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'watt',\n    symbols: ['w', 'va'],\n    baseQuantity: 'power',\n    pretty: 'W',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n];\n","import { N } from '@decipad/number';\nimport type { UnitOfMeasure } from './known-units';\nimport { identity, invert } from '../utils';\n\nconst N_760 = N(760);\nconst N_1E3 = N(1e3);\nconst N_14_696 = N(14_696);\nconst N_101_325 = N(101_325);\nconst N_1E5 = N(1e5);\n\ntype Converter = UnitOfMeasure['toBaseQuantity'];\nconst pascal: Converter = (x) => x.div(N_101_325);\nconst bar: Converter = (x) => x.div(N_101_325).mul(N_1E5);\nconst mmhg: Converter = (x) => x.div(N_760);\nconst psi: Converter = (x) => x.div(N_14_696).mul(N_1E3);\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'atmosphere',\n    symbols: ['atm'],\n    baseQuantity: 'pressure',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n  {\n    name: 'pascal',\n    symbols: ['pa'],\n    baseQuantity: 'pressure',\n    toBaseQuantity: pascal,\n    fromBaseQuantity: invert(pascal),\n  },\n  {\n    name: 'bar',\n    symbols: ['ba'],\n    baseQuantity: 'pressure',\n    toBaseQuantity: bar,\n    fromBaseQuantity: invert(bar),\n  },\n  {\n    name: 'mmhg',\n    baseQuantity: 'pressure',\n    symbols: ['torr'],\n    toBaseQuantity: mmhg,\n    fromBaseQuantity: invert(mmhg),\n  },\n  {\n    name: 'psi',\n    baseQuantity: 'pressure',\n    toBaseQuantity: psi,\n    fromBaseQuantity: invert(psi),\n  },\n];\n","import type { UnitOfMeasure } from './known-units';\nimport { identity } from '../utils';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'steradian',\n    symbols: ['sr'],\n    baseQuantity: 'solid angle',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n];\n","import { N } from '@decipad/number';\nimport type { UnitOfMeasure } from './known-units';\nimport { identity, invert } from '../utils';\n\nexport const oneInch = N(254, 10_000);\nexport const oneFoot = oneInch.mul(N(12));\nexport const oneYard = oneFoot.mul(N(3));\nexport const oneMile = oneYard.mul(N(1_760));\nconst N_1000 = N(1000);\n\ntype Converter = UnitOfMeasure['toBaseQuantity'];\n\nconst mile: Converter = (x) => x.mul(oneMile).div(N_1000);\nconst knot: Converter = (x) => x.mul(N(1_852)).div(N_1000);\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'kph',\n    baseQuantity: 'speed',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n  {\n    name: 'mph',\n    baseQuantity: 'speed',\n    toBaseQuantity: mile,\n    fromBaseQuantity: invert(mile),\n  },\n  {\n    name: 'knot',\n    baseQuantity: 'speed',\n    toBaseQuantity: knot,\n    fromBaseQuantity: invert(knot),\n  },\n];\n","import { identity } from '../utils';\nimport type { UnitOfMeasure } from './known-units';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'mole',\n    baseQuantity: 'substance',\n    symbols: ['mol'],\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n];\n","import { N } from '@decipad/number';\nimport { identity } from '../utils';\nimport type { UnitOfMeasure } from './known-units';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'kelvin',\n    symbols: ['k'],\n    pretty: 'K',\n    baseQuantity: 'temperature',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n  {\n    name: 'celsius',\n    symbols: ['c'],\n    pretty: 'C',\n    baseQuantity: 'temperature',\n    doesNotScaleOnConversion: true,\n    toBaseQuantity: (celsius) => celsius.add(N(27315, 100)),\n    fromBaseQuantity: (kelvin) => kelvin.sub(N(27315, 100)),\n  },\n  {\n    name: 'fahrenheit',\n    symbols: ['f'],\n    baseQuantity: 'temperature',\n    pretty: 'F',\n    doesNotScaleOnConversion: true,\n    toBaseQuantity: (fahrenheit) =>\n      fahrenheit.sub(N(32)).mul(N(5)).div(N(9)).add(N(27315, 100)),\n    fromBaseQuantity: (kelvin) =>\n      kelvin.sub(N(27315, 100)).mul(N(9)).div(N(5)).add(N(32)),\n  },\n];\n","import { N } from '@decipad/number';\nimport type { UnitOfMeasure } from './known-units';\nimport { identity, invert } from '../utils';\n\nconst N_10 = N(10);\nconst N_1000 = N(1000);\nconst oneMinute = N(60);\nconst oneHour = oneMinute.mul(N(60));\nconst oneDay = oneHour.mul(N(24));\nconst oneWeek = oneDay.mul(N(7));\n\nconst oneYear = N(12);\nconst oneDecade = oneYear.mul(N_10);\nconst oneCentury = oneDecade.mul(N_10);\nconst oneMillennium = oneCentury.mul(N_10);\n\ntype Converter = UnitOfMeasure['toBaseQuantity'];\n// base: second\nconst ms: Converter = (x) => x.div(N_1000);\nconst minute: Converter = (x) => x.mul(oneMinute);\nconst hour: Converter = (x) => x.mul(oneHour);\nconst day: Converter = (x) => x.mul(oneDay);\nconst week: Converter = (x) => x.mul(oneWeek);\n// base: month\nconst year: Converter = (x) => x.mul(oneYear);\nconst decade: Converter = (x) => x.mul(oneDecade); // year * 10\nconst century: Converter = (x) => x.mul(oneCentury); // year * 100\nconst millennium: Converter = (x) => x.mul(oneMillennium); // year * 1000\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'second',\n    baseQuantity: 'second',\n    symbols: ['s'],\n    aliases: ['sec'],\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n  {\n    name: 'millisecond',\n    baseQuantity: 'second',\n    symbols: ['ms'],\n    toBaseQuantity: ms,\n    fromBaseQuantity: invert(ms),\n  },\n  {\n    name: 'minute',\n    aliases: ['min'],\n    baseQuantity: 'second',\n    toBaseQuantity: minute,\n    fromBaseQuantity: invert(minute),\n  },\n  {\n    name: 'hour',\n    symbols: ['h'],\n    aliases: ['hr'],\n    baseQuantity: 'second',\n    toBaseQuantity: hour,\n    fromBaseQuantity: invert(hour),\n  },\n  {\n    name: 'day',\n    symbols: ['d'],\n    baseQuantity: 'second',\n    toBaseQuantity: day,\n    fromBaseQuantity: invert(day),\n  },\n  {\n    name: 'week',\n    aliases: ['wk'],\n    baseQuantity: 'second',\n    toBaseQuantity: week,\n    fromBaseQuantity: invert(week),\n  },\n  {\n    name: 'month',\n    aliases: ['mo'],\n    baseQuantity: 'month',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n  {\n    name: 'year',\n    aliases: ['yr'],\n    baseQuantity: 'month',\n    toBaseQuantity: year,\n    fromBaseQuantity: invert(year),\n  },\n  {\n    name: 'decade',\n    baseQuantity: 'month',\n    toBaseQuantity: decade,\n    fromBaseQuantity: invert(decade),\n  },\n  {\n    name: 'century',\n    baseQuantity: 'month',\n    toBaseQuantity: century,\n    fromBaseQuantity: invert(century),\n  },\n  {\n    name: 'millennium',\n    aliases: ['millenniums'],\n    baseQuantity: 'month',\n    toBaseQuantity: millennium,\n    fromBaseQuantity: invert(millennium),\n  },\n];\n","import { singular, addIrregularRule } from '../langPluralize';\n\nexport function normalizeUnitName(unit: string): string {\n  return singular(unit.toLocaleLowerCase());\n}\n\nexport function doNotPluralize(abbr: string): void {\n  const aux = abbr.toLocaleLowerCase();\n  addIrregularRule(aux, aux);\n}\n","import type { UnitOfMeasure } from './known-units';\nimport { identity } from '../utils';\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'volt',\n    symbols: ['v'],\n    pretty: 'V',\n    baseQuantity: 'voltage',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n];\n","import { N } from '@decipad/number';\nimport { identity, invert } from '../utils';\nimport type { UnitOfMeasure } from './known-units';\nimport { oneMile, oneYard, oneFoot, oneInch } from './length-units';\n\nconst oneGallon = N(454_609);\n\ntype Converter = UnitOfMeasure['toBaseQuantity'];\n\nconst liters: Converter = (x) => x.div(N(1_000));\nconst ton: Converter = (x) => x.mul(N(99_108_963_072)).div(N(1e11));\nconst cup: Converter = (x) => x.mul(N(250)).div(N(1_000_000));\nconst tablespoon: Converter = (x) => x.mul(N(15)).div(N(1_000_000));\nconst ounce: Converter = (x) => x.mul(N(284_130_625)).div(N(1e13));\nconst pint: Converter = (x) => x.mul(N(56_826_125)).div(N(1e11));\nconst teaspoon: Converter = (x) => x.mul(N(5)).div(N(1_000_000));\nconst pinch: Converter = (x) => x.mul(N(5)).div(N(1_000_000)).div(N(16));\nconst dash: Converter = (x) =>\n  x.mul(N(5)).div(N(1_000_000)).div(N(16)).div(N(2));\nconst barrel: Converter = (x) => x.mul(N(16_365_924)).div(N(1e8));\nconst gallon: Converter = (x) => x.mul(N(oneGallon)).div(N(1e8));\nconst bushel: Converter = (x) => x.mul(N(oneGallon)).div(N(1e8)).mul(N(8));\nconst bucket: Converter = (x) => x.mul(oneGallon).div(N(1e8)).mul(N(4));\nconst acrefoot: Converter = (x) => x.mul(N(123_348_183_754_752)).div(N(1e14));\nconst cubicinch: Converter = (x) => x.mul(oneInch).mul(oneInch).mul(oneInch);\nconst cubicfoot: Converter = (x) => x.mul(oneFoot).mul(oneFoot).mul(oneFoot);\nconst cubicyard: Converter = (x) => x.mul(oneYard).mul(oneYard).mul(oneYard);\nconst cubicmile: Converter = (x) => x.mul(oneMile).mul(oneMile).mul(oneMile);\n\nexport const units: UnitOfMeasure[] = [\n  {\n    name: 'cubicmeter',\n    baseQuantity: 'volume',\n    symbols: ['m3', 'm'],\n    aliases: ['cubicmetre'],\n    pretty: 'm',\n    toBaseQuantity: identity,\n    fromBaseQuantity: identity,\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  1 in * 1 in * 1 in\n    name: 'cubicinch',\n    baseQuantity: 'volume',\n    symbols: ['in3', 'in', 'cuin'],\n    pretty: 'in',\n    toBaseQuantity: cubicinch,\n    fromBaseQuantity: invert(cubicinch),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  1 ft * 1 ft * 1 ft\n    name: 'cubicfoot',\n    baseQuantity: 'volume',\n    symbols: ['ft3', 'ft', 'cuft'],\n    pretty: 'ft',\n    toBaseQuantity: cubicfoot,\n    fromBaseQuantity: invert(cubicfoot),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  1 yd * 1 yd * 1 yd\n    name: 'cubicyd',\n    baseQuantity: 'volume',\n    symbols: ['yd3', 'yd', 'cuyd'],\n    pretty: 'yd',\n    toBaseQuantity: cubicyard,\n    fromBaseQuantity: invert(cubicyard),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  1 mi * 1 mi * 1 mi\n    name: 'cubicmile',\n    baseQuantity: 'volume',\n    symbols: ['cumi'],\n    pretty: 'cu mi',\n    toBaseQuantity: cubicmile,\n    fromBaseQuantity: invert(cubicmile),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  0.001 m3\n    name: 'liter',\n    baseQuantity: 'volume',\n    symbols: ['l'],\n    aliases: ['litre'],\n    toBaseQuantity: liters,\n    fromBaseQuantity: invert(liters),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  0.99108963072 m3\n    name: 'ton_displacement',\n    baseQuantity: 'volume',\n    toBaseQuantity: ton,\n    fromBaseQuantity: invert(ton),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //   250.0106 m3\n    name: 'cup',\n    baseQuantity: 'volume',\n    toBaseQuantity: cup,\n    fromBaseQuantity: invert(cup),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //   15106 m3\n    name: 'tablespoon',\n    baseQuantity: 'volume',\n    symbols: ['tbsp'],\n    toBaseQuantity: tablespoon,\n    fromBaseQuantity: invert(tablespoon),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  28.413062510e6 m3\n    name: 'ounce_fluid_imperial',\n    baseQuantity: 'volume',\n    symbols: ['floz'],\n    toBaseQuantity: ounce,\n    fromBaseQuantity: invert(ounce),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    // = 568.26125106 m3\n    name: 'pint',\n    baseQuantity: 'volume',\n    toBaseQuantity: pint,\n    fromBaseQuantity: invert(pint),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //   5106 m3\n    name: 'teaspoon',\n    baseQuantity: 'volume',\n    symbols: ['tsp'],\n    toBaseQuantity: teaspoon,\n    fromBaseQuantity: invert(teaspoon),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  1/16 tsp\n    name: 'pinch',\n    baseQuantity: 'volume',\n    toBaseQuantity: pinch,\n    fromBaseQuantity: invert(pinch),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  1/2 pinch\n    name: 'dash',\n    baseQuantity: 'volume',\n    toBaseQuantity: dash,\n    fromBaseQuantity: invert(dash),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    // = 0.16365924 m3\n    name: 'barrel',\n    baseQuantity: 'volume',\n    symbols: ['bl'],\n    toBaseQuantity: barrel,\n    fromBaseQuantity: invert(barrel),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  4.54609103 m3\n    name: 'gallon',\n    baseQuantity: 'volume',\n    symbols: ['gal'],\n    toBaseQuantity: gallon,\n    fromBaseQuantity: invert(gallon),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  8 gal\n    name: 'bushel',\n    baseQuantity: 'volume',\n    symbols: ['bu'],\n    toBaseQuantity: bushel,\n    fromBaseQuantity: invert(bushel),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    //  4 gal\n    name: 'bucket',\n    baseQuantity: 'volume',\n    symbols: ['bkt'],\n    toBaseQuantity: bucket,\n    fromBaseQuantity: invert(bucket),\n  },\n  {\n    // https://en.wikipedia.org/wiki/Conversion_of_units\n    // = 1233.48183754752 m3\n    name: 'acrefoot',\n    baseQuantity: 'volume',\n    symbols: ['acft'],\n    toBaseQuantity: acrefoot,\n    fromBaseQuantity: invert(acrefoot),\n  },\n];\n","import DeciNumber from '@decipad/number';\nimport * as AngleUnits from './angle-units';\nimport * as AreaUnits from './area-units';\nimport * as CurrencyUnits from './currency-units';\nimport * as ElectricChargeUnits from './electric-charge-units';\nimport * as ElectricCurrentUnits from './electric-current-units';\nimport * as ElectricalCapacitanceUnits from './electrical-capacitance-units';\nimport * as ElectricalConductanceUnits from './electrical-conductance-units';\nimport * as ElectricalResistanceUnits from './electrical-resistance-units';\nimport * as EnergyUnits from './energy-units';\nimport * as ForceUnits from './force-units';\nimport * as FrequencyUnits from './frequency-units';\nimport * as InformationUnits from './information-units';\nimport * as LengthUnits from './length-units';\nimport * as LuminousFlowUnits from './luminous-flow-units';\nimport * as LuminousIntensityUnits from './luminous-intensity-units';\nimport * as MassUnits from './mass-units';\nimport * as PowerUnits from './power-units';\nimport * as PressureUnits from './pressure-units';\nimport * as SolidAngleUnits from './solid-angle-units';\nimport * as SpeedUnits from './speed-units';\nimport * as SubstanceUnits from './substance-units';\nimport * as TemperatureUnits from './temperature-units';\nimport * as TimeUnits from './time-units';\nimport { doNotPluralize, normalizeUnitName } from './utils';\nimport * as VoltageUnits from './voltage-units';\nimport * as VolumeUnits from './volume-units';\n\nexport type BaseQuantity =\n  | 'length'\n  | 'area'\n  | 'volume'\n  | 'pressure'\n  | 'force'\n  | 'energy'\n  | 'mass'\n  | 'temperature'\n  | 'second'\n  | 'month'\n  | 'substance'\n  | 'electric current'\n  | 'electric charge'\n  | 'electrical capacitance'\n  | 'electrical resistance'\n  | 'electrical conductance'\n  | 'luminous intensity'\n  | 'luminous flow'\n  | 'solid angle'\n  | 'voltage'\n  | 'speed'\n  | 'power'\n  | 'frequency'\n  | 'information'\n  | 'angle'\n  | 'EUR'\n  | 'USD'\n  | 'GBP'\n  | 'SEK'\n  | 'XXX'\n  | 'NOK'\n  | 'UAH'\n  | 'JPY'\n  | 'CNY'\n  | 'PHP'\n  | 'INR'\n  | 'RUB'\n  | 'TRY'\n  | 'KRW'\n  | 'THB'\n  | 'PLN'\n  | 'ILS'\n  | 'AED'\n  | 'SAR'\n  | 'AUD'\n  | 'CAD'\n  | 'CHF'\n  | 'HKD'\n  | 'NZD'\n  | 'SGD'\n  | 'ZAR'\n  | 'BRL'\n  | 'TWD'\n  | 'DKK'\n  | 'IDR'\n  | 'HUF'\n  | 'CZK'\n  | 'CLP'\n  | 'COP'\n  | 'MYR'\n  | 'RON'\n  | 'BTC'\n  | 'ETH';\n\nexport type UnitOfMeasure = {\n  name: string;\n  baseQuantity: BaseQuantity;\n  symbols?: string[];\n  aliases?: string[];\n  pretty?: string;\n  doesNotScaleOnConversion?: true;\n  toBaseQuantity: (n: DeciNumber) => DeciNumber;\n  fromBaseQuantity: (n: DeciNumber) => DeciNumber;\n  superBaseQuantity?: 'currency';\n};\n\nconst allUnitPackages = [\n  LengthUnits,\n  AreaUnits,\n  VolumeUnits,\n  PressureUnits,\n  EnergyUnits,\n  ForceUnits,\n  MassUnits,\n  TemperatureUnits,\n  TimeUnits,\n  InformationUnits,\n  SubstanceUnits,\n  ElectricCurrentUnits,\n  ElectricChargeUnits,\n  VoltageUnits,\n  ElectricalCapacitanceUnits,\n  ElectricalResistanceUnits,\n  ElectricalConductanceUnits,\n  PowerUnits,\n  FrequencyUnits,\n  SpeedUnits,\n  CurrencyUnits,\n  LuminousIntensityUnits,\n  LuminousFlowUnits,\n  SolidAngleUnits,\n  AngleUnits,\n];\n\nconst duplicates: Set<string> = new Set();\n\nconst symbols: string[] = [];\nexport const prettyForSymbol: Record<string, string> = {};\n\nfunction makePrettyRecord(symbol: string, prty: string | undefined) {\n  if (prty) {\n    prettyForSymbol[symbol.toLowerCase()] = prty;\n  }\n}\n\nallUnitPackages.map((x) => {\n  x.units.map((unit) => {\n    if (duplicates.has(unit.name)) {\n      throw new Error(`Trying to declare twice ${unit.name}`);\n    }\n    duplicates.add(unit.name);\n    makePrettyRecord(unit.name, unit.pretty);\n    (unit.aliases || []).forEach((alias) => {\n      if (duplicates.has(alias)) {\n        throw new Error(`Trying to declare twice ${alias}`);\n      }\n      duplicates.add(alias);\n      makePrettyRecord(alias, unit.pretty);\n    });\n    (unit.symbols || []).forEach((symbol) => {\n      if (duplicates.has(symbol)) {\n        throw new Error(`Trying to declare twice ${symbol}`);\n      }\n      symbols.push(symbol);\n      duplicates.add(symbol);\n      makePrettyRecord(symbol, unit.pretty);\n    });\n  });\n});\n\nexport const unitIsSymbol = (unit: string): boolean => {\n  return symbols.some((u) => u === unit);\n};\n\nsymbols.map((symbol) => {\n  doNotPluralize(symbol);\n});\n\nconst allUnits: UnitOfMeasure[] = allUnitPackages.flatMap(\n  (unitPackage) => unitPackage.units\n);\n\nconst baseQuantitiesThatDoNotUseUnitPrefixes: Set<BaseQuantity> = new Set();\nbaseQuantitiesThatDoNotUseUnitPrefixes.add('area');\nbaseQuantitiesThatDoNotUseUnitPrefixes.add('volume');\nbaseQuantitiesThatDoNotUseUnitPrefixes.add('speed');\n\nconst allSymbols = new Map<string, UnitOfMeasure>();\n\nexport const unitsByName = allUnits.reduce<Map<string, UnitOfMeasure>>(\n  (byName, unit) => {\n    byName.set(unit.name, unit);\n    if (unit.symbols) {\n      for (const symbol of unit.symbols) {\n        allSymbols.set(symbol, unit);\n        byName.set(symbol.toLowerCase(), unit);\n      }\n    }\n    if (unit.aliases) {\n      for (const alias of unit.aliases) {\n        byName.set(alias.toLowerCase(), unit);\n      }\n    }\n    return byName;\n  },\n  new Map()\n);\n\nexport function isKnownSymbol(symbol = ''): boolean {\n  return !!symbol && allSymbols.has(symbol.toLowerCase());\n}\n\nexport function getUnitByName(unit: string): UnitOfMeasure | undefined {\n  const n = normalizeUnitName(unit);\n  return unitsByName.get(n);\n}\n\nexport function knowsUnit(unit: string): boolean {\n  return unitsByName.has(normalizeUnitName(unit));\n}\n\nexport function unitUsesPrefixes(unit: string): boolean {\n  const n = getUnitByName(unit);\n  //\n  // this means user defined units can use prefixes by default\n  // should we disable that?\n  //\n  if (!n) {\n    return true;\n  }\n  return !baseQuantitiesThatDoNotUseUnitPrefixes.has(n.baseQuantity);\n}\n\nexport function areUnitsCompatible(\n  unitAName: string,\n  unitBName: string\n): boolean {\n  const unitA = getUnitByName(unitAName);\n  const unitB = getUnitByName(unitBName);\n\n  if (!unitA && !unitB) {\n    return normalizeUnitName(unitAName) === normalizeUnitName(unitBName);\n  }\n\n  if (!unitA || !unitB) {\n    return false;\n  }\n\n  return unitA.baseQuantity === unitB.baseQuantity;\n}\n\nexport { CurrencyUnits };\n","import DeciNumber, { N } from '@decipad/number';\nimport { identity } from '@decipad/utils';\nimport type { BaseQuantity } from '../known-units';\n\nexport interface ExpandTo {\n  baseQuantity: BaseQuantity;\n  exp: DeciNumber;\n}\n\nexport type BaseQuantityExpansion = {\n  expandedUnits: ExpandTo[];\n  convertToExpanded: (n: DeciNumber) => DeciNumber;\n};\ntype Expansions = Record<BaseQuantity, BaseQuantityExpansion>;\n\nconst N_10 = N(10);\nconst N_36 = N(36);\nconst N_1000 = N(1000);\nconst N_101325 = N(101325);\n\nexport const expansions: Partial<Expansions> = {\n  force: {\n    expandedUnits: [\n      { baseQuantity: 'mass', exp: N(1) },\n      { baseQuantity: 'length', exp: N(1) },\n      { baseQuantity: 'second', exp: N(-2) },\n    ],\n    convertToExpanded: (newton) => newton.mul(N_1000), // mass is kg -> g\n  },\n  pressure: {\n    expandedUnits: [\n      { baseQuantity: 'force', exp: N(1) },\n      { baseQuantity: 'area', exp: N(-1) },\n    ],\n    convertToExpanded: (atmospheres) => atmospheres.mul(N_101325), // atmosphere to Pa\n  },\n  area: {\n    expandedUnits: [{ baseQuantity: 'length', exp: N(2) }],\n    convertToExpanded: identity,\n  },\n  volume: {\n    expandedUnits: [{ baseQuantity: 'length', exp: N(3) }],\n    convertToExpanded: identity,\n  },\n  frequency: {\n    expandedUnits: [{ baseQuantity: 'second', exp: N(-1) }],\n    convertToExpanded: identity,\n  },\n  energy: {\n    expandedUnits: [\n      { baseQuantity: 'mass', exp: N(1) },\n      { baseQuantity: 'length', exp: N(2) },\n      { baseQuantity: 'second', exp: N(-2) },\n    ],\n    convertToExpanded: (joules) => joules.mul(N_1000), // mass is kg -> g\n  },\n  power: {\n    expandedUnits: [\n      { baseQuantity: 'mass', exp: N(1) },\n      { baseQuantity: 'length', exp: N(2) },\n      { baseQuantity: 'second', exp: N(-3) },\n    ],\n    convertToExpanded: (watts) => watts.mul(N_1000), // mass is kg -> g\n  },\n  'electric charge': {\n    expandedUnits: [\n      { baseQuantity: 'second', exp: N(1) },\n      { baseQuantity: 'electric current', exp: N(1) },\n    ],\n    convertToExpanded: identity,\n  },\n  'luminous flow': {\n    expandedUnits: [\n      { baseQuantity: 'luminous intensity', exp: N(1) },\n      { baseQuantity: 'solid angle', exp: N(1) },\n    ],\n    convertToExpanded: identity,\n  },\n  speed: {\n    expandedUnits: [\n      { baseQuantity: 'length', exp: N(1) },\n      { baseQuantity: 'second', exp: N(-1) },\n    ],\n    convertToExpanded: (kph) => kph.mul(N_10).div(N_36),\n  },\n  voltage: {\n    expandedUnits: [\n      { baseQuantity: 'mass', exp: N(1) },\n      { baseQuantity: 'length', exp: N(2) },\n      { baseQuantity: 'second', exp: N(-3) },\n      { baseQuantity: 'electric current', exp: N(-1) },\n    ],\n    convertToExpanded: (volts) => volts.mul(N_1000), // mass is kg -> g\n  },\n  'electrical capacitance': {\n    expandedUnits: [\n      { baseQuantity: 'mass', exp: N(-1) },\n      { baseQuantity: 'length', exp: N(-2) },\n      { baseQuantity: 'second', exp: N(4) },\n      { baseQuantity: 'electric current', exp: N(2) },\n    ],\n    convertToExpanded: (farads) => farads.div(N_1000), // mass is kg -> g\n  },\n  'electrical resistance': {\n    expandedUnits: [\n      { baseQuantity: 'mass', exp: N(1) },\n      { baseQuantity: 'length', exp: N(2) },\n      { baseQuantity: 'second', exp: N(-3) },\n      { baseQuantity: 'electric current', exp: N(-2) },\n    ],\n    convertToExpanded: (ohms) => ohms.mul(N_1000), // mass is kg -> g\n  },\n  'electrical conductance': {\n    expandedUnits: [\n      { baseQuantity: 'mass', exp: N(-1) },\n      { baseQuantity: 'length', exp: N(-2) },\n      { baseQuantity: 'second', exp: N(3) },\n      { baseQuantity: 'electric current', exp: N(2) },\n    ],\n    convertToExpanded: (siemens) => siemens.div(N_1000), // mass is kg -> g\n  },\n};\n","import { BaseQuantity } from './known-units';\n\nconst baseQuantityToBaseUnit: Record<BaseQuantity, string> = {\n  length: 'meter',\n  area: 'squaremeter',\n  volume: 'cubicmeter',\n  pressure: 'atmosphere',\n  force: 'newton',\n  energy: 'joule',\n  mass: 'gram',\n  temperature: 'kelvin',\n  second: 'second',\n  month: 'month',\n  substance: 'mole',\n  'electric current': 'ampere',\n  'electric charge': 'coulomb',\n  voltage: 'volt',\n  power: 'watt',\n  'electrical capacitance': 'farad',\n  'electrical resistance': 'ohm',\n  'electrical conductance': 'siemens',\n  frequency: 'hertz',\n  information: 'bit',\n  'luminous intensity': 'candela',\n  'luminous flow': 'lumen',\n  'solid angle': 'steradian',\n  angle: 'radian',\n  speed: 'kph',\n  EUR: 'EUR',\n  USD: 'USD',\n  GBP: 'GBP',\n  SEK: 'SEK',\n  XXX: 'XXX',\n  NOK: 'NOK',\n  JPY: 'JPY',\n  CNY: 'CNY',\n  PHP: 'PHP',\n  INR: 'INR',\n  RUB: 'RUB',\n  TRY: 'TRY',\n  KRW: 'KRW',\n  THB: 'THB',\n  PLN: 'PLN',\n  ILS: 'ILS',\n  AED: 'AED',\n  SAR: 'SAR',\n  AUD: 'AUD',\n  CAD: 'CAD',\n  CHF: 'CHF',\n  HKD: 'HKD',\n  NZD: 'NZD',\n  SGD: 'SGD',\n  ZAR: 'ZAR',\n  BRL: 'BRL',\n  TWD: 'TWD',\n  DKK: 'DKK',\n  IDR: 'IDR',\n  HUF: 'HUF',\n  CZK: 'CZK',\n  CLP: 'CLP',\n  COP: 'COP',\n  MYR: 'MYR',\n  RON: 'RON',\n  BTC: 'BTC',\n  ETH: 'ETH',\n  UAH: 'UAH',\n};\n\nexport function baseUnitForBaseQuantity(baseQuantity: BaseQuantity): string {\n  return baseQuantityToBaseUnit[baseQuantity];\n}\n","import DeciNumber, { ONE } from '@decipad/number';\nimport { produce } from 'immer';\nimport { getDefined, identity } from '@decipad/utils';\nimport { UnitOfMeasure, getUnitByName } from '../known-units';\nimport { normalizeUnits, Unit } from '../../type';\nimport { BaseQuantityExpansion, expansions } from './expansions';\nimport { baseUnitForBaseQuantity } from '../base-units';\nimport { Converter, ExpandUnitResult } from '.';\nimport { normalizeUnitNames } from '../../type/units';\n\nexport type NonScalarExpansion = (u: Unit) => [Unit, Converter];\nexport type ScaleConverter = (convert: Converter) => Converter;\n\nfunction nonScalarExpansionFromBaseQuantity(u: Unit): [Unit, Converter] {\n  const knownUnit = getDefined(getUnitByName(u.unit));\n  const baseUnit = baseUnitForBaseQuantity(knownUnit.baseQuantity);\n  const newUnits = produce(u, (unit) => {\n    unit.unit = baseUnit;\n  });\n\n  return [newUnits, knownUnit.toBaseQuantity];\n}\n\nexport function doesNotScaleOnConversion(unit: Unit): boolean {\n  const knownUnit = getUnitByName(unit.unit);\n  if (knownUnit) {\n    return !!knownUnit.doesNotScaleOnConversion;\n  }\n  return false;\n}\n\nfunction convertingBy(mul: DeciNumber): Converter {\n  return (n: DeciNumber) => n.mul(mul);\n}\n\nfunction expandUnitWith(unit: Unit, expansion: BaseQuantityExpansion): Unit[] {\n  let first = true;\n  return expansion.expandedUnits.map((expandedUnit) => {\n    const targetUnitName = baseUnitForBaseQuantity(expandedUnit.baseQuantity);\n    const newUnit = {\n      unit: targetUnitName,\n      exp: expandedUnit.exp.mul(unit.exp),\n      multiplier: first ? unit.multiplier.pow(expandedUnit.exp) : ONE,\n      known: true,\n    };\n    first = false;\n    return newUnit;\n  });\n}\n\nfunction convertKnownUnitToBase(\n  uom: UnitOfMeasure,\n  unit: Unit\n): [Unit, Converter] {\n  const baseUnit = baseUnitForBaseQuantity(uom.baseQuantity);\n  if (baseUnit === uom.name) {\n    return [unit, identity];\n  }\n  const newUnit = produce(unit, (unit) => {\n    unit.unit = baseUnit;\n  });\n  const baseConversionFactor = uom.toBaseQuantity(ONE).pow(unit.exp);\n  const convert = convertingBy(baseConversionFactor);\n  return [newUnit, convert];\n}\n\nexport function expandUnit(\n  unit: Unit,\n  nonScalarExpansion: NonScalarExpansion = nonScalarExpansionFromBaseQuantity,\n  scale: ScaleConverter = identity\n): ExpandUnitResult {\n  if (unit.unit) {\n    const knownUnit = getUnitByName(unit.unit);\n    if (knownUnit) {\n      if (doesNotScaleOnConversion(unit)) {\n        const [baseUnit, convertToBaseUnit] = nonScalarExpansion(unit);\n        return [[baseUnit], convertToBaseUnit];\n      }\n\n      const expandTo = expansions[knownUnit.baseQuantity];\n      const [baseUnit, convertToBaseUnit] = convertKnownUnitToBase(\n        knownUnit,\n        unit\n      );\n\n      if (expandTo) {\n        const newUnits = expandUnitWith(baseUnit, expandTo);\n        const expansionFactor = expandTo.convertToExpanded(ONE).pow(unit.exp);\n        const convert: Converter = (n) =>\n          convertToBaseUnit(n).mul(expansionFactor);\n\n        return [newUnits, scale(convert)];\n      }\n\n      return [[baseUnit], scale(convertToBaseUnit)];\n    }\n  }\n  return [[unit], identity];\n}\n\nfunction expandUnitArgs(\n  _units: Unit[],\n  nonScalarExpansion: NonScalarExpansion = nonScalarExpansionFromBaseQuantity,\n  scale: ScaleConverter = identity\n): [Unit[] | null, Converter] {\n  let units = _units;\n  let converter: Converter = identity;\n  let beforeCount = units.length;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const [expandedUnits, newConverter] = units\n      .map((u) => expandUnit(u, nonScalarExpansion, scale))\n      .reduce(\n        ([allExpandedUnits, allConverters], [expandedUnits, converter]) => [\n          [...allExpandedUnits, ...expandedUnits],\n          (n) => allConverters(converter(n)),\n        ],\n        [[], converter]\n      );\n    units = normalizeUnits(expandedUnits) ?? [];\n    converter = newConverter;\n    if (units.length === beforeCount) {\n      break;\n    }\n    beforeCount = units.length;\n  }\n  return [units, converter];\n}\n\nexport function expandUnits(\n  units?: Unit[] | null,\n  nonScalarExpansion: NonScalarExpansion = nonScalarExpansionFromBaseQuantity,\n  scale: ScaleConverter = identity\n): [Unit[] | null, Converter] {\n  if (!units?.length) {\n    return [null, identity];\n  }\n\n  const [unitArgs, converter] = expandUnitArgs(\n    normalizeUnitNames(units),\n    nonScalarExpansion,\n    scale\n  );\n\n  return [unitArgs ?? [], converter];\n}\n","import { getDefined, identity } from '@decipad/utils';\nimport { ONE } from '@decipad/number';\nimport { Converter } from '.';\nimport { expandUnits } from './expand-units';\nimport { Unit } from '../../type';\nimport { getUnitByName } from '..';\n\nfunction scalarInversion(convert: Converter): Converter {\n  return (n) => {\n    if (n.isZero()) {\n      return n;\n    }\n    const div = convert(ONE);\n    return n.div(div);\n  };\n}\n\nfunction nonScalarInversion(u: Unit): [Unit, Converter] {\n  const knownUnit = getDefined(getUnitByName(u.unit));\n  return [u, knownUnit.fromBaseQuantity];\n}\n\nexport function contractUnits(\n  units: Unit[] | null\n): [Unit[] | null, Converter] {\n  if (!units?.length) {\n    return [null, identity];\n  }\n  const [, converter] = expandUnits(units, nonScalarInversion, scalarInversion);\n  return [units, converter];\n}\n","import DeciNumber, { N } from '@decipad/number';\n\nconst dayInSeconds = 86400;\nconst monthInSeconds = N(dayInSeconds * 30);\n\n/**\n * Convert between base quantities that are almost equivalent\n */\nexport const impreciseConversions: ImpreciseConversions = {\n  month: {\n    second: monthInSeconds,\n  },\n  second: {\n    month: N(1).div(monthInSeconds),\n  },\n};\n\ninterface ImpreciseConversions {\n  [baseQuantity: string]: {\n    [desiredQuantity: string]: DeciNumber;\n  };\n}\n\nexport const getImpreciseConversionFactor = (from?: string, to?: string) => {\n  return from != null && to != null\n    ? impreciseConversions[from]?.[to]\n    : undefined;\n};\n","import DeciNumber from '@decipad/number';\nimport produce from 'immer';\nimport { getUnitByName } from './known-units';\nimport { expandUnits, contractUnits } from './expand';\nimport { Unit } from '../type/unit-type';\nimport { normalizeUnits, simplifyUnits } from '../type/units';\nimport { zip } from '../utils';\nimport { InferError } from '../type';\nimport { getImpreciseConversionFactor } from './imprecise-conversions';\n\nconst getBaseQuantity = (u: Unit) => getUnitByName(u.unit)?.baseQuantity;\n\ninterface ImprecisionOpts {\n  tolerateImprecision?: boolean;\n}\n\nfunction areQuantityUnitsCompatible(\n  a: Unit,\n  b: Unit,\n  { tolerateImprecision }: ImprecisionOpts = {}\n): boolean {\n  if (a.unit === b.unit && a.exp.equals(b.exp)) {\n    return true;\n  } else if (tolerateImprecision && a.exp.equals(b.exp)) {\n    const baseA = getBaseQuantity(a);\n    const baseB = getBaseQuantity(b);\n    return getImpreciseConversionFactor(baseA, baseB) != null;\n  } else {\n    return false;\n  }\n}\n\nfunction areQuantityUnitsReversible(\n  a: Unit[] | null,\n  b: Unit[] | null\n): boolean {\n  if (!a || !b) {\n    return false;\n  }\n\n  const sortedA = normalizeUnits(baseQuantityUnits(a) as Unit[]) as Unit[];\n  const sortedB = normalizeUnits(baseQuantityUnits(b) as Unit[]) as Unit[];\n\n  return (\n    sortedA.length === sortedB.length &&\n    zip(sortedA, sortedB).every(\n      ([a, b]) => a.unit === b.unit && a.exp.equals(b.exp.neg())\n    )\n  );\n}\n\nfunction baseQuantityUnits(units: Unit[] | null): Unit[] | null {\n  if (!units?.length) {\n    return units;\n  }\n\n  return simplifyUnits(\n    units.map(\n      produce((unit) => {\n        const knownUnit = getUnitByName(unit.unit);\n        unit.unit = knownUnit ? knownUnit.baseQuantity : unit.unit;\n      })\n    )\n  );\n}\n\nexport function areUnitsConvertible(\n  unitsA: Unit[],\n  unitsB: Unit[],\n  { tolerateImprecision }: ImprecisionOpts = {}\n): boolean {\n  const [sourceUnits] = expandUnits(unitsA);\n  const [targetUnits] = expandUnits(unitsB);\n  const baseQuantitySourceUnits = baseQuantityUnits(sourceUnits);\n  const baseQuantityTargetUnits = baseQuantityUnits(targetUnits);\n\n  if (\n    (baseQuantitySourceUnits ?? []).length !==\n    (baseQuantityTargetUnits ?? []).length\n  ) {\n    return false;\n  }\n\n  if (areQuantityUnitsReversible(sourceUnits, targetUnits)) {\n    return true;\n  }\n\n  const pendingMatchUnits = new Set(baseQuantityTargetUnits ?? []);\n  for (const baseQuantitySourceUnit of baseQuantitySourceUnits ?? []) {\n    for (const pendingMatchUnit of pendingMatchUnits) {\n      if (\n        areQuantityUnitsCompatible(baseQuantitySourceUnit, pendingMatchUnit, {\n          tolerateImprecision,\n        })\n      ) {\n        pendingMatchUnits.delete(pendingMatchUnit);\n        break;\n      }\n    }\n  }\n  return pendingMatchUnits.size === 0;\n}\n\nexport function toExpandedBaseQuantity(\n  n: DeciNumber,\n  sourceUnits: Unit[]\n): [Unit[] | null, DeciNumber] {\n  const [expandedUnits, convert] = expandUnits(sourceUnits);\n  return [expandedUnits, convert(n)];\n}\n\nexport function fromExpandedBaseQuantity(\n  n: DeciNumber,\n  targetUnits: Unit[]\n): [Unit[] | null, DeciNumber] {\n  const [, convert] = contractUnits(targetUnits);\n  return [targetUnits, convert(n)];\n}\n\nexport function convertBetweenUnits(\n  n: DeciNumber,\n  from: Unit[],\n  to: Unit[],\n  { tolerateImprecision }: ImprecisionOpts = {}\n): DeciNumber {\n  if (!areUnitsConvertible(from, to, { tolerateImprecision })) {\n    throw InferError.cannotConvertBetweenUnits(from, to);\n  }\n\n  if (tolerateImprecision && !areUnitsConvertible(from, to)) {\n    // It's not convertible precisely, let's go imprecise\n    return impreciselyConvertBetweenUnits(n, from, to);\n  }\n\n  const [expandedUnits, expandedN] = toExpandedBaseQuantity(n, from);\n  const [outputUnits, revertedN] = fromExpandedBaseQuantity(expandedN, to);\n\n  if (areQuantityUnitsReversible(expandedUnits, outputUnits)) {\n    const [, revertedNReversed] = fromExpandedBaseQuantity(\n      expandedN.inverse(),\n      to\n    );\n\n    return revertedNReversed;\n  }\n\n  return revertedN;\n}\n\nfunction impreciselyConvertBetweenUnits(\n  n: DeciNumber,\n  from: Unit[],\n  to: Unit[]\n) {\n  for (const fromU of from) {\n    for (const toU of to) {\n      const basicCompat = areQuantityUnitsCompatible(fromU, toU);\n      if (basicCompat) {\n        continue;\n      }\n\n      const fromBase = getUnitByName(fromU.unit);\n      const toBase = getUnitByName(toU.unit);\n\n      const conv =\n        fromBase?.baseQuantity &&\n        toBase?.baseQuantity &&\n        getImpreciseConversionFactor(\n          fromBase.baseQuantity,\n          toBase.baseQuantity\n        );\n      if (!conv) {\n        continue;\n      }\n\n      // Convert fromU to something compatible with toU\n      n = toBase.fromBaseQuantity(fromBase.toBaseQuantity(n).mul(conv));\n    }\n  }\n\n  return n;\n}\n","import { Type } from '../type';\nimport { enumerate } from '../utils';\nimport { getCardinality, IndexNames } from './common';\n\nconst isColumn = (arg: Type) => arg.cellType != null;\n\n/** Get all the indices in this column */\nconst getIndexNames = (t: Type): IndexNames => {\n  if (t.cellType) {\n    return [t.indexedBy, ...getIndexNames(t.cellType)];\n  } else {\n    return [];\n  }\n};\n\nconst findCommonIndexBetweenArguments = <T>(\n  argIndices: T[][],\n  highCardinality: boolean[],\n  exclude = new Set<T>()\n): T | null => {\n  const seen = new Set();\n\n  for (const [index, arg] of enumerate(argIndices)) {\n    if (!highCardinality[index]) continue;\n\n    for (const indexName of arg) {\n      if (indexName != null) {\n        if (seen.has(indexName) && !exclude.has(indexName)) {\n          return indexName;\n        }\n        seen.add(indexName);\n      }\n    }\n  }\n\n  return null;\n};\n\nconst findAnyIndex = <T>(\n  argIndices: (T | null)[][],\n  highCardinality: boolean[],\n  exclude = new Set<T>()\n) => {\n  for (const [index, arg] of enumerate(argIndices)) {\n    if (!highCardinality[index]) continue;\n\n    for (const indexName of arg) {\n      if (\n        typeof indexName === 'string' &&\n        !(!indexName.startsWith || indexName.startsWith('\\0')) &&\n        !exclude.has(indexName)\n      ) {\n        return indexName;\n      }\n    }\n  }\n\n  return null;\n};\n\n/**\n * Given a call with higher-dimension arguments, which dimension are we going\n * through first?\n *\n * This is based on indices, and on whether the function we're calling has\n * lower-dimension arguments than the arguments we have for it.\n *\n * Does not find all the reductions -- once this reduction is eliminated\n * (below in the recursion stack), further calls to getReductionPlan will find\n * where to reduce next.\n */\nexport const getReductionPlan = (\n  args: Type[],\n  wantedCardinalities: number[]\n): boolean[] => {\n  /** Given an arg index, does it have more dimensions than wantedCardinalities? */\n  const highCardinality = args.map(\n    (arg, i) => isColumn(arg) && getCardinality(arg) > wantedCardinalities[i]\n  );\n\n  const argIndices = args.map(getIndexNames);\n  const commonIndex = findCommonIndexBetweenArguments(\n    argIndices,\n    highCardinality\n  );\n  if (commonIndex) {\n    return argIndices.map(\n      (indices, i) => indices.includes(commonIndex) && highCardinality[i]\n    );\n  }\n\n  // Expand dims when any named index is spotted\n  const namedIndex = findAnyIndex(argIndices, highCardinality);\n  if (namedIndex) {\n    return argIndices.map(\n      (indexName, i) => indexName.includes(namedIndex) && highCardinality[i]\n    );\n  }\n\n  // Iterate all unnamed higher-cardinality columns at once\n  return highCardinality;\n};\n","import { enumerate } from '../utils';\nimport type { Type } from '../type';\n\nconst getDimensionId = (type: Type, index: number) => type.indexedBy ?? index;\n\nexport function groupTypesByDimension(...args: Type[][]) {\n  const allDimensions = new Map();\n  for (const arg of args) {\n    for (const [index, type] of enumerate(arg)) {\n      const dimensionId = getDimensionId(type, index);\n      const array = allDimensions.get(dimensionId) ?? [];\n\n      array.push(type);\n\n      allDimensions.set(dimensionId, array);\n    }\n  }\n  return [...allDimensions.values()];\n}\n","import * as Value from '../value';\nimport { createLazyOperation } from '../lazy';\nimport { build as t, Type } from '../type';\nimport {\n  arrayOfOnes,\n  deLinearizeType,\n  getCardinality,\n  linearizeType,\n  findInvalidCardinality,\n} from './common';\nimport { getReductionPlan } from './getReductionPlan';\nimport { groupTypesByDimension } from './multidimensional-utils';\n\n/**\n * Takes a function expects a certain cardinality in each argument,\n * and arguments that might have a higher cardinality. Higher cardinality\n * arguments are looped over, constructing a result that's higher dimension.\n *\n * Examples:\n * [a, b] calls the function with (a, b)\n * [[a], [b]] calls the function with (a, b)\n * [[a, b], [c, d]] calls the function with (a, c) and (b, d)\n * */\nexport const automapTypes = (\n  argTypes: Type[],\n  mapFn: (types: Type[]) => Type,\n  expectedCardinalities = arrayOfOnes(argTypes.length)\n): Type => {\n  const invalidCardinality = findInvalidCardinality(\n    argTypes,\n    expectedCardinalities\n  );\n\n  if (invalidCardinality) {\n    return invalidCardinality.expected(t.column(t.anything()));\n  }\n\n  if (expectedCardinalities.every((c) => c === 1)) {\n    // Expand dimensions by returning the union of all arguments' dims\n    const linearTypedArgs = argTypes.map((t) => linearizeType(t));\n    const scalarArgs = linearTypedArgs.map((types) => types[types.length - 1]);\n    const allDimensions = groupTypesByDimension(\n      ...linearTypedArgs.map((item) => item.slice(0, -1))\n    );\n\n    return deLinearizeType([\n      ...allDimensions.map((t) => t[0]),\n      mapFn(scalarArgs),\n    ]);\n  } else {\n    const whichToReduce = getReductionPlan(argTypes, expectedCardinalities);\n\n    if (whichToReduce.every((w) => w === false)) {\n      // Reduce nothing -- input dimensions are correct\n      return mapFn(argTypes);\n    } else {\n      return t.impossible(\n        'Operating upon multiple dimensional values is not supported yet'\n      );\n    }\n  }\n};\n\n// Extremely symmetrical with the above function\nexport const automapValues = (\n  argTypes: Type[],\n  argValues: Value.Value[],\n  mapFn: (values: Value.Value[], types: Type[]) => Value.Value,\n  expectedCardinalities = arrayOfOnes(argValues.length)\n): Value.Value => {\n  if (findInvalidCardinality(argTypes, expectedCardinalities)) {\n    throw new Error('panic: one or more cardinalities are too low');\n  }\n\n  if (expectedCardinalities.every((c) => c === 1)) {\n    const reducedArgTypes = hackilyReduceArgTypes(\n      argTypes,\n      expectedCardinalities\n    );\n    const mapFnAndTypes = (values: Value.Value[]) =>\n      mapFn(values, reducedArgTypes);\n\n    return createLazyOperation(mapFnAndTypes, argValues, argTypes);\n  } else {\n    const whichToReduce = getReductionPlan(argTypes, expectedCardinalities);\n\n    if (whichToReduce.every((doReduce) => doReduce === false)) {\n      // Reduce nothing -- input dimensions are correct\n      return mapFn(argValues, argTypes);\n    } else {\n      throw new Error(\n        'panic: Operating upon multiple dimensional values is not supported yet'\n      );\n    }\n  }\n};\n\n// Minor hack: use the automaptypes function to retrieve the arg types\n// Better solution: Make Hypercube type-aware and pass the types from there.\nconst hackilyReduceArgTypes = (\n  argTypes: Type[],\n  expectedCardinalities: number[]\n) => {\n  let argTypesLowerDims: Type[] = [];\n  automapTypes(\n    argTypes,\n    (argTypesFromMapTypes) => {\n      argTypesLowerDims = argTypesFromMapTypes;\n\n      // Just satisfying mapFn protocol, nothing to see here\n      return t.nothing();\n    },\n    expectedCardinalities\n  );\n\n  return argTypesLowerDims;\n};\n\nexport const automapTypesForReducer = (\n  argType: Type,\n  mapFn: (types: Type[]) => Type\n): Type => {\n  const invalidCardinality = findInvalidCardinality([argType], [2]);\n  if (invalidCardinality) {\n    return invalidCardinality.expected(t.column(t.anything()));\n  }\n\n  if (getCardinality(argType) === 2) {\n    return mapFn([argType]);\n  } else if (argType.columnSize != null) {\n    return t.column(\n      automapTypesForReducer(argType.reduced(), mapFn),\n      argType.columnSize,\n      argType.indexedBy\n    );\n  } else {\n    throw new Error('panic: unreachable');\n  }\n};\n\nexport const automapValuesForReducer = (\n  argType: Type,\n  argValue: Value.Value,\n  mapFn: (values: Value.Value[], types: Type[]) => Value.Value\n): Value.Value => {\n  if (findInvalidCardinality([argType], [2])) {\n    throw new Error('panic: cardinality is too low');\n  }\n\n  if (getCardinality(argType) === 2) {\n    return mapFn([argValue], [argType]);\n  } else {\n    const argCol = Value.getColumnLike(\n      argValue,\n      'reducers always take columnar arguments'\n    );\n    return Value.Column.fromValues(\n      argCol.values.map((v) =>\n        automapValuesForReducer(\n          argType.reduced(),\n          Value.getColumnLike(v),\n          mapFn\n        )\n      ),\n      argCol.dimensions.slice(1)\n    );\n  }\n};\n","import { getDefined } from '@decipad/utils';\nimport { SwappedHypercube } from '../lazy';\nimport { ColumnLike, getColumnLike } from '../value';\nimport { build as t, InferError, Type } from '../type';\nimport { chooseFirst, deLinearizeType, linearizeType } from './common';\n\nexport const dimSwapTypes = (dominantIndexName: string, type: Type) => {\n  return type.isColumn().mapType((matrix) => {\n    const types = linearizeType(matrix);\n    const scalarTip = getDefined(types.pop());\n\n    const dimIndex = types.findIndex((t) => t.indexedBy === dominantIndexName);\n    if (dimIndex === -1) {\n      return t.impossible(InferError.unknownCategory(dominantIndexName));\n    }\n\n    return deLinearizeType([...chooseFirst(dimIndex, types), scalarTip]);\n  });\n};\n\nexport const dimSwapValues = (\n  dominantIndexName: string,\n  type: Type,\n  value: ColumnLike\n) => {\n  const linear = linearizeType(type).slice(0, -1);\n\n  if (linear.length !== value.dimensions.length) {\n    throw new Error('panic: incorrect amount of dimensions');\n  }\n\n  const indexOfDominantDimension = linear.findIndex(\n    (t) => t.indexedBy === dominantIndexName\n  );\n\n  if (indexOfDominantDimension === 0) {\n    return value;\n  }\n\n  if (indexOfDominantDimension < 0) {\n    throw new Error('panic: dominant dimension not found');\n  }\n\n  const swapped = new SwappedHypercube(\n    getColumnLike(value),\n    indexOfDominantDimension\n  );\n\n  return swapped;\n};\n","import type { ColumnLike } from '../value';\n\n/**\n * Turns an output index (IE an index in a Interpreter.Result array) into an index of a label\n *\n * ColumnLike values which transform the order or arity of indices supply an .indexToLabelIndex method\n */\nexport function getLabelIndex(column: ColumnLike, index: number): number {\n  getPositive(index);\n\n  if (column.indexToLabelIndex) {\n    return getPositive(column.indexToLabelIndex(index));\n  }\n\n  return index;\n}\n\nconst getPositive = (index: number | null) => {\n  if (index == null || index < 0) {\n    throw new Error(`getLabelIndex got an invalid index ${index}`);\n  } else {\n    return index;\n  }\n};\n","import { getDefined } from '@decipad/utils';\nimport type { Type } from '..';\nimport { NumberValue, Value } from '../value';\nimport { expandUnits, contractUnits } from './expand';\nimport { zip } from '../utils';\nimport { automapValues } from '../dimtools';\n\nfunction autoconvertArgument(value: Value, type: Type): Value {\n  const typeLowestDims = type.reducedToLowest();\n  if (typeLowestDims.unit) {\n    const [, expander] = expandUnits(getDefined(typeLowestDims.unit));\n    return automapValues([type], [value], ([value]) => {\n      if (value instanceof NumberValue) {\n        return NumberValue.fromValue(expander(value.value));\n      }\n      return value;\n    });\n  }\n  return value;\n}\n\nexport function autoconvertResult(value: Value, type: Type): Value {\n  const typeLowestDims = type.reducedToLowest();\n  if (typeLowestDims.unit) {\n    const [, contractor] = contractUnits(getDefined(typeLowestDims.unit));\n    return automapValues([type], [value], ([value]) => {\n      if (value instanceof NumberValue) {\n        return NumberValue.fromValue(contractor(value.value));\n      }\n      return value;\n    });\n  }\n  return value;\n}\n\nexport function autoconvertArguments(values: Value[], types: Type[]): Value[] {\n  return zip(values, types).map(([value, type]) =>\n    autoconvertArgument(value, type)\n  );\n}\n","import DeciNumber, { N, ONE } from '@decipad/number';\nimport { getUnitByName, knowsUnit, unitUsesPrefixes } from '.';\nimport { Unit } from '..';\n\nconst abbreviatedPrefixes = {\n  q: 'quecto',\n  r: 'ronto',\n  y: 'yocto',\n  z: 'zepto',\n  a: 'atto',\n  f: 'femto',\n  p: 'pico',\n  n: 'nano',\n  : 'micro',\n  m: 'milli',\n  c: 'centi',\n  d: 'deci',\n  da: 'deca',\n  h: 'hecto',\n  k: 'kilo',\n  M: 'mega',\n  G: 'giga',\n  T: 'tera',\n  P: 'peta',\n  E: 'exa',\n  Z: 'zetta',\n  Y: 'yotta',\n  R: 'ronna',\n  Q: 'quetta',\n} as const;\n\ntype AbbreviatedPrefixes = typeof abbreviatedPrefixes;\n\ntype MultiplierPrefixToFraction = {\n  [P in AbbreviatedPrefixes[keyof AbbreviatedPrefixes]]: DeciNumber;\n};\nconst multiplierPrefixToFraction: MultiplierPrefixToFraction = {\n  quecto: N(1, 1_000_000_000_000_000_000_000_000_000_000n), // 1e-30,\n  ronto: N(1, 1_000_000_000_000_000_000_000_000_000n), // 1e-27,\n  yocto: N(1, 1_000_000_000_000_000_000_000_000n), // 1e-24,\n  zepto: N(1, 1_000_000_000_000_000_000_000n), // 1e-21,\n  atto: N(1, 1_000_000_000_000_000_000n), // 1e-18,\n  femto: N(1, 1_000_000_000_000_000n), // 1e-15,\n  pico: N(1, 1_000_000_000_000n), // 1e-12,\n  nano: N(1, 1_000_000_000n), // 1e-9,\n  micro: N(1, 1_000_000n), // 1e-6,\n  milli: N(1, 1_000n), // 1e-3,\n  centi: N(1, 100n), // 1e-2,\n  deci: N(1, 10n), // 1e-1,\n  deca: N(10n), // 1e1,\n  hecto: N(100n), // 1e2,\n  kilo: N(1_000n), // 1e3,\n  mega: N(1_000_000n), // 1e6,\n  giga: N(1_000_000_000n), // 1e9,\n  tera: N(1_000_000_000_000n), // 1e12,\n  peta: N(1_000_000_000_000_000n), // 1e15,\n  exa: N(1_000_000_000_000_000_000n), // 1e18,\n  zetta: N(1_000_000_000_000_000_000_000n), // 1e21,\n  yotta: N(1_000_000_000_000_000_000_000_000n), // 1e24,\n  ronna: N(1_000_000_000_000_000_000_000_000_000n), // 1e27,\n  quetta: N(1_000_000_000_000_000_000_000_000_000_000n), // 1e30,\n};\n\nconst multiplierPrefixes = Object.keys(multiplierPrefixToFraction);\n\nfunction trimPrefix(unitName: string): [DeciNumber, string] {\n  for (const fullPrefix of multiplierPrefixes) {\n    if (unitName.startsWith(fullPrefix)) {\n      return [\n        multiplierPrefixToFraction[\n          fullPrefix as keyof typeof multiplierPrefixToFraction\n        ],\n        unitName.substring(fullPrefix.length),\n      ];\n    }\n  }\n  if (unitName.startsWith('da')) {\n    return [multiplierPrefixToFraction.deca, unitName.slice(2)];\n  } else if (unitName[0] in abbreviatedPrefixes) {\n    const prefix =\n      abbreviatedPrefixes[unitName[0] as keyof typeof abbreviatedPrefixes];\n    return [\n      multiplierPrefixToFraction[\n        prefix as keyof typeof multiplierPrefixToFraction\n      ],\n      unitName.slice(1),\n    ];\n  }\n  return [ONE, unitName];\n}\n\nexport function parseUnit(unitString: string): Unit {\n  const knownUnit = getUnitByName(unitString);\n  if (knownUnit) {\n    return {\n      unit: unitString,\n      exp: ONE,\n      multiplier: ONE,\n      known: true,\n      baseQuantity: knownUnit.baseQuantity,\n      baseSuperQuantity: knownUnit.superBaseQuantity ?? knownUnit.baseQuantity,\n    };\n  } else {\n    const trimResult = trimPrefix(unitString);\n    let multiplier = trimResult[0];\n    let name = trimResult[1];\n    const exponent = 1;\n    const known = knowsUnit(name);\n\n    const smallPrefix = unitString.length - name.length < 3;\n\n    if (!known && smallPrefix) {\n      name = unitString;\n      multiplier = ONE;\n    }\n    if (!unitUsesPrefixes(name)) {\n      const matchesExponent = name.match(/(.*)([0-9])+$/);\n      if (matchesExponent) {\n        const [, name, exponent] = matchesExponent;\n\n        return {\n          unit: name,\n          exp: N(exponent),\n          multiplier,\n          known,\n        };\n      } else {\n        //\n        // this is a user invented unit that collided?\n        // or is this an error?\n        //\n        // cause microkph is not really a thing\n        //\n        // todo: code review\n        //\n      }\n    }\n\n    const ret = {\n      unit: name,\n      exp: N(exponent),\n      multiplier,\n      known,\n    };\n\n    if (known) {\n      const maybeACurrency = getUnitByName(name);\n      if (maybeACurrency && maybeACurrency.superBaseQuantity === 'currency') {\n        return { ...ret, baseSuperQuantity: 'currency' };\n      } else {\n        return ret;\n      }\n    }\n\n    return ret;\n  }\n}\n","import DeciNumber, { N, ZERO } from '@decipad/number';\nimport { lenientZip } from '@decipad/utils';\nimport { produce } from 'immer';\nimport type { Type } from '..';\nimport pluralize from '../langPluralize';\nimport {\n  areUnitsCompatible,\n  expandUnits,\n  getUnitByName,\n  isKnownSymbol,\n} from '../units';\nimport { getDefined } from '../utils';\nimport type { Unit } from './unit-type';\nimport { InferError } from './InferError';\nimport { propagatePercentage } from './percentages';\n\nexport const timeUnits = new Set([\n  'millennium',\n  'millenniums',\n  'millennia',\n  'century',\n  'centuries',\n  'decade',\n  'decades',\n  'year',\n  'years',\n  'quarter',\n  'quarters',\n  'month',\n  'months',\n  'day',\n  'days',\n  'hour',\n  'hours',\n  'minute',\n  'minutes',\n  'second',\n  'seconds',\n  'millisecond',\n  'milliseconds',\n]);\n\nexport const pluralizeUnit = (\n  baseUnit: Unit,\n  value: bigint | number = 2n\n): Unit => {\n  const { unit } = baseUnit;\n  if (isKnownSymbol(unit)) {\n    return baseUnit;\n  }\n  const pluralUnit = pluralize(unit, value);\n  if (pluralUnit === unit) {\n    return baseUnit;\n  }\n  return produce(baseUnit, (u) => {\n    u.unit = pluralUnit;\n  });\n};\n\nconst areUnitQualitiesCompatible = (\n  quality1?: string,\n  quality2?: string\n): boolean => {\n  return (quality1 == null && quality2 == null) || quality1 === quality2;\n};\n\nexport const matchUnitArrays = (\n  units1?: Unit[] | null,\n  units2?: Unit[] | null\n): boolean => {\n  const [expandedUnit1] = expandUnits(units1);\n  const expandedUnits1 = expandedUnit1 ?? [];\n  const [expandedUnit2] = expandUnits(units2);\n  const expandedUnits2 = expandedUnit2 ?? [];\n  if (expandedUnits1.length !== expandedUnits2.length) {\n    return false;\n  }\n\n  const pendingMatch = Array.from(expandedUnits2);\n  for (const unit of expandedUnits1) {\n    let match: Unit | undefined;\n    for (const matchingUnit of pendingMatch) {\n      if (\n        unit.exp.compare(matchingUnit.exp) === 0 &&\n        areUnitsCompatible(unit.unit, matchingUnit.unit)\n      ) {\n        match = matchingUnit;\n        break;\n      }\n    }\n    if (match) {\n      pendingMatch.splice(pendingMatch.indexOf(match), 1);\n    } else {\n      return false;\n    }\n  }\n\n  return pendingMatch.length === 0;\n};\n\nexport const matchUnitArraysForColumn = (\n  _units1?: Unit[] | null,\n  _units2?: Unit[] | null\n) => {\n  const units1 = normalizeUnits(_units1) ?? [];\n  const units2 = normalizeUnits(_units2) ?? [];\n\n  if ((units1.length === 0) !== (units2.length === 0)) {\n    return true;\n  }\n\n  return lenientZip(units1, units2).every(([left, right]) => {\n    if (left == null || right == null) {\n      return false;\n    }\n\n    return (\n      left.unit === right.unit &&\n      left.multiplier.compare(right.multiplier) === 0 &&\n      left.exp.compare(right.exp) === 0\n    );\n  });\n};\n\nexport const removeSingleUnitless = (a: Type, b: Type) => {\n  const bothNumbers = a.type === 'number' && b.type === 'number';\n  const oneIsUnitless = (a.unit == null) !== (b.unit == null);\n\n  if (bothNumbers && oneIsUnitless) {\n    return getDefined(a.unit ?? b.unit);\n  } else {\n    return null;\n  }\n};\n\nexport const propagateTypeUnits = (me: Type, other: Type) => {\n  me = propagatePercentage(me, other);\n\n  me = produce(me, (me) => {\n    me.numberError ??= other.numberError;\n  });\n\n  const matchingUnits = matchUnitArrays(me.unit, other.unit);\n  if (matchingUnits) {\n    return me;\n  }\n\n  const onlyOneHasAUnit = removeSingleUnitless(me, other);\n  if (onlyOneHasAUnit) {\n    return setUnit(me, onlyOneHasAUnit);\n  }\n\n  return me.withErrorCause(InferError.expectedUnit(other.unit, me.unit));\n};\n\nexport const simplifyUnits = (units: Unit[]): Unit[] =>\n  units\n    .map((u) => pluralizeUnit(u))\n    .reduce<Unit[]>((units, unit) => {\n      const matchingUnitIndex = units.findIndex(\n        (candidate) =>\n          unit.unit === candidate.unit &&\n          areUnitQualitiesCompatible(unit.quality, candidate.quality)\n      );\n      if (matchingUnitIndex >= 0) {\n        const matchingUnit = units[matchingUnitIndex];\n        units[matchingUnitIndex] = produce(matchingUnit, (match) => {\n          match.exp = match.exp.add(unit.exp);\n          //\n          // match.multiplier *= unit.multiplier ** Number(unit.exp);\n          //\n          match.multiplier = match.multiplier.mul(\n            unit.multiplier.pow(unit.exp)\n          );\n        });\n        return units;\n      } else {\n        return [...units, unit];\n      }\n    }, [])\n    .filter((unit) => N(unit.exp).compare(ZERO) !== 0) as Unit[];\n\nexport const normalizeUnitName = (unit: Unit): Unit => {\n  const symbolUnit = getUnitByName(unit.unit);\n  if (symbolUnit) {\n    return produce(unit, (unit) => {\n      unit.unit = symbolUnit.name;\n    });\n  }\n  return unit;\n};\n\nexport const normalizeUnitNames = (units: Unit[]): Unit[] => {\n  return units.map(normalizeUnitName);\n};\n\nconst byUnitName = (a: Unit, b: Unit): number => {\n  if (a.unit > b.unit) {\n    return 1;\n  } else if (a.unit < b.unit) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nexport const normalizeUnits = (\n  units?: Unit[] | null,\n  { mult = false }: { mult?: boolean } = {}\n): Unit[] | null => {\n  if (!units?.length) {\n    return null;\n  }\n\n  const simplified = simplifyUnits(units);\n\n  if (simplified.length === 0) {\n    return null;\n  } else if (mult) {\n    return simplified;\n  } else {\n    return simplified.sort(byUnitName);\n  }\n};\n\nexport const setExponent = produce((unit: Unit, newExponent: DeciNumber) => {\n  unit.exp = newExponent;\n});\n\nexport const inverseExponent = (unit: Unit) =>\n  setExponent(unit, unit.exp.neg());\n\nexport const combineUnits = (\n  myUnitsObj: Unit[] | null,\n  theirUnitsObj: Unit[] | null,\n  { mult = false }: { mult?: boolean } = {}\n): Unit[] | null => {\n  const myUnits = normalizeUnits(myUnitsObj, { mult }) ?? [];\n  const theirUnits = normalizeUnits(theirUnitsObj, { mult }) ?? [];\n\n  const outputUnits: Unit[] = mult ? [...myUnits] : [...theirUnits];\n  const sourceUnits: Unit[] = mult ? theirUnits : myUnits;\n\n  // Combine their units in\n  for (const thisUnit of sourceUnits) {\n    const existingUnitIndex = outputUnits.findIndex((u) => {\n      return (\n        areUnitQualitiesCompatible(u.quality, thisUnit.quality) &&\n        areUnitsCompatible(u.unit, thisUnit.unit)\n      );\n    });\n    if (existingUnitIndex >= 0) {\n      outputUnits[existingUnitIndex] = produce(\n        outputUnits[existingUnitIndex],\n        (inversed) => {\n          inversed.exp = inversed.exp.add(thisUnit.exp);\n        }\n      );\n    } else {\n      outputUnits.push(thisUnit);\n    }\n  }\n\n  return normalizeUnits(outputUnits, { mult });\n};\n\nexport const multiplyExponent = (myUnits: Unit[], by: number): Unit[] | null =>\n  normalizeUnits(\n    produce(myUnits, (myUnits) => {\n      for (const u of myUnits) {\n        try {\n          u.exp = u.exp.mul(N(by));\n        } catch (err) {\n          const error = new Error(\n            `error multiplying ${u.exp} by ${by}: ${(err as Error).message}`\n          );\n          throw error;\n        }\n      }\n    })\n  );\n\nexport const setUnit = (t: Type, newUnit: Unit[] | null) =>\n  produce(t, (t) => {\n    if (t.type === 'number') {\n      t.unit = newUnit;\n    }\n  });\n","import { dequal } from 'dequal';\nimport { PrimitiveTypeName, Type } from '.';\nimport type { Time } from '..';\nimport { zip } from '../utils';\nimport * as t from './build';\nimport { InferError } from './InferError';\nimport { propagatePercentage } from './percentages';\nimport { Unit } from './unit-type';\nimport {\n  combineUnits,\n  inverseExponent,\n  multiplyExponent,\n  setUnit,\n  timeUnits,\n  propagateTypeUnits,\n} from './units';\n\nconst checker = <Args extends unknown[]>(\n  fn: (...args: Args) => Type\n): typeof fn => {\n  return function typeChecker(...args: Args) {\n    const errored = args.find(\n      (a) => a instanceof Type && a.errorCause != null\n    ) as Type | undefined;\n\n    return errored ?? fn(...args);\n  };\n};\n\nexport const isScalar = checker((me: Type, type: PrimitiveTypeName) => {\n  if (type === me.type) {\n    return me;\n  } else {\n    return me.expected(t[type]());\n  }\n});\n\nexport const sameScalarnessAs = checker((me: Type, other: Type) => {\n  const meScalar = me.type != null;\n  const theyScalar = me.type != null;\n\n  if (meScalar && theyScalar) {\n    const matchingTypes = me.type === other.type;\n    if (!matchingTypes) {\n      return me.expected(other);\n    }\n\n    if (me.type === 'number') {\n      return propagateTypeUnits(me, other);\n    }\n\n    return me;\n  } else if (!meScalar && !theyScalar) {\n    return me;\n  } else {\n    return me.expected(other);\n  }\n});\n\nexport const sharePercentage = checker((me: Type, other: Type) => {\n  if (me.type === 'number' && other.type === 'number') {\n    return propagatePercentage(me, other);\n  }\n  return me;\n});\n\nexport const isColumn = checker((me: Type) => {\n  if (me.columnSize != null) {\n    return me;\n  } else {\n    return me.expected('column');\n  }\n});\n\nexport const isTable = checker((me: Type) => {\n  if (me.columnNames != null && me.columnTypes != null) {\n    return me;\n  } else {\n    return me.expected('table');\n  }\n});\n\nexport const isTableOrRow = checker((me: Type) => {\n  if (\n    (me.columnNames != null && me.columnTypes != null) ||\n    (me.rowCellTypes != null && me.rowCellNames != null)\n  ) {\n    return me;\n  } else {\n    return me.expected('table or row');\n  }\n});\n\nexport const reduced = checker((me: Type) => {\n  if (me.cellType != null) {\n    return me.cellType;\n  } else {\n    return me.expected('column');\n  }\n});\n\nexport const reducedToLowest = checker((me: Type) => {\n  while (me.cellType) {\n    me = me.cellType;\n  }\n  return me;\n});\n\nexport const withMinimumColumnCount = checker(\n  (me: Type, minColumns: number) => {\n    const columnCount = (me.columnTypes ?? []).length;\n    if (columnCount >= minColumns) {\n      return me;\n    } else {\n      return me.withErrorCause(\n        `Expected table with at least ${minColumns} column${\n          minColumns === 1 ? '' : 's'\n        }`\n      );\n    }\n  }\n);\n\nexport const withAtParentIndex = checker((me: Type) => {\n  if (me.atParentIndex != null) {\n    return me;\n  } else {\n    return me.withErrorCause(\n      InferError.expectedTableAndAssociatedColumn(null, me)\n    );\n  }\n});\n\nexport const sameColumnessAs = checker((me: Type, other: Type) => {\n  if (me.columnSize != null && other.columnSize != null) {\n    return me\n      .reduced()\n      .sameAs(other.reduced())\n      .mapType(() => me);\n  } else if (me.columnSize == null && other.columnSize == null) {\n    return me;\n  } else {\n    return me.expected(other);\n  }\n});\n\nexport const isRange = checker((me: Type) => {\n  if (me.rangeOf != null) {\n    return me;\n  } else {\n    return me.expected('range');\n  }\n});\n\nexport const getRangeOf = checker((me: Type) => {\n  return me.rangeOf ?? me.expected('range');\n});\n\nexport const sameRangenessAs = checker((me: Type, other: Type) => {\n  if (me.rangeOf != null && other.rangeOf != null) {\n    return me.rangeOf.sameAs(other.rangeOf).mapType(() => me);\n  } else if (me.rangeOf == null && other.rangeOf == null) {\n    return me;\n  } else {\n    return me.expected(other);\n  }\n});\n\nexport const sameTablenessAs = checker((me: Type, other: Type) => {\n  if (me.columnTypes != null && other.columnTypes != null) {\n    if (\n      dequal(me.columnNames, other.columnNames) &&\n      zip(me.columnTypes, other.columnTypes).every(\n        ([myT, otherT]) => myT.sameAs(otherT).errorCause == null\n      )\n    ) {\n      return me;\n    } else {\n      return me.expected(other);\n    }\n  } else if (me.columnTypes == null && other.columnTypes == null) {\n    return me;\n  } else {\n    return me.expected(other);\n  }\n});\n\nexport const isTimeQuantity = checker((me: Type) => {\n  if (\n    me.unit == null ||\n    me.unit.length === 0 ||\n    !me.unit.every((unit) => timeUnits.has(unit.unit))\n  ) {\n    return me.expected('time quantity');\n  }\n  return me;\n});\n\nexport const isDate = checker((me: Type, specificity?: Time.Specificity) => {\n  if (me.date != null && (specificity == null || me.date === specificity)) {\n    return me;\n  } else {\n    return me.expected(specificity ? t.date(specificity) : 'date');\n  }\n});\n\nexport const sameDatenessAs = checker((me: Type, other: Type) => {\n  if (me.date === other.date) {\n    return me;\n  } else {\n    return me.expected(other);\n  }\n});\n\nexport const multiplyUnit = checker((me: Type, withUnits: Unit[] | null) => {\n  return setUnit(me, combineUnits(me.unit, withUnits, { mult: true }));\n});\n\nexport const divideUnit = checker(\n  (me: Type, divideBy: Unit[] | number | null) => {\n    if (typeof divideBy === 'number') {\n      const multiplyBy = 1 / divideBy;\n      if (me.unit) {\n        return setUnit(me, multiplyExponent(me.unit, multiplyBy));\n      }\n      return me;\n    } else {\n      const invTheirUnits = divideBy?.map((u) => inverseExponent(u)) ?? [];\n      const combinedUnits = combineUnits(me.unit, invTheirUnits);\n      return setUnit(me, combinedUnits);\n    }\n  }\n);\n\nexport const sameAs = checker((me: Type, other: Type) => {\n  const ensurers = [\n    sameScalarnessAs,\n    sameColumnessAs,\n    sameDatenessAs,\n    sameRangenessAs,\n    sameTablenessAs,\n  ];\n\n  let type = me;\n  for (const cmp of ensurers) {\n    type = cmp(type, other);\n    if (type.errorCause) return type;\n  }\n\n  return type;\n});\n\nexport const isPrimitive = checker((me: Type) => {\n  const anyOf = Type.either(\n    me.isDate(),\n    me.isScalar('string'),\n    me.isScalar('number'),\n    me.isScalar('boolean')\n  );\n\n  if (anyOf.errorCause) {\n    return t.impossible(InferError.expectedPrimitive(me));\n  } else {\n    return me;\n  }\n});\n","import { immerable, produce } from 'immer';\nimport type { AST, Time } from '..';\nimport * as t from './build';\nimport {\n  divideUnit,\n  getRangeOf,\n  isColumn,\n  isDate,\n  isPrimitive,\n  isRange,\n  isScalar,\n  isTable,\n  isTableOrRow,\n  isTimeQuantity,\n  multiplyUnit,\n  reduced,\n  reducedToLowest,\n  sameAs,\n  sharePercentage,\n  withAtParentIndex,\n  withMinimumColumnCount,\n} from './checks';\nimport { InferError } from './InferError';\nimport type { Unit } from './unit-type';\n\nexport type PrimitiveTypeName = 'number' | 'string' | 'boolean';\n\ntype CombineArg = Type | ((t: Type) => Type);\n\nexport class Type {\n  [immerable] = true;\n\n  node: AST.Node | null = null;\n  errorCause: InferError | null = null;\n\n  type: PrimitiveTypeName | null = null;\n  unit: Unit[] | null = null;\n  numberFormat: AST.NumberFormat | null = null;\n  numberError: 'month-day-conversion' | null = null;\n\n  date: Time.Specificity | null = null;\n\n  rangeOf: Type | null = null;\n\n  // Indices (columns, tables, imported tables)\n  indexName: string | null = null;\n  indexedBy: string | null = null;\n\n  // Column\n  cellType: Type | null = null;\n  columnSize: number | 'unknown' | null = null;\n  atParentIndex: number | null = null;\n\n  // Table\n  columnTypes: Type[] | null = null;\n  columnNames: string[] | null = null;\n\n  rowIndexName: string | null = null;\n  rowCellTypes: Type[] | null = null;\n  rowCellNames: string[] | null = null;\n\n  // Functions are impossible types with functionness = true\n  functionness = false;\n  functionName: string | undefined;\n  functionArgCount: number | undefined;\n\n  // Set to true when no data will be present. Used for empty blocks\n  nothingness = false;\n\n  // Set to true when it can be anything. Used for narrowing when you don't care about the insides of composite types\n  anythingness = false;\n\n  // Associates the type to a symbol\n  symbol: string | null = null;\n\n  // Return the first type that has an error, or the last one.\n  static combine(initialType: Type, ...types: CombineArg[]): Type {\n    let lastNonErrorType = initialType;\n    if (lastNonErrorType.errorCause != null) {\n      return lastNonErrorType;\n    }\n    for (const type of types) {\n      const resultingType =\n        typeof type === 'function' ? lastNonErrorType.mapType(type) : type;\n      if (resultingType.errorCause != null) {\n        return resultingType;\n      }\n      lastNonErrorType = resultingType;\n    }\n\n    return lastNonErrorType;\n  }\n\n  /** Return the first non-error type */\n  static either(...types: Type[]): Type {\n    const notErrored = types.find((t) => !t.errorCause);\n    return notErrored ?? types[0];\n  }\n\n  mapType(fn: (t: Type) => Type) {\n    if (this.errorCause) {\n      return this;\n    } else {\n      return fn(this);\n    }\n  }\n\n  inNode(node: AST.Node) {\n    return produce(this, (newType) => {\n      newType.node = node;\n    });\n  }\n\n  withErrorCause(error: InferError | string): Type {\n    const { node, errorCause } = this;\n\n    if (errorCause) {\n      return this;\n    } else {\n      return t.impossible(error, node);\n    }\n  }\n\n  expected(expected: Type | string): Type {\n    return this.mapType(() =>\n      this.withErrorCause(InferError.expectedButGot(expected, this))\n    );\n  }\n\n  // Type assertions -- these return a new type possibly with an error\n  sameAs(other: Type): Type {\n    return sameAs(this, other);\n  }\n\n  isScalar(type: PrimitiveTypeName): Type {\n    return isScalar(this, type);\n  }\n\n  isColumn(): Type {\n    return isColumn(this);\n  }\n\n  isTable(): Type {\n    return isTable(this);\n  }\n\n  isTableOrRow(): Type {\n    return isTableOrRow(this);\n  }\n\n  reduced(): Type {\n    return reduced(this);\n  }\n\n  reducedToLowest(): Type {\n    return reducedToLowest(this);\n  }\n\n  withAtParentIndex(): Type {\n    return withAtParentIndex(this);\n  }\n\n  withMinimumColumnCount(colCount = 1): Type {\n    return withMinimumColumnCount(this, colCount);\n  }\n\n  isPrimitive(): Type {\n    return isPrimitive(this);\n  }\n\n  isRange(): Type {\n    return isRange(this);\n  }\n\n  getRangeOf(): Type {\n    return getRangeOf(this);\n  }\n\n  isTimeQuantity(): Type {\n    return isTimeQuantity(this);\n  }\n\n  isDate(specificity?: Time.Specificity): Type {\n    return isDate(this, specificity);\n  }\n\n  multiplyUnit(withUnits: Unit[] | null): Type {\n    return multiplyUnit(this, withUnits);\n  }\n\n  divideUnit(divideBy: Unit[] | number | null): Type {\n    return divideUnit(this, divideBy);\n  }\n\n  sharePercentage(other: Type) {\n    return sharePercentage(this, other);\n  }\n}\n","import DeciNumber, { ONE } from '@decipad/number';\nimport type { Unit } from '.';\n\nfunction multipliersFor(units: Unit[]): DeciNumber {\n  let acc = ONE;\n  for (const unit of units) {\n    acc = acc.mul(unit.multiplier.pow(unit.exp));\n  }\n\n  return acc;\n}\n\nexport function convertToMultiplierUnit(\n  n: DeciNumber,\n  units?: Unit[] | null\n): DeciNumber {\n  if (!units) {\n    return n;\n  }\n  const multiplier = multipliersFor(units);\n  return n.div(multiplier);\n}\n","import produce from 'immer';\nimport type { SerializedType } from './SerializedType';\n\nexport function traverseType(\n  givenType: SerializedType,\n  fn: (type: SerializedType) => SerializedType\n): SerializedType {\n  const type = fn(givenType);\n\n  switch (type.kind) {\n    case 'nothing':\n    case 'anything':\n    case 'type-error':\n    case 'boolean':\n    case 'string':\n    case 'number':\n    case 'date': {\n      return type;\n    }\n\n    case 'range': {\n      const { rangeOf } = type;\n      return produce(type, (t) => {\n        t.rangeOf = traverseType(rangeOf, fn);\n      });\n    }\n\n    case 'column': {\n      const { cellType } = type;\n      return produce(type, (t) => {\n        t.cellType = traverseType(cellType, fn);\n      });\n    }\n\n    case 'table':\n    case 'row':\n    case 'function': {\n      throw new Error(`cannot traverse type ${type.kind}`);\n    }\n  }\n}\n","import { getDefined, zip } from '@decipad/utils';\nimport produce from 'immer';\nimport { deserializeType, SerializedTypes, serializeType, Type } from '.';\nimport { equalOrUndefined } from '../utils';\nimport { onlyOneIsPercentage } from './percentages';\nimport { traverseType } from './traverseType';\nimport { propagateTypeUnits } from './units';\n\nexport interface FunctionSignature {\n  expectedArgs: Type[];\n  returnType: Type;\n}\n\nexport function narrowTypes(\n  t1: Type,\n  t2: Type,\n  mutSymbols = new Map<string, Type>(),\n  errorPath: ('column' | 'range')[] = []\n): Type {\n  if (t1.errorCause) return t1;\n  if (t2.errorCause) return t2;\n\n  // Treat generic symbols\n  if (t1.symbol) {\n    if (mutSymbols.has(t1.symbol)) {\n      t1 = getDefined(mutSymbols.get(t1.symbol));\n    } else {\n      mutSymbols.set(t1.symbol, t2);\n    }\n  }\n\n  const s1 = serializeType(t1);\n  const s2UnknownType = serializeType(t2);\n\n  if (s1.kind === 'anything') return t2;\n  if (s2UnknownType.kind === 'anything') return t1;\n\n  const ret = (() => {\n    if (s1.kind !== s2UnknownType.kind) {\n      return t2.expected(s1.kind);\n    }\n\n    switch (s1.kind) {\n      case 'nothing':\n      case 'boolean':\n      case 'type-error':\n      case 'string': {\n        return t1;\n      }\n\n      case 'number': {\n        if (onlyOneIsPercentage(t1.numberFormat, t2.numberFormat)) {\n          return produce(t1, (number) => {\n            number.numberFormat = null;\n          });\n        }\n        return propagateTypeUnits(t1, t2);\n      }\n\n      case 'date': {\n        const s2 = s2UnknownType as SerializedTypes.Date;\n\n        if (s1.date !== s2.date) {\n          return t2.expected(s1.date);\n        }\n\n        return t1;\n      }\n\n      case 'range': {\n        const narrowedContents = narrowTypes(\n          getDefined(t1.rangeOf),\n          getDefined(t2.rangeOf),\n          mutSymbols,\n          [...errorPath, 'range']\n        );\n\n        if (narrowedContents.errorCause) {\n          return narrowedContents;\n        }\n\n        return produce(t1, (type) => {\n          type.rangeOf = narrowedContents;\n        });\n      }\n\n      case 'column': {\n        const s2 = s2UnknownType as SerializedTypes.Column;\n\n        const narrowedCell = narrowTypes(\n          getDefined(t1.cellType),\n          getDefined(t2.cellType),\n          mutSymbols,\n          [...errorPath, 'column']\n        );\n\n        if (narrowedCell.errorCause) {\n          return narrowedCell;\n        }\n\n        if (!equalOrUndefined(s1.indexedBy, s2.indexedBy)) {\n          return t1.withErrorCause('mismatched index name');\n        }\n\n        return produce(t1, (type) => {\n          type.columnSize =\n            s1.columnSize === 'unknown' ? s2.columnSize : s1.columnSize;\n          type.cellType = narrowedCell;\n        });\n      }\n\n      case 'table': {\n        throw new Error('tables cannot be narrowed');\n      }\n\n      case 'row': {\n        throw new Error('rows cannot be narrowed');\n      }\n\n      case 'function': {\n        throw new Error('functions cannot be narrowed');\n      }\n    }\n  })();\n\n  // Trace the path to the error\n  return produce(ret, (type) => {\n    if (type.errorCause && !type.errorCause.pathToError.length) {\n      type.errorCause.pathToError = errorPath;\n    }\n  });\n}\n\ninterface NarrowFunctionCallArgs {\n  args: Type[];\n  expectedArgs: Type[];\n  returnType: Type;\n}\n\nexport function narrowFunctionCall({\n  args,\n  expectedArgs,\n  returnType,\n}: NarrowFunctionCallArgs): Type {\n  const genericSymbols = new Map<string, Type>();\n\n  const actualArgs = zip(args, expectedArgs).map(([arg, expected]) =>\n    narrowTypes(expected, arg, genericSymbols)\n  );\n\n  const error = actualArgs.find((t) => t.errorCause);\n\n  if (error) {\n    return error;\n  }\n\n  const returnTypeWithSymbols = traverseType(\n    serializeType(returnType),\n    (type) => {\n      if (type.symbol) {\n        const ret = getDefined(genericSymbols.get(type.symbol));\n        const typeWithoutSymbol = produce(ret, (t) => {\n          t.symbol = null;\n        });\n        return serializeType(typeWithoutSymbol);\n      }\n      return type;\n    }\n  );\n\n  return deserializeType(returnTypeWithSymbols);\n}\n","import produce from 'immer';\nimport moo from 'moo';\nimport { getDefined, thro } from '@decipad/utils';\n\nimport { build as t, Type } from '.';\nimport type { FunctionSignature } from './narrowing';\n\nconst tokens = moo.compile({\n  lt: '<',\n  gt: '>',\n  comma: ',',\n  colon: ':',\n  arrow: '->',\n  number: /\\d+/,\n  word: /\\w+/,\n  WS: { match: /\\s+/, lineBreaks: true },\n});\n\nexport const parseType = (typeSource: string) => {\n  const tokenStream = tokenize(typeSource);\n\n  const parsed = parseTypeInner(tokenStream);\n\n  tokenStream.assertAllConsumed();\n\n  return parsed;\n};\n\nexport const parseFunctionSignature = (sig: string): FunctionSignature => {\n  const tokenStream = tokenize(sig);\n\n  const expectedArgs = [parseTypeInner(tokenStream)];\n\n  while (tokenStream.token()?.type === 'comma') {\n    tokenStream.next();\n    expectedArgs.push(parseTypeInner(tokenStream));\n  }\n\n  tokenStream.ensure('arrow');\n\n  const returnType = parseTypeInner(tokenStream);\n\n  tokenStream.assertAllConsumed();\n\n  return { expectedArgs, returnType };\n};\n\ninterface TokenStream {\n  token: () => moo.Token | undefined;\n  next: () => moo.Token | undefined;\n  error: () => Error;\n  ensure: (type: string | undefined) => moo.Token | undefined;\n  assertAllConsumed: () => void;\n}\n\nfunction parseTypeInner({ token, next, error, ensure }: TokenStream) {\n  const parseLiteralNumber = (): number | 'unknown' => {\n    const { type, text } = next() ?? thro(error());\n\n    if (type === 'number') {\n      return Number(text);\n    }\n\n    if (text === 'unknown') {\n      return 'unknown';\n    }\n\n    throw error();\n  };\n\n  const maybeSymbol = (type: Type): Type => {\n    const tok = token();\n    if (!tok) {\n      return type;\n    }\n\n    if (tok.type === 'colon') {\n      next();\n      const word = ensure('word');\n      return produce(type, (type) => {\n        type.symbol = getDefined(word).text;\n      });\n    }\n\n    return type;\n  };\n\n  const parseWord = (): Type => {\n    const { text } = next() ?? thro('unexpected end');\n\n    if (text === 'string' || text === 'number' || text === 'boolean') {\n      return maybeSymbol(t[text]());\n    }\n\n    if (text === 'column') {\n      ensure('lt');\n      const cellType = parseWord();\n      let columnSize: number | 'unknown' = 'unknown';\n\n      if (token()?.type === 'comma') {\n        next();\n        columnSize = parseLiteralNumber();\n      }\n      const col = t.column(cellType, columnSize);\n      ensure('gt');\n      return maybeSymbol(col);\n    }\n\n    if (text === 'range') {\n      ensure('lt');\n      const rangeOf = parseWord();\n      ensure('gt');\n      return maybeSymbol(t.range(rangeOf));\n    }\n\n    if (text === 'anything') {\n      return maybeSymbol(t.anything());\n    }\n\n    if (text === 'nothing') {\n      return maybeSymbol(t.nothing());\n    }\n\n    if (/^[A-Z]+$/.test(text)) {\n      // \"A\" is shorthand for \"anything:A\"\n      return produce(t.anything(), (type) => {\n        type.symbol = text;\n      });\n    }\n\n    throw error();\n  };\n\n  return parseWord();\n}\n\nfunction tokenize(typeSource: string): TokenStream {\n  tokens.reset(typeSource);\n\n  let curToken = tokens.next();\n\n  const next = () => {\n    const consumed = curToken;\n\n    do {\n      curToken = tokens.next();\n    } while (curToken?.type === 'WS');\n\n    return consumed;\n  };\n\n  const ensure = (type: string | undefined) => {\n    if (curToken?.type !== type) {\n      throw error(`expected ${type}, got `);\n    }\n    return next();\n  };\n\n  const error = (message = 'unexpected ') => {\n    const tok = curToken ? `\"${curToken.text}\"` : '<end>';\n\n    return new Error(message + tok);\n  };\n\n  const token = () => curToken;\n\n  const assertAllConsumed = () => {\n    if (curToken != null) {\n      throw error('unexpected garbage at the end: ');\n    }\n  };\n\n  return { token, next, error, ensure, assertAllConsumed };\n}\n","import { getDefined } from '@decipad/utils';\nimport { buildType as t, Type } from '..';\nimport { InferError } from './InferError';\nimport {\n  SerializedType,\n  SerializedTypes,\n  SerializedTypeKind,\n} from './SerializedType';\n\nexport type { SerializedType, SerializedTypes, SerializedTypeKind };\n\nexport function serializeType(type: Type | SerializedType): SerializedType {\n  if (!(type instanceof Type)) {\n    // Already serialized\n    return type;\n  }\n  const serializedType = ((): SerializedType | null => {\n    if (type.cellType && type.columnSize) {\n      return {\n        kind: 'column',\n        indexedBy: type.indexedBy,\n        cellType: serializeType(type.cellType),\n        columnSize: type.columnSize,\n      };\n    } else if (type.columnTypes && type.columnNames) {\n      return {\n        kind: 'table',\n        indexName: type.indexName,\n        columnTypes: type.columnTypes.map((t) => serializeType(t)),\n        columnNames: type.columnNames,\n      };\n    } else if (type.rowCellTypes && type.rowCellNames) {\n      return {\n        kind: 'row',\n        rowIndexName: type.rowIndexName,\n        rowCellTypes: type.rowCellTypes.map((t) => serializeType(t)),\n        rowCellNames: type.rowCellNames,\n      };\n    } else if (type.type === 'number') {\n      if (type.numberFormat === 'percentage' && type.unit?.length) {\n        throw new Error('Cannot serialize a percentage number with a unit');\n      }\n\n      if (type.numberFormat) {\n        return {\n          kind: 'number',\n          numberFormat: type.numberFormat,\n        };\n      }\n\n      if (type.numberError) {\n        return {\n          kind: 'number',\n          unit: type.unit?.length ? type.unit : null,\n          numberError: type.numberError,\n        };\n      }\n\n      return {\n        kind: 'number',\n        unit: type.unit?.length ? type.unit : null,\n      };\n    } else if (type.type === 'boolean') {\n      return { kind: 'boolean' };\n    } else if (type.type === 'string') {\n      return { kind: 'string' };\n    } else if (type.date) {\n      return { kind: 'date', date: type.date };\n    } else if (type.rangeOf) {\n      return { kind: 'range', rangeOf: serializeType(type.rangeOf) };\n    } else if (type.nothingness) {\n      return { kind: 'nothing' };\n    } else if (type.anythingness) {\n      return { kind: 'anything' };\n    } else if (type.functionness) {\n      return {\n        kind: 'function',\n        name: getDefined(type.functionName),\n        argCount: type.functionArgCount,\n        ast: type.node,\n      };\n    } else if (type.errorCause) {\n      return { kind: 'type-error', errorCause: type.errorCause.spec };\n    }\n\n    return null;\n  })();\n\n  if (serializedType != null) {\n    return propagateSymbol(type, serializedType);\n  }\n\n  /* istanbul ignore next */\n  console.error(type);\n  throw new Error(`panic: serializing invalid type ${type.type}`);\n}\n\n/* eslint-disable-next-line consistent-return */\nexport function deserializeType(type: Type | SerializedType): Type {\n  if (type instanceof Type) {\n    return type;\n  }\n  return propagateSymbol(\n    type,\n    (() => {\n      switch (type.kind) {\n        case 'number':\n          return t.number(type.unit, type.numberFormat, type.numberError);\n        case 'string':\n          return t.string();\n        case 'boolean':\n          return t.boolean();\n        case 'date':\n          return t.date(type.date);\n        case 'range':\n          return t.range(deserializeType(type.rangeOf));\n        case 'column':\n          return t.column(\n            deserializeType(type.cellType),\n            type.columnSize,\n            type.indexedBy\n          );\n        case 'table':\n          const { columnTypes, columnNames } = type;\n          return t.table({\n            columnTypes: columnTypes.map((t) => deserializeType(t)),\n            columnNames,\n          });\n        case 'row':\n          return t.row(\n            type.rowCellTypes.map((t) => deserializeType(t)),\n            type.rowCellNames,\n            type.rowIndexName\n          );\n        case 'nothing':\n          return t.nothing();\n        case 'anything':\n          return t.nothing();\n        case 'function':\n          return t.functionPlaceholder(type.name, type.argCount);\n        case 'type-error':\n          return t.impossible(new InferError(type.errorCause));\n      }\n    })()\n  );\n}\n\n/** give the symbol in fromT (if any) to toT */\nfunction propagateSymbol<T extends Type | SerializedType>(\n  fromT: Type | SerializedType,\n  toT: T\n): T {\n  if (fromT.symbol) {\n    return { ...toT, symbol: fromT.symbol };\n  }\n  return toT;\n}\n","import { produce } from 'immer';\nimport { DimensionId } from '../lazy';\nimport { Type } from '../type';\n\nexport type IndexNames = (string | null)[];\n\nexport const arrayOfOnes = (length: number) => Array.from({ length }, () => 1);\n\nexport const getCardinality = (type: Type): number => {\n  if (type.cellType != null) {\n    return 1 + getCardinality(type.cellType);\n  } else {\n    return 1;\n  }\n};\n\nexport const findInvalidCardinality = (\n  args: Type[],\n  expectedCardinalities: number[]\n) => args.find((arg, i) => getCardinality(arg) < expectedCardinalities[i]);\n\nexport const linearizeType = (type: Type): Type[] =>\n  type.cellType ? [type, ...linearizeType(type.cellType)] : [type];\n\nexport const deLinearizeType = (types: Type[]): Type => {\n  const [initialType, ...rest] = types;\n  return Type.combine(initialType, ...rest).mapType(() =>\n    types.length === 1\n      ? initialType\n      : produce(types[0], (type) => {\n          type.cellType = deLinearizeType(rest);\n        })\n  );\n};\n\nexport const typeToDimensionIds = (type: Type): DimensionId[] => {\n  const linear = linearizeType(type).slice(0, -1);\n  return linear.map((t, i) => t.indexedBy ?? i);\n};\n\n/** Place a new item in the head of an array */\nexport const chooseFirst = <T>(indexOnTop: number, items: T[]): T[] => [\n  items[indexOnTop],\n  ...items.filter((_, i) => i !== indexOnTop),\n];\n\n/** undo a chooseFirst() */\nexport const undoChooseFirst = <T>(indexOnTop: number, items: T[]) =>\n  items.flatMap((item, index) => {\n    if (index === 0) {\n      return indexOnTop === 0 ? [item] : [];\n    }\n    if (index === indexOnTop) {\n      return [item, items[0]];\n    }\n    return [item];\n  });\n","import { getDefined } from '@decipad/utils';\nimport { Class } from 'utility-types';\nimport { ColumnLike, Value } from '../value';\nimport { MinimalHypercube } from './types';\nimport { OneResult } from '../interpreter/interpreter-types';\nimport { materialize } from './materialize';\n\n/**\n * Used to lazily lookup into a hypercube\n *\n * hc // -> [\n *   [1, 2],\n *   [69, 420]\n * ]\n *\n * new HypercubeAtIndex(hc, 1) // -> [69, 420]\n */\nexport const HypercubeAtIndex = implementColumnLike(\n  class HypercubeAtIndex implements MinimalHypercube {\n    index: number;\n    innerHC: ColumnLike;\n\n    constructor(innerHC: ColumnLike, index: number) {\n      this.innerHC = innerHC;\n      this.index = index;\n\n      const { dimensionLength } = this.innerHC.dimensions[0];\n      if (index < 0 || index >= dimensionLength) {\n        throw new Error(`panic: index ${index} out of bounds`);\n      }\n    }\n\n    get dimensions() {\n      return this.innerHC.dimensions.slice(1);\n    }\n\n    lowLevelGet(...indices: number[]) {\n      return this.innerHC.lowLevelGet(this.index, ...indices);\n    }\n  }\n);\n\n/**\n * Extend hypercube-like class `Cls` such that it implements the `ColumnLike` interface\n */\nexport function implementColumnLike<T extends Class<MinimalHypercube>>(Cls: T) {\n  return class ColumnLikeMixin extends Cls implements ColumnLike {\n    get values() {\n      const values: Value[] = [];\n      for (let index = 0; index < this.rowCount; index++) {\n        values.push(this.atIndex(index));\n      }\n      return values;\n    }\n\n    get rowCount() {\n      const firstDim = getDefined(\n        this.dimensions[0],\n        'panic: getting row count from non-dimensional value'\n      );\n      return firstDim.dimensionLength;\n    }\n\n    atIndex(i: number): Value {\n      if (this.dimensions.length === 1) {\n        return this.lowLevelGet(i);\n      } else {\n        return new HypercubeAtIndex(this, i);\n      }\n    }\n\n    getData(): OneResult {\n      return materialize(this);\n    }\n  };\n}\n","import { OneResult } from '../interpreter/interpreter-types';\nimport type { Dimension, MinimalHypercube } from './types';\n\n/**\n * Come up with all possible .lowLevelGet arg combinations and call\n * it while building a nested array\n * */\nexport function materialize(hc: MinimalHypercube): OneResult {\n  if (hc.dimensions.some((dim) => dim.dimensionLength === 0)) {\n    return [];\n  }\n\n  /** args for lowLevelGet(). We'll be mutating this as we go */\n  const currentCoordinates = hc.dimensions.map(() => 0);\n\n  return (function recurse(dims: Dimension[], currentDepth: number): OneResult {\n    if (dims.length > 0) {\n      const [firstDim, ...restDims] = dims;\n      return Array.from({ length: firstDim.dimensionLength }, (_, i) => {\n        currentCoordinates[currentDepth] = i;\n        return recurse(restDims, currentDepth + 1);\n      });\n    } else {\n      return hc.lowLevelGet(...currentCoordinates).getData();\n    }\n  })(hc.dimensions, 0);\n}\n","import { getDefined } from '@decipad/utils';\nimport { Type } from '..';\nimport { typeToDimensionIds } from '../dimtools/common';\nimport { isColumnLike, Value } from '../value';\nimport { zip } from '../utils';\nimport { implementColumnLike } from './HypercubeAtIndex';\nimport type {\n  Dimension,\n  DimensionId,\n  MinimalHypercube,\n  OperationFunction,\n} from './types';\n\nexport type HypercubeArg = [arg: Value, argDimensionIds: DimensionId[]];\nexport type HypercubeArgLoose = [\n  arg: Value,\n  dimensionLike: DimensionId[] | Type\n];\n\n/**\n * Represents an operation and X amount of arguments. It's used to represent\n * operations without using RAM to represent results.\n *\n * Instead, getData() is used to materialize the data.\n */\nexport const Hypercube = implementColumnLike(\n  class Hypercube implements MinimalHypercube {\n    readonly op: OperationFunction;\n    readonly args: HypercubeArg[];\n\n    readonly dimensions: Dimension[];\n    readonly dimensionIds: DimensionId[];\n\n    constructor(op: OperationFunction, ...args: HypercubeArgLoose[]) {\n      this.op = op;\n      this.args = args.map(getHypercubeArg);\n\n      const [dimensionIds, dimensions] = uniqDimensions(this.args);\n      this.dimensionIds = dimensionIds;\n      this.dimensions = dimensions;\n    }\n\n    lowLevelGet(...keys: number[]): Value {\n      if (this.dimensions.length !== keys.length) {\n        throw new Error('panic: mismatched dimensions in core lazy operation');\n      }\n\n      const operationArgs = this.args.map(([arg, argDimIds]): Value => {\n        if (isColumnLike(arg)) {\n          // Key indices match dimensions indices\n          const keysForThisArg = argDimIds.map((argDim) => {\n            const whichKey = this.dimensionIds.findIndex(\n              (myDim) => myDim === argDim\n            );\n\n            return getDefined(\n              keys[whichKey],\n              'index out of bounds in core lazy operation'\n            );\n          });\n\n          return arg.lowLevelGet(...keysForThisArg);\n        } else {\n          return arg;\n        }\n      });\n\n      return this.op(operationArgs);\n    }\n  }\n);\n\n/**\n * Hypercubes can be 0-dimensional, but when using as a Value we don't want\n * this flexibility.\n */\nexport const createLazyOperation = (\n  op: OperationFunction,\n  argValues: Value[],\n  argTypes: Type[]\n) => {\n  const lazyOperation = new Hypercube(op, ...zip(argValues, argTypes));\n  if (lazyOperation.dimensions.length) {\n    return lazyOperation;\n  } else {\n    return lazyOperation.lowLevelGet();\n  }\n};\n\nexport const getHypercubeArg = ([value, dimsOrType]: HypercubeArgLoose) => {\n  const dims = Array.isArray(dimsOrType)\n    ? dimsOrType\n    : typeToDimensionIds(dimsOrType);\n  return [value, dims] as HypercubeArg;\n};\n\nexport const uniqDimensions = (\n  args: HypercubeArg[]\n): [DimensionId[], Dimension[]] => {\n  const retDimensions = new Map<DimensionId, Dimension>();\n\n  for (const [arg, argDimIds] of args) {\n    if (!isColumnLike(arg)) continue;\n\n    for (const [argDim, dimId] of zip(arg.dimensions, argDimIds)) {\n      if (!retDimensions.has(dimId)) {\n        retDimensions.set(dimId, argDim);\n      }\n    }\n  }\n\n  return [[...retDimensions.keys()], [...retDimensions.values()]];\n};\n","import { Dimension } from '.';\nimport { Value } from '../value';\nimport { implementColumnLike } from './HypercubeAtIndex';\nimport { MinimalHypercube } from './types';\n\n/**\n * Sometimes we may access `.values[0]` of a column to figure out its dimensionality.\n * But some columns are empty!\n *\n * This class deals with that. To represent an empty column, you create one of these.\n * Column.fromValues() returns this when given dimension information and zero values\n */\nexport const EmptyColumn = implementColumnLike(\n  class EmptyColumn implements MinimalHypercube {\n    dimensions: Dimension[];\n\n    constructor(dimensions: Dimension[]) {\n      this.dimensions = [{ dimensionLength: 0 }, ...dimensions];\n    }\n\n    lowLevelGet(): Value {\n      throw new Error('panic: Attempting to access an empty column');\n    }\n\n    indexToLabelIndex(): number {\n      throw new Error(\n        'panic: Attempting to get source index on an empty column'\n      );\n    }\n  }\n);\n","import { ColumnLike } from '../value';\nimport { chooseFirst, undoChooseFirst } from '../dimtools/common';\nimport { implementColumnLike } from './HypercubeAtIndex';\nimport { Dimension, MinimalHypercube } from './types';\n\n/**\n * Swaps a dimension like so (pseudocode):\n *\n * > unswappedHC\n * [\n *   [1, 2, 3],\n *   [4, 5, 6]\n * ]\n *\n * > swappedHC = new SwappedHypercube(unswappedHC, 1)\n * > swappedHC\n * [\n *   [1, 4],\n *   [2, 5],\n *   [3, 6],\n * ]\n */\nexport const SwappedHypercube = implementColumnLike(\n  class SwappedHypercube implements MinimalHypercube {\n    unswappedHC: ColumnLike;\n\n    dimensions: Dimension[];\n    dominantDimensionIndex: number;\n\n    constructor(unswappedHC: ColumnLike, dominantDimensionIndex: number) {\n      this.unswappedHC = unswappedHC;\n\n      this.dominantDimensionIndex = dominantDimensionIndex;\n      this.dimensions = chooseFirst(\n        this.dominantDimensionIndex,\n        unswappedHC.dimensions\n      );\n    }\n\n    lowLevelGet(...indices: number[]) {\n      return this.unswappedHC.lowLevelGet(\n        ...undoChooseFirst(this.dominantDimensionIndex, indices)\n      );\n    }\n  }\n);\n","import { getDefined } from '@decipad/utils';\nimport { isColumnLike, Value } from '../value';\n\nexport function lowLevelGet(valueHere: Value, keys: number[]) {\n  getDefined(valueHere, 'panic: lowLevelGet called with undefined value');\n\n  if (isColumnLike(valueHere)) {\n    return valueHere.lowLevelGet(...keys);\n  } else if (keys.length) {\n    throw new Error('panic: lowLevelGet called with too many coordinates');\n  } else {\n    return valueHere;\n  }\n}\n","import { Dimension, lowLevelGet } from '.';\nimport { getLabelIndex } from '../dimtools';\nimport { ColumnLike } from '../value';\nimport { implementColumnLike } from './HypercubeAtIndex';\nimport { MinimalHypercube } from './types';\n\nexport const ConcatenatedColumn = implementColumnLike(\n  class ConcatenatedColumn implements MinimalHypercube {\n    dimensions: Dimension[];\n    column1: ColumnLike;\n    column2: ColumnLike;\n\n    /** Construct a column that concatenates the values of 2 columns. */\n    constructor(column1: ColumnLike, column2: ColumnLike) {\n      const [firstDim, ...restDims] = column1.dimensions;\n\n      const concatenatedDim = {\n        dimensionLength:\n          firstDim.dimensionLength + column2.dimensions[0].dimensionLength,\n      };\n\n      this.dimensions = [concatenatedDim, ...restDims];\n      this.column1 = column1;\n      this.column2 = column2;\n    }\n\n    lowLevelGet(...keys: number[]) {\n      const [firstKey, ...restKeys] = keys;\n\n      const item =\n        firstKey < this.column1.rowCount\n          ? this.column1.atIndex(firstKey)\n          : this.column2.atIndex(firstKey - this.column1.rowCount);\n\n      return lowLevelGet(item, restKeys);\n    }\n\n    indexToLabelIndex(concatenatedIndex: number) {\n      if (concatenatedIndex < this.column1.rowCount) {\n        return getLabelIndex(this.column1, concatenatedIndex);\n      } else {\n        return getLabelIndex(\n          this.column2,\n          concatenatedIndex - this.column1.rowCount\n        );\n      }\n    }\n  }\n);\n","import { enableMapSet } from 'immer';\n\nenableMapSet();\nexport { createLazyOperation } from './Hypercube';\nexport { EmptyColumn } from './EmptyColumn';\nexport { SwappedHypercube } from './SwappedHypercube';\nexport { lowLevelGet } from './lowLevelGetImpl';\nexport { ConcatenatedColumn } from './ConcatenatedColumn';\nexport type { Dimension, DimensionId } from './types';\n","/* eslint-disable no-underscore-dangle */\nimport DeciNumber, { N } from '@decipad/number';\nimport { unzip, getDefined, AnyMapping, anyMappingToMap } from '@decipad/utils';\nimport { DeepReadonly } from 'utility-types';\nimport { Interpreter, Time } from '..';\nimport { addTime, cleanDate } from '../date';\nimport { Dimension, EmptyColumn, lowLevelGet } from '../lazy';\nimport { filterUnzipped } from '../utils';\nimport { RuntimeError } from '.';\nimport { Unknown } from './Unknown';\nimport { getLabelIndex } from '../dimtools/getLabelIndex';\nimport {\n  Value,\n  ColumnLike,\n  NonColumn,\n  isColumnLike,\n  getColumnLike,\n} from './types';\n\nexport const UnknownValue: Value = {\n  getData() {\n    return Unknown;\n  },\n};\n\nexport class Scalar {\n  static fromValue(\n    value: number | bigint | DeciNumber | boolean | string | symbol | Date\n  ): NonColumn {\n    if (value instanceof Date) {\n      return DateValue.fromDateAndSpecificity(value.getTime(), 'millisecond');\n    }\n    if (value instanceof DeciNumber) {\n      return NumberValue.fromValue(value);\n    }\n    const t = typeof value;\n    if (t === 'number' || t === 'bigint') {\n      return NumberValue.fromValue(value as number | bigint);\n    }\n    if (t === 'boolean') {\n      return BooleanValue.fromValue(value as boolean);\n    }\n    return StringValue.fromValue(value as string);\n  }\n}\n\nexport class NumberValue implements Value {\n  readonly value: DeciNumber;\n\n  constructor(varValue: number | bigint | DeciNumber) {\n    const t = typeof varValue;\n    if (t === 'number' || t === 'bigint') {\n      this.value = N(varValue as number | bigint);\n    } else {\n      this.value = varValue as DeciNumber;\n    }\n  }\n\n  getData() {\n    return this.value;\n  }\n\n  static fromValue(value: number | bigint | DeciNumber): NumberValue {\n    return new NumberValue(value);\n  }\n}\n\nexport class StringValue implements Value {\n  value: string;\n  constructor(value: string) {\n    this.value = value;\n  }\n\n  static fromValue(value: string): StringValue {\n    return new StringValue(value);\n  }\n\n  getData() {\n    return this.value;\n  }\n}\n\nexport class BooleanValue implements Value {\n  value: boolean;\n  constructor(value: boolean) {\n    this.value = value;\n  }\n\n  static fromValue(value: boolean): BooleanValue {\n    return new BooleanValue(value);\n  }\n\n  getData() {\n    return this.value;\n  }\n}\n\nexport class DateValue implements Value {\n  specificity: Time.Specificity;\n  moment: bigint;\n\n  constructor(moment: bigint, specificity: Time.Specificity) {\n    this.moment = moment;\n    this.specificity = specificity;\n  }\n\n  static fromDateAndSpecificity(\n    date: bigint | number,\n    specificity: Time.Specificity\n  ) {\n    return new DateValue(cleanDate(date, specificity), specificity);\n  }\n\n  getData() {\n    return this.moment;\n  }\n\n  /**\n   * Dates such as month, day and year, have a start and end. getData() gets us the first millisecond of that range. getEnd gets us the last.\n   */\n  getEnd() {\n    return addTime(this.moment, this.specificity, 1n) - 1n;\n  }\n\n  getEndDate() {\n    const moment = this.getEnd();\n    return new DateValue(moment, this.specificity);\n  }\n}\n\nexport class Range implements Value {\n  start: Value;\n  end: Value;\n\n  constructor({ start, end }: Pick<Range, 'start' | 'end'>) {\n    this.start = start;\n    this.end = end;\n  }\n\n  static fromBounds(start: Value, end: Value): Range {\n    if (start instanceof DateValue && end instanceof DateValue) {\n      return new Range({\n        start,\n        end: end.getEndDate(),\n      });\n    } else if (start instanceof NumberValue && end instanceof NumberValue) {\n      return new Range({ start, end });\n    } else {\n      throw new Error(\n        `panic: bad Range.fromBounds arguments ${start.constructor.name} and ${end.constructor.name}`\n      );\n    }\n  }\n\n  getData() {\n    return [this.start.getData(), this.end.getData()];\n  }\n}\n\nexport type SliceRange = [start: number, end: number];\nexport type SlicesMap = SliceRange[];\n\nexport class Column implements ColumnLike {\n  readonly _values: DeepReadonly<Value[]>;\n\n  constructor(values: DeepReadonly<Column['values']>) {\n    this._values = values;\n  }\n\n  get dimensions() {\n    const contents = this.values[0];\n\n    if (isColumnLike(contents)) {\n      return [{ dimensionLength: this.rowCount }, ...contents.dimensions];\n    } else {\n      return [{ dimensionLength: this.rowCount }];\n    }\n  }\n\n  lowLevelGet(...keys: number[]) {\n    return lowLevelGet(this.atIndex(keys[0]), keys.slice(1));\n  }\n\n  /**\n   * Create a column from the values inside. Empty columns return a special value.\n   */\n  static fromValues(\n    values: DeepReadonly<Value[]>,\n    innerDimensions?: Dimension[]\n  ): ColumnLike {\n    if (values.length === 0) {\n      if (innerDimensions) {\n        // We can create a column with no values\n        return new EmptyColumn(innerDimensions);\n      }\n      throw new Error('panic: Empty columns are forbidden');\n    }\n    return new Column(values);\n  }\n\n  get values() {\n    return this._values;\n  }\n\n  get rowCount() {\n    return this.values.length;\n  }\n\n  atIndex(i: number) {\n    return getDefined(this.values[i], `index ${i} out of bounds`);\n  }\n\n  getData(): Interpreter.OneResult[] {\n    return this.values.map((value) => value.getData());\n  }\n}\n\nexport class MappedColumn extends Column implements ColumnLike {\n  private map: number[];\n  sourceColumn: ColumnLike;\n\n  constructor(col: ColumnLike, map: number[]) {\n    super(col.values);\n    this.sourceColumn = col;\n    this.map = map;\n  }\n\n  get values(): Value[] {\n    return this.map.map((index) => this._values[index]);\n  }\n\n  static fromColumnAndMap(column: ColumnLike, map: number[]): MappedColumn {\n    return new MappedColumn(column, map);\n  }\n\n  get rowCount() {\n    return this.map.length;\n  }\n\n  atIndex(index: number) {\n    return this._values[this.map[index]];\n  }\n\n  indexToLabelIndex(mappedIndex: number) {\n    return getLabelIndex(this.sourceColumn, this.map[mappedIndex]);\n  }\n}\n\nexport class FilteredColumn extends Column implements ColumnLike {\n  private map: boolean[];\n  private sourceColumn: ColumnLike;\n\n  constructor(col: ColumnLike, map: boolean[]) {\n    super(col.values);\n    this.sourceColumn = col;\n    this.map = map;\n  }\n\n  get values(): Value[] {\n    const { map } = this;\n    let cursor = -1;\n    return Array.from({ length: this.map.filter(Boolean).length }, () => {\n      cursor += 1;\n      while (!map[cursor]) {\n        cursor += 1;\n      }\n      return this._values[cursor];\n    });\n  }\n\n  static fromColumnAndMap(column: ColumnLike, map: boolean[]): FilteredColumn {\n    return new FilteredColumn(column, map);\n  }\n\n  get rowCount() {\n    let count = 0;\n    for (const bool of this.map) {\n      count += Number(bool);\n    }\n    return count;\n  }\n\n  private getSourceIndex(outwardIndex: number) {\n    let trueCount = -1;\n    for (let sourceIndex = 0; sourceIndex < this.map.length; sourceIndex++) {\n      if (this.map[sourceIndex] === true) {\n        trueCount++;\n        if (trueCount === outwardIndex) {\n          return sourceIndex;\n        }\n      }\n    }\n\n    throw new Error(`panic: index not found: ${outwardIndex}`);\n  }\n\n  atIndex(wantedIndex: number) {\n    return this._values[this.getSourceIndex(wantedIndex)];\n  }\n\n  indexToLabelIndex(filteredIndex: number) {\n    const sourceIndex = this.getSourceIndex(filteredIndex);\n    return getLabelIndex(this.sourceColumn, sourceIndex);\n  }\n}\n\nexport class Table implements Value {\n  columns: ColumnLike[];\n  columnNames: string[];\n\n  constructor(columns: ColumnLike[], columnNames: string[]) {\n    this.columns = columns;\n    this.columnNames = columnNames;\n  }\n\n  static fromNamedColumns(columns: Value[], columnNames: string[]) {\n    return new Table(\n      columns.map((v) => getColumnLike(v)),\n      columnNames\n    );\n  }\n\n  get tableRowCount(): number | undefined {\n    return this.columns.at(0)?.rowCount;\n  }\n\n  static fromMapping(mapping: AnyMapping<ColumnLike>) {\n    const [columnNames, columns] = unzip(anyMappingToMap(mapping).entries());\n    return new Table(columns, columnNames);\n  }\n\n  getColumn(name: string) {\n    const index = this.columnNames.indexOf(name);\n    if (index < 0 || index >= this.columns.length) {\n      throw new RuntimeError(`Missing column ${name}`);\n    }\n    return this.columns[index];\n  }\n\n  getData() {\n    return this.columns.map((column) => column.getData());\n  }\n\n  mapColumns(mapFn: (col: ColumnLike, index: number) => ColumnLike): Table {\n    return Table.fromNamedColumns(this.columns.map(mapFn), this.columnNames);\n  }\n\n  filterColumns(fn: (colName: string, col: ColumnLike) => boolean): Table {\n    const [names, columns] = filterUnzipped(this.columnNames, this.columns, fn);\n\n    return Table.fromNamedColumns(columns, names);\n  }\n}\n\nexport class Row implements Value {\n  cells: Value[];\n  cellNames: string[];\n\n  constructor(values: Value[], cellNames: string[]) {\n    this.cells = values;\n    this.cellNames = cellNames;\n  }\n\n  static fromNamedCells(cells: Value[], cellNames: string[]) {\n    return new Row(cells, cellNames);\n  }\n\n  getCell(name: string): Value {\n    const index = this.cellNames.indexOf(name);\n    if (index < 0 || index >= this.cells.length) {\n      throw new RuntimeError(`Missing cell ${name}`);\n    }\n    return this.cells[index];\n  }\n\n  getData() {\n    return this.cells.map((v) => v.getData());\n  }\n}\n\nexport type FromJSArg =\n  | string\n  | boolean\n  | number\n  | bigint\n  | Date\n  | DeciNumber\n  | FromJSArg[];\n\nexport const fromJS = (thing: FromJSArg): Value => {\n  // TODO this doesn't distinguish Range/Date from Column, and it can't possibly do it!\n  if (thing == null) {\n    throw new TypeError('result cannot be null');\n  }\n  if (!Array.isArray(thing)) {\n    return Scalar.fromValue(thing);\n  } else if (thing.length === 0) {\n    return Column.fromValues([], []);\n  } else {\n    return Column.fromValues(thing.map((t) => fromJS(t)));\n  }\n};\n","/* eslint-disable no-underscore-dangle */\nimport DeciNumber, { N } from '@decipad/number';\nimport { RuntimeError, Time } from '..';\nimport { addTime, getSpecificity } from '../date';\n\nimport { Column, DateValue, Scalar } from './Value';\nimport { Value, ColumnLike } from './types';\n\nconst MAX_ITERATIONS = 10_000; // Failsafe\n\nexport function columnFromSequence(\n  startV: Value,\n  endV: Value,\n  byV?: Value\n): ColumnLike {\n  const [start, end] = [startV, endV].map((val) => val.getData() as DeciNumber);\n\n  const by = byV\n    ? (byV.getData() as DeciNumber)\n    : start.compare(end) < 0\n    ? N(1)\n    : N(-1);\n\n  const array = [];\n\n  // helper to allow decreasing sequences\n  const cmpFn = (s: DeciNumber, e: DeciNumber, i: DeciNumber) => {\n    return s.compare(e) < 0 ? i.compare(e) <= 0 : i.compare(e) >= 0;\n  };\n\n  let iterations = 0;\n  for (let i = start; cmpFn(start, end, i); i = i.add(by)) {\n    if (++iterations > MAX_ITERATIONS) {\n      throw new RuntimeError(\n        `A maximum number of ${MAX_ITERATIONS} has been reached in sequence. Check for an unbounded sequence in your code.`\n      );\n    }\n    array.push(Scalar.fromValue(i));\n  }\n\n  return Column.fromValues(array);\n}\n\nexport function columnFromDateSequence(\n  startD: DateValue,\n  endD: DateValue,\n  by: Time.Unit\n): ColumnLike {\n  let start = startD.getData();\n  let end = endD.getData();\n  if (end >= start) {\n    end = endD.getEnd();\n  } else {\n    start = startD.getEnd();\n  }\n\n  const spec = getSpecificity(by);\n\n  const array = [];\n\n  // helper to allow decreasing date sequences\n  const cmpFn = (s: bigint, e: bigint, i: bigint) => {\n    return s < e ? i <= e : i >= e;\n  };\n\n  const signal = start < end ? 1 : -1;\n  const step = 1 * signal;\n\n  let iterations = 0;\n  for (\n    let cur = start;\n    cmpFn(start, end, cur);\n    cur = addTime(cur, by, BigInt(step))\n  ) {\n    if (++iterations > MAX_ITERATIONS) {\n      throw new RuntimeError(\n        `A maximum number of ${MAX_ITERATIONS} has been reached in sequence. Check for an unbounded sequence in your code.`\n      );\n    }\n\n    array.push(DateValue.fromDateAndSpecificity(cur, spec));\n  }\n\n  return Column.fromValues(array);\n}\n","// eslint-disable-next-line no-restricted-imports\nimport DeciNumber, {\n  isDeciNumberInput,\n  N,\n  DeciNumberInput,\n} from '@decipad/number';\nimport { zip } from '@decipad/utils';\nimport { DeepReadonly } from 'utility-types';\nimport {\n  RuntimeError,\n  Value,\n  NumberValue,\n  StringValue,\n  BooleanValue,\n  DateValue,\n  isColumnLike,\n} from '.';\n\nexport type CompareResult = -1 | 0 | 1;\n\nexport type Comparable =\n  | DeepReadonly<Value>\n  | string\n  | boolean\n  | number\n  | bigint\n  | DeciNumber\n  | DeciNumberInput\n  | ReadonlyArray<Comparable>;\n\n/** Returns the sign of a comparison between two things, whatever they may be */\nfunction compareToNumber(a: Comparable, b: Comparable): number | bigint {\n  if (isDeciNumberInput(a) && isDeciNumberInput(b)) {\n    return N(a).compare(N(b));\n  }\n  if (typeof a === 'string' && typeof b === 'string') {\n    return a > b ? 1 : a === b ? 0 : -1;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a - b;\n  }\n  if (typeof a === 'boolean' && typeof b === 'boolean') {\n    return Number(a) - Number(b);\n  }\n  if (typeof a === 'bigint' && typeof b === 'bigint') {\n    return a - b;\n  }\n  if (a instanceof NumberValue && b instanceof NumberValue) {\n    return a.value.compare(b.value);\n  }\n  if (a instanceof StringValue && b instanceof StringValue) {\n    return a.value === b.value ? 0 : a.value < b.value ? -1 : 1;\n  }\n  if (a instanceof BooleanValue && b instanceof BooleanValue) {\n    return ((a.value && 1) || 0) - ((b.value && 1) || 0);\n  }\n  if (a instanceof DateValue && b instanceof DateValue) {\n    return a.moment < b.moment ? -1 : a.moment === b.moment ? 0 : 1;\n  }\n  if (isColumnLike(a) && isColumnLike(b)) {\n    return compareToNumber(a.values, b.values);\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    const lengthComparison = a.length - b.length;\n\n    if (lengthComparison === 0) {\n      for (const [aItem, bItem] of zip(a, b)) {\n        const thisItem = compare(aItem, bItem);\n\n        if (thisItem !== 0) {\n          return thisItem;\n        }\n      }\n    }\n\n    return lengthComparison;\n  }\n  console.log(a, b);\n  throw new RuntimeError(\n    `Don't know how to compare ${a} (${typeof a}) against ${b} (${typeof b})`\n  );\n}\n\nconst sign = (diff: number | bigint): CompareResult => {\n  if (typeof diff === 'number') {\n    return diff > 0 ? 1 : diff < 0 ? -1 : 0;\n  }\n  return diff > 0n ? 1 : diff < 0n ? -1 : 0;\n};\n\nexport function compare(a: Comparable, b: Comparable): CompareResult {\n  return sign(compareToNumber(a, b));\n}\n","import { Dimension, lowLevelGet } from '.';\nimport { getLabelIndex } from '../dimtools';\nimport { ColumnLike } from '../value';\nimport { implementColumnLike } from './HypercubeAtIndex';\nimport { MinimalHypercube } from './types';\n\nexport const ColumnSlice = implementColumnLike(\n  class _ColumnSlice implements MinimalHypercube {\n    begin: number;\n    end: number;\n    sourceColumn: ColumnLike;\n    dimensions: Dimension[];\n\n    constructor(sourceColumn: ColumnLike, begin: number, end: number) {\n      this.sourceColumn = sourceColumn;\n      this.begin = begin;\n      this.end = end;\n      this.dimensions = [\n        { dimensionLength: this.end - this.begin },\n        ...sourceColumn.dimensions.slice(1),\n      ];\n    }\n\n    static fromColumnAndRange(column: ColumnLike, begin: number, end: number) {\n      return new ColumnSlice(column, begin, end);\n    }\n\n    lowLevelGet(...keys: number[]) {\n      const [firstKey, ...restKeys] = keys;\n\n      if (firstKey < 0 || firstKey > this.dimensions[0].dimensionLength) {\n        throw new Error(`panic: index ${firstKey} out of bounds`);\n      }\n      return lowLevelGet(this.sourceColumn, [\n        firstKey + this.begin,\n        ...restKeys,\n      ]);\n    }\n\n    indexToLabelIndex(outIndex: number) {\n      return getLabelIndex(this.sourceColumn, outIndex + this.begin);\n    }\n  }\n);\n","import { Value } from './types';\nimport { ColumnSlice } from '../lazy/ColumnSlice';\nimport {\n  compare,\n  ColumnLike,\n  FilteredColumn,\n  MappedColumn,\n  SlicesMap,\n} from '.';\n\nexport function sortMap(col: ColumnLike): number[] {\n  const unsortedIndexes = Array.from({ length: col.rowCount }, (_, i) => i);\n  return unsortedIndexes.sort((aIndex, bIndex) => {\n    return compare(col.atIndex(aIndex), col.atIndex(bIndex));\n  });\n}\n\nexport function sort(col: ColumnLike): ColumnLike {\n  return MappedColumn.fromColumnAndMap(col, sortMap(col));\n}\n\nexport function unique(col: ColumnLike): ColumnLike {\n  const sorted = sort(col);\n  const slices = contiguousSlices(sorted).map(([index]) => index);\n  return applyMap(sorted, slices);\n}\n\nfunction reverseMap(col: ColumnLike) {\n  const length = col.rowCount;\n  return Array.from({ length }, (_, i) => length - i - 1);\n}\n\nexport function reverse(col: ColumnLike): ColumnLike {\n  return MappedColumn.fromColumnAndMap(col, reverseMap(col));\n}\n\nexport function slice(col: ColumnLike, begin: number, end: number): ColumnLike {\n  return ColumnSlice.fromColumnAndRange(col, begin, end);\n}\n\nexport function applyMap(col: ColumnLike, map: number[]): ColumnLike {\n  return MappedColumn.fromColumnAndMap(col, map);\n}\n\nexport function applyFilterMap(col: ColumnLike, map: boolean[]): ColumnLike {\n  return FilteredColumn.fromColumnAndMap(col, map);\n}\n\nexport function contiguousSlices(column: ColumnLike): SlicesMap {\n  const slices: SlicesMap = [];\n  let lastValue: undefined | Value;\n  let nextSliceBeginsAt = 0;\n  column.values.forEach((currentValue, index) => {\n    if (lastValue && compare(lastValue, currentValue) !== 0) {\n      // at the beginning of a new slice\n      slices.push([nextSliceBeginsAt, index - 1]);\n      nextSliceBeginsAt = index;\n    }\n    lastValue = currentValue;\n  });\n\n  if (nextSliceBeginsAt <= column.rowCount - 1) {\n    slices.push([nextSliceBeginsAt, column.rowCount - 1]);\n  }\n\n  return slices;\n}\n","import { singular } from 'pluralize';\nimport { Time, timeUnitToJSDateUnit, toLuxonUTC, getTimeUnit } from '.';\nimport type { Unit } from '..';\nimport { RuntimeError } from '../value';\nimport { getDefined } from '../utils';\n\nexport const addTime = (\n  date: bigint,\n  timeUnit: Time.Unit,\n  quantity: bigint\n): bigint => {\n  const [composedUnit, compositeMultiplier] = getDefined(\n    timeUnitToJSDateUnit[timeUnit],\n    `bad time unit ${timeUnit}`\n  );\n\n  const added = toLuxonUTC(date).plus({\n    [composedUnit]: Number(BigInt(quantity) * compositeMultiplier),\n  });\n\n  return BigInt(added.toMillis());\n};\n\nexport function timeUnitFromUnits(units: Unit[]): Time.Unit {\n  if (units.length !== 1) {\n    throw new RuntimeError(\n      'Cannot construct time quantity from more than one unit of time'\n    );\n  }\n  const unit = singular(units[0].unit);\n  return getTimeUnit(unit);\n}\n","import { singular } from 'pluralize';\nimport { DateTime } from 'luxon';\nimport DeciNumber, { N } from '@decipad/number';\nimport { AST, Unit } from '..';\nimport { n, pairwise, getDefined } from '../utils';\nimport { DateValue } from '../value';\nimport * as Time from './time-types';\n\nexport * from './time-quantities';\n\nexport { Time };\n\n/*\n * Check out ./time-types.ts for documentation about different kinds of time units\n */\n\n/**\n * Create a Luxon DateTime without a timezone offset from a date-like arg\n */\nexport const toLuxonUTC = (date: bigint | number | DateValue | DateTime) => {\n  if (date instanceof DateValue) {\n    date = date.getData();\n  }\n  if (typeof date === 'bigint') {\n    date = Number(date);\n  }\n  if (date instanceof DateTime) {\n    return date.toUTC();\n  }\n  if (typeof date !== 'number') {\n    throw new Error('panic: toLuxon(date) passed an invalid date');\n  }\n  return DateTime.fromMillis(date).toUTC();\n};\n\nconst specificities: Time.Specificity[] = [\n  'year',\n  'month',\n  'day',\n  'hour',\n  'minute',\n  'second',\n  'millisecond',\n];\n\nexport const timeUnitToJSDateUnit: Record<\n  Time.Unit,\n  [Time.JSDateUnit, bigint]\n> = {\n  millennium: ['year', 1000n],\n  century: ['year', 100n],\n  decade: ['year', 10n],\n  year: ['year', 1n],\n  quarter: ['month', 3n],\n  month: ['month', 1n],\n  week: ['day', 7n],\n  day: ['day', 1n],\n  hour: ['hour', 1n],\n  minute: ['minute', 1n],\n  second: ['second', 1n],\n  millisecond: ['millisecond', 1n],\n};\n\nconst timeUnits = new Set(Object.keys(timeUnitToJSDateUnit));\n\nexport const getJSDateUnitAndMultiplier = (unit: Time.Unit) =>\n  timeUnitToJSDateUnit[unit];\n\nexport const jsUnitToIndex: Record<Time.JSDateUnit, number> = {\n  year: 0,\n  month: 1,\n  day: 2,\n  hour: 3,\n  minute: 4,\n  second: 5,\n  millisecond: 6,\n};\n\nexport const jsIndexToUnit: Record<number, Time.JSDateUnit> = {\n  0: 'year',\n  1: 'month',\n  2: 'day',\n  3: 'hour',\n  4: 'minute',\n  5: 'second',\n  6: 'millisecond',\n};\n\nconst timeUnitToIndex: Record<Time.Unit, number> = {\n  millennium: 0,\n  century: 1,\n  decade: 2,\n  year: 3,\n  quarter: 4,\n  month: 5,\n  week: 6,\n  day: 7,\n  hour: 8,\n  minute: 9,\n  second: 10,\n  millisecond: 11,\n};\n\nexport const timeUnitFromUnit = (unit: Unit | string): Time.Unit => {\n  const u = singular((unit as Unit).unit ?? unit);\n  if (!timeUnits.has(u)) {\n    throw new Error(`Expected time unit and got ${u}`);\n  }\n  return u as Time.Unit;\n};\n\nexport const getSpecificity = (thing?: string | Unit): Time.Specificity => {\n  let unit = typeof thing === 'string' ? thing : thing && thing.unit;\n  if (unit) {\n    unit = singular(unit);\n\n    if (unit === 'millennium') return 'year';\n    if (unit === 'century') return 'year';\n    if (unit === 'decade') return 'year';\n\n    if (unit === 'quarter') return 'month';\n\n    if (unit === 'week') return 'day';\n\n    if (specificities.includes(unit as Time.Specificity)) {\n      return unit as Time.Specificity;\n    }\n  }\n\n  throw new Error(`panic: Expected Time.JSDateUnit, got ${unit}`);\n};\n\nexport const getTimeUnit = (thing: string) => {\n  if (thing in timeUnitToJSDateUnit) {\n    return thing as Time.Unit;\n  } else {\n    throw new Error(`panic: Expected Time.Unit, got ${thing}`);\n  }\n};\n\nexport const cmpSpecificities = (left: string, right: string): number => {\n  const leftIdx = specificities.indexOf(getSpecificity(left));\n  const rightIdx = specificities.indexOf(getSpecificity(right));\n\n  return Math.sign(leftIdx - rightIdx);\n};\n\nexport const sortSpecificities = (specificities: (Unit | string)[]) => {\n  const uniqueSpecificities = Array.from(\n    new Set(specificities.map((s) => getSpecificity(s)))\n  );\n  return uniqueSpecificities.sort((a, b) => cmpSpecificities(a, b));\n};\n\nexport const sortTimeUnits = <T extends string | Unit>(\n  toSort: Iterable<T>\n): T[] => {\n  const uniqueUnits = Array.from(new Set(toSort));\n  return uniqueUnits.sort((a, b) => {\n    const tua = timeUnitFromUnit(a);\n    const tub = timeUnitFromUnit(b);\n    return Math.sign(timeUnitToIndex[tua] - timeUnitToIndex[tub]);\n  });\n};\n\nexport const getHighestSpecificity = (specificities: Unit[]) =>\n  getDefined(sortSpecificities(specificities).pop());\n\nconst cmpJSDateUnits = (left: Time.JSDateUnit, right: Time.JSDateUnit) => {\n  const leftIdx = jsUnitToIndex[left];\n  const rightIdx = jsUnitToIndex[right];\n\n  return Math.sign(leftIdx - rightIdx);\n};\n\n// Dates are ranges -- this function cuts up a date to its closest specificity\nexport const cleanDate = (\n  date: bigint | number,\n  specificity: Time.Specificity\n): bigint => {\n  const necessarySegments = dateToArray(date).slice(\n    0,\n    jsUnitToIndex[specificity] + 1\n  );\n\n  return arrayToDate(necessarySegments);\n};\n\nexport const dateToArray = (date: Date | number | bigint) => {\n  const d = new Date(Number(date));\n\n  return [\n    BigInt(d.getUTCFullYear()),\n    BigInt(d.getUTCMonth() + 1),\n    BigInt(d.getUTCDate()),\n    BigInt(d.getUTCHours()),\n    BigInt(d.getUTCMinutes()),\n    BigInt(d.getUTCSeconds()),\n    BigInt(d.getUTCMilliseconds()),\n  ];\n};\n\nconst getDateSegment = (\n  thing: bigint | string | AST.TZInfo | undefined,\n  isMonth: boolean\n): bigint | null => {\n  if (typeof thing === 'string') {\n    thing = BigInt(thing.replace(/^0+/, ''));\n  }\n\n  if (typeof thing === 'bigint') {\n    return thing - (isMonth ? 1n : 0n);\n  } else {\n    return null;\n  }\n};\n\nexport function arrayToDate(\n  segments: (string | bigint | AST.TZInfo | undefined)[]\n): bigint {\n  const nameAndNumber: [string, string | bigint | AST.TZInfo | undefined][] = [\n    ['year', segments[0]],\n    ['month', segments[1]],\n    ['day', segments[2]],\n    ['hour', segments[3]],\n    ['minute', segments[4]],\n    ['second', segments[5]],\n    ['millisecond', segments[6]],\n  ];\n\n  const dateArgs: bigint[] = [];\n  for (const [segName, segValue] of nameAndNumber) {\n    const segNumber = getDateSegment(segValue, segName === 'month');\n\n    if (segNumber != null) {\n      dateArgs.push(segNumber);\n    } else {\n      break;\n    }\n  }\n\n  const utcArgs = [\n    Number(dateArgs[0]),\n    Number(dateArgs[1] || 0n),\n    ...dateArgs.slice(2).map(Number),\n  ];\n  const d = Date.UTC(utcArgs[0], utcArgs[1], ...utcArgs.slice(2));\n  return BigInt(d);\n}\n\n// TODO move the following functions to test utils\nexport function parseUTCDate(iso: string) {\n  const segments = iso.match(/(\\d+)/g)?.map((n) => BigInt(n));\n\n  return arrayToDate(getDefined(segments, `bad date ${iso}`));\n}\n\nexport function getUTCDateSpecificity(iso: string): Time.Specificity {\n  const segmentCount = getDefined(iso.match(/(\\d+)/g)?.length);\n\n  return specificities[segmentCount - 1] as Time.Specificity;\n}\n\nexport function date(\n  parsableDate: string,\n  specificity: Time.JSDateUnit\n): AST.Date {\n  const dateArray = dateToArray(parseUTCDate(parsableDate));\n\n  const args: AST.Date['args'] = [];\n\n  for (const [unit, index] of Object.entries(jsUnitToIndex)) {\n    args.push(unit as Time.JSDateUnit, BigInt(dateArray[index]));\n\n    if (cmpJSDateUnits(unit as Time.JSDateUnit, specificity) === 0) {\n      break;\n    }\n  }\n\n  return n('date', ...args);\n}\n\nconst pad = (x: bigint | string) => String(x).padStart(2, '0');\n\nexport function stringifyDate(\n  date: bigint,\n  specificity: Time.Specificity\n): string {\n  const segments = dateToArray(date);\n\n  let out = String(segments[0]);\n  if (specificity === 'year') return out;\n\n  out += `-${pad(segments[1])}`;\n  if (specificity === 'month') return out;\n\n  out += `-${pad(segments[2])}`;\n  if (specificity === 'day') return out;\n\n  out += ` ${pad(segments[3])}:${pad(segments[4])}`;\n\n  return out;\n}\n\nexport const dateNodeToSpecificity = (\n  nodeArgs: AST.Date['args']\n): Time.Specificity => getSpecificity(dateNodeToTimeUnit(nodeArgs));\n\nexport const dateNodeToTimeUnit = (nodeArgs: AST.Date['args']): Time.Unit => {\n  let lowestSegment: Time.Unit = 'year';\n\n  for (const [segment] of pairwise<Time.Unit, unknown>(nodeArgs)) {\n    lowestSegment = segment;\n  }\n\n  return lowestSegment;\n};\n\nexport const getDateFromAstForm = (\n  segments: AST.Date['args']\n): [bigint, Time.Specificity] => {\n  const dateNum = arrayToDate([\n    segments[1],\n    segments[3],\n    segments[5],\n    segments[7],\n    segments[9],\n    segments[11],\n  ]);\n\n  return [dateNum, dateNodeToSpecificity(segments)];\n};\n\nexport const subtractDates = (\n  d1: DateValue,\n  d2: DateValue,\n  specificity: Time.Specificity\n): DeciNumber => {\n  const dateTime1 = toLuxonUTC(d1.getData());\n  const dateTime2 = toLuxonUTC(d2.getData());\n\n  switch (specificity) {\n    case 'year': {\n      return N(dateTime1.diff(dateTime2, 'years').years * 12);\n    }\n    case 'month': {\n      return N(dateTime1.diff(dateTime2, 'months').months);\n    }\n    default: {\n      return N(dateTime1.diff(dateTime2, 'milliseconds').milliseconds, 1000n);\n    }\n  }\n};\n","import DeciNumber, { N, ONE } from '@decipad/number';\nimport { Class } from 'utility-types';\nimport { AST, Unit } from '.';\n\nexport { date } from './date';\n\ntype WalkFn = (node: AST.Node, path: number[]) => void;\ntype MutateFn = (node: AST.Node, path: number[]) => AST.Node;\n\nexport const DEFAULT_PRECISION = 10;\nexport const MAX_PRECISION = 15;\n\nexport const walkAst = (node: AST.Node, fn: WalkFn, path: number[] = []) => {\n  fn(node, path);\n\n  for (let index = 0; index < node.args.length; index++) {\n    const arg = node.args[index];\n    if (isNode(arg)) {\n      walkAst(arg, fn, [...path, index]);\n    }\n  }\n};\n\nexport const mutateAst = (\n  node: AST.Node,\n  fn: MutateFn,\n  path: number[] = []\n): AST.Node => {\n  const newNode = fn(node, path);\n  if (newNode !== node) {\n    return newNode;\n  }\n\n  for (let index = 0; index < node.args.length; index++) {\n    const arg = node.args[index];\n    if (isNode(arg)) {\n      const newNode = mutateAst(arg, fn, [...path, index]);\n      node.args[index] = newNode;\n    }\n  }\n\n  return node;\n};\n\nexport function n<\n  NodeType extends AST.Node['type'],\n  Node extends Extract<AST.Node, { type: NodeType }>\n>(type: NodeType, ...args: Node['args']): Node {\n  const node = {\n    type,\n    args,\n  } as unknown as Node;\n\n  return node;\n}\n\nexport const block = (...contents: AST.Statement[]) => n('block', ...contents);\n\ntype LitType = number | bigint | string | boolean | DeciNumber;\nexport function l(value: LitType): AST.Literal {\n  if (value instanceof DeciNumber) {\n    return n('literal', 'number', value);\n  }\n  const t = typeof value;\n  if (t === 'number' || t === 'bigint') {\n    const fraction = N(value as number | bigint);\n    return n('literal', 'number', fraction);\n  } else if (t === 'boolean') {\n    return n('literal', 'boolean', value as boolean);\n  } else {\n    return n('literal', 'string', value as string);\n  }\n}\n\nexport function num(\n  num: DeciNumber | number | bigint,\n  format?: AST.NumberFormat\n) {\n  const numberFrac = N(num);\n\n  if (format) {\n    return n('literal', 'number', numberFrac, format);\n  } else {\n    return n('literal', 'number', numberFrac);\n  }\n}\n\nexport function col(...values: (LitType | AST.Expression)[]): AST.Column {\n  return n(\n    'column',\n    n(\n      'column-items',\n      ...values.map((value) => (isExpression(value) ? value : l(value)))\n    )\n  );\n}\n\nexport const genericIdent = (name: string) => n('generic-identifier', name);\n\nexport function indexedCol(\n  indexName: string | null,\n  ...values: (LitType | AST.Expression)[]\n): AST.Column {\n  return n(\n    'column',\n    n(\n      'column-items',\n      ...values.map((value) => (isExpression(value) ? value : l(value)))\n    ),\n    indexName != null ? genericIdent(indexName) : undefined\n  );\n}\n\nexport function seq(\n  start: AST.Expression,\n  end: AST.Expression,\n  by: AST.Expression | null = null\n): AST.Sequence {\n  if (by) {\n    return n('sequence', start, end, by);\n  } else {\n    return n('sequence', start, end);\n  }\n}\n\nexport function range(\n  start: LitType | AST.Expression,\n  end: LitType | AST.Expression\n): AST.Range {\n  const startExpr = isExpression(start) ? start : l(start);\n  const endExpr = isExpression(end) ? end : l(end);\n  return n('range', startExpr, endExpr);\n}\n\nexport function table(\n  name: string,\n  items: Record<string, AST.Expression>\n): AST.Table {\n  const args: AST.Table['args'] = [n('tabledef', name)];\n\n  for (const [key, value] of Object.entries(items)) {\n    args.push(n('table-column', n('coldef', key), value));\n  }\n\n  return n('table', ...args);\n}\n\nexport function tableDef(\n  name: string,\n  columns: Record<string, AST.Expression>\n): AST.Table {\n  return table(name, columns);\n}\n\nexport function tableColAssign(\n  tableName: string,\n  columnName: string,\n  value: AST.Expression\n): AST.TableColumnAssign {\n  return n(\n    'table-column-assign',\n    n('tablepartialdef', tableName),\n    n('coldef', columnName),\n    value\n  );\n}\n\nexport const matrixAssign = (\n  name: string,\n  matchers: AST.Expression[],\n  value: AST.Expression\n) =>\n  n('matrix-assign', n('def', name), n('matrix-matchers', ...matchers), value);\n\nexport const matrixRef = (name: string, matchers: AST.Expression[]) =>\n  n('matrix-ref', n('ref', name), n('matrix-matchers', ...matchers));\n\nexport const categories = (name: string, catContents: AST.Expression) =>\n  n('categories', n('catdef', name), catContents);\n\nexport const assign = (name: string, value: AST.Expression) =>\n  n('assign', n('def', name), value);\n\nexport function c(fName: string, ...args: AST.Expression[]) {\n  return n('function-call', n('funcref', fName), n('argument-list', ...args));\n}\n\nexport function r(fName: string) {\n  return n('ref', fName);\n}\n\nexport function as(left: AST.Expression, units: AST.Expression) {\n  return n('directive', 'as', left, units);\n}\n\nexport function match(...defs: AST.MatchDef[]) {\n  return n('match', ...defs);\n}\n\nexport function matchDef(cond: AST.Expression, value: AST.Expression) {\n  return n('matchdef', cond, value);\n}\n\nexport function tiered(arg: AST.Expression, ...defs: AST.TieredDef[]) {\n  return n('tiered', arg, ...defs);\n}\n\nexport function tieredDef(tier: AST.Expression, value: AST.Expression) {\n  return n('tiered-def', tier, value);\n}\n\nexport function funcDef(\n  fName: string,\n  args: string[],\n  ...body: AST.Statement[]\n) {\n  return n(\n    'function-definition',\n    n('funcdef', fName),\n    n('argument-names', ...args.map((a) => n('def', a))),\n    n('block', ...body)\n  );\n}\n\nexport function prop(thing: string | AST.Expression, propName: string) {\n  const asExp = typeof thing === 'string' ? n('ref', thing) : thing;\n  return n('property-access', asExp, propName);\n}\n\nexport function getOfType<\n  K extends AST.Node['type'],\n  N extends Extract<AST.Node, { type: K }>\n>(desiredType: K, node: AST.Node): N {\n  if (getDefined(node).type !== desiredType) {\n    throw new Error(`getOfType: expected ${desiredType}, found ${node.type}`);\n  } else {\n    return node as N;\n  }\n}\n\nexport const isNode = (value: unknown | AST.Node): value is AST.Node => {\n  if (value == null || typeof value !== 'object' || Array.isArray(value)) {\n    return false;\n  } else {\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    const v = value as any;\n\n    return typeof v.type === 'string' && Array.isArray(v.args);\n  }\n};\n\nconst expressionTypesSet = new Set([\n  'function-call',\n  'ref',\n  'external-ref',\n  'property-access',\n  'literal',\n  'column',\n  'range',\n  'sequence',\n  'date',\n  'matrix-ref',\n  'directive',\n  'match',\n  'tiered',\n]);\n\nexport const isExpression = (\n  value: unknown | AST.Expression\n): value is AST.Expression =>\n  isNode(value) && expressionTypesSet.has(value.type);\n\nconst statementTypesSet = new Set([\n  'matrix-assign',\n  'categories',\n  'assign',\n  'table',\n  'function-definition',\n]);\n\nexport const isStatement = (value: unknown): value is AST.Statement =>\n  isNode(value) && statementTypesSet.has(value.type);\n\nconst assignmentTypesSet = new Set([\n  'assign',\n  'table',\n  'matrix-assign',\n  'function-definition',\n  'table-column-assign',\n]);\n\nexport const isAssignment = (value: unknown): value is AST.GenericAssignment =>\n  isNode(value) && assignmentTypesSet.has(value.type);\n\nconst identifierTypesSet = new Set([\n  'ref',\n  'catdef',\n  'def',\n  'tabledef',\n  'tablepartialdef',\n  'funcdef',\n  'generic-identifier',\n  'funcref',\n  'coldef',\n  'externalref',\n]);\n\nexport const isIdentifier = (value: unknown): value is AST.Identifier =>\n  isNode(value) && identifierTypesSet.has(value.type);\n\nexport function assertIdentifier(\n  value: unknown\n): asserts value is AST.Identifier {\n  if (!isIdentifier(value)) {\n    throw new TypeError(\n      `panic: identifier expected on node of type ${\n        (value as AST.Statement)?.type\n      } and arg[0] of type ${typeof (value as AST.Statement)?.args[0]}`\n    );\n  }\n}\n\nexport const getIdentifierString = (node: AST.Identifier): string => {\n  assertIdentifier(node);\n  const { args } = node;\n  return args[0];\n};\n\nexport type ErrorMessage = string | (() => string);\n\nexport const getDefined = <T>(\n  anything: T | null | undefined,\n  message: ErrorMessage = 'getDefined did not expect null or undefined'\n): T => {\n  if (anything == null) {\n    throw new Error(\n      `panic: ${typeof message === 'function' ? message() : message}`\n    );\n  } else {\n    return anything;\n  }\n};\n\nexport const getInstanceof = <T>(\n  thing: T | unknown,\n  cls: Class<T>,\n  message?: string\n): T => {\n  if (thing instanceof cls) {\n    return thing as T;\n  } else {\n    throw new Error(\n      `panic: ${\n        message ??\n        `getInstanceof expected an instance of ${\n          cls?.name ?? 'a specific class'\n        } and got ${\n          (thing as { constructor: { name: string } })?.constructor?.name\n        }`\n      }`\n    );\n  }\n};\n\nexport const zip = <K, V>(keys: K[], values: V[]): [K, V][] => {\n  if (keys.length !== values.length) {\n    throw new Error('panic: cannot zip arrays of different lengths');\n  }\n\n  const out = [];\n\n  for (let i = 0; i < keys.length; i++) {\n    const pair: [K, V] = [keys[i], values[i]];\n    out.push(pair);\n  }\n\n  return out;\n};\n\n/** Filter two same-length arrays. Calls `filterFn` with each pair. */\nexport const filterUnzipped = <K, V>(\n  keys: K[],\n  values: V[],\n  filterFn: (key: K, val: V) => boolean\n): [K[], V[]] => {\n  if (keys.length !== values.length) {\n    throw new Error('panic: cannot filter arrays of different lengths');\n  }\n\n  const outKeys: K[] = [];\n  const outValues: V[] = [];\n  for (let i = 0; i < keys.length; i++) {\n    if (filterFn(keys[i], values[i])) {\n      outKeys.push(keys[i]);\n      outValues.push(values[i]);\n    }\n  }\n\n  return [outKeys, outValues];\n};\n\nexport function* enumerate<T>(items: Iterable<T>): Generator<[number, T]> {\n  let index = 0;\n  for (const item of items) {\n    yield [index, item];\n    index++;\n  }\n}\n\nexport function* pairwise<T1, T2>(array: (T1 | T2)[]) {\n  for (let i = 0; i < array.length - 1; i += 2) {\n    yield [array[i], array[i + 1]] as [T1, T2];\n  }\n}\n\nexport function equalOrUndefined<T>(\n  a: T | null | undefined,\n  b: T | null | undefined\n) {\n  if (a == null || b == null) {\n    return true;\n  }\n  return a === b;\n}\n\nexport function identity<T>(o: T): T {\n  return o;\n}\n\nexport function invert(\n  f: (n: DeciNumber) => DeciNumber\n): (n: DeciNumber) => DeciNumber {\n  const reversingFactor = f(ONE).inverse();\n  return (n) => n.mul(reversingFactor);\n}\n\nexport function u(unit: string | Unit, opts: Partial<Unit> = {}): Unit {\n  if (typeof unit === 'string') {\n    unit = {\n      unit,\n      exp: N(1),\n      multiplier: N(1),\n      known: true,\n    };\n  }\n  return { ...unit, ...opts };\n}\n\nexport function U(units: string | Unit | Unit[], opts?: Partial<Unit>): Unit[] {\n  const unitsArr = Array.isArray(units) ? units : [units];\n  return unitsArr.map((unit) => u(unit, opts));\n}\n\n// ne = number expression\nexport function ne(n: number, unit: string): AST.Expression {\n  return {\n    type: 'function-call',\n    args: [\n      {\n        type: 'funcref',\n        args: ['implicit*'],\n      },\n      {\n        type: 'argument-list',\n        args: [l(n), r(unit)],\n      },\n    ],\n  };\n}\n\nexport function multiplyMultipliers(\n  units: Unit[] | undefined | null,\n  start: DeciNumber = ONE\n): DeciNumber {\n  if (!units) {\n    return start;\n  }\n  let acc = start;\n  for (const unit of units) {\n    acc = acc.mul(unit.multiplier.pow(unit.exp));\n  }\n  return acc;\n}\n\nexport function safeNumberForPrecision(n: DeciNumber): [number, number] {\n  const rounded = n.round(MAX_PRECISION).valueOf();\n  const precise = n.valueOf();\n  return [\n    rounded,\n    Number.isNaN(precise) || !Number.isFinite(precise) ? rounded : precise,\n  ];\n}\n","import { AnyMapping, anyMappingToMap, getDefined } from '@decipad/utils';\n\nexport type VarGroup =\n  // Global variables\n  | 'global'\n  // Arguments and variables in the current function\n  | 'function'\n  // The temporary scope (and if not found, function and global)\n  | 'lexical';\n\n/** Take a mapping of keys to values and join it. Used to join tables */\nexport type StackNamespaceJoiner<T> = (\n  x: ReadonlyMap<string, T>,\n  nsName: string\n) => T;\n\n/** Take a stack item and split it. Used to split tables ondemand */\nexport type StackNamespaceSplitter<T> = (\n  x: T\n) => Iterable<[string, T]> | undefined;\n\n/**\n * MASSIVE HACK\n * Language tables contain the types of \"CELLS\", not the types of the columns. So we need a callback to raise the dimension of the cells to the column-level.\n */\nexport type StackNamespaceRetrieverHackForTypesystemTables<T> = (\n  x: T,\n  container: T\n) => T;\n\n/**\n * Holds scopes, which are maps of variable names to things like Type,\n * Value or whatever!\n *\n * Split into a global scope (always present and visible) and temporary scopes,\n * which you can .push and .pop from as you go into and out of tables or\n * other places where names are temporarily defined.\n *\n * When calling a function, use .pushFunction and .popFunction to replace the\n * temporary scopes and leave only the global variables and a local scope available.\n */\nexport class Stack<T> {\n  private globalScope: Map<string, Map<string, T>>;\n\n  /** Current function scope. Cannot be lexically nested */\n  private functionScope: Map<string, Map<string, T>> | undefined = undefined;\n  /** Non-call scopes that can be pushed and popped. Used within tables for storing column names */\n  private temporaryScopes: Map<string, Map<string, T>>[] = [];\n  private namespaceJoiner: StackNamespaceJoiner<T>;\n  private namespaceSplitter: StackNamespaceSplitter<T>;\n  private namespaceRetriever: StackNamespaceRetrieverHackForTypesystemTables<T>;\n\n  private idMap = new Map<string, readonly [string, string]>();\n\n  constructor(\n    initialGlobalScope: AnyMapping<T> | undefined,\n    namespaceJoiner: StackNamespaceJoiner<T>,\n    namespaceSplitter: StackNamespaceSplitter<T>,\n    namespaceRetriever: StackNamespaceRetrieverHackForTypesystemTables<T> = (\n      x\n    ) => x\n  ) {\n    this.globalScope = new Map([\n      ['', anyMappingToMap(initialGlobalScope ?? new Map())],\n    ]);\n    this.namespaceJoiner = namespaceJoiner;\n    this.namespaceSplitter = namespaceSplitter;\n    this.namespaceRetriever = namespaceRetriever;\n  }\n\n  private *getVisibleScopes(varGroup: VarGroup = 'lexical') {\n    if (varGroup === 'lexical') {\n      for (let i = this.temporaryScopes.length - 1; i >= 0; i--) {\n        yield this.temporaryScopes[i];\n      }\n    }\n    if (\n      this.functionScope &&\n      (varGroup === 'lexical' || varGroup === 'function')\n    ) {\n      yield this.functionScope;\n    }\n    yield this.globalScope;\n  }\n\n  private getAssignmentScope(varGroup: VarGroup = 'lexical') {\n    if (varGroup === 'lexical' && this.temporaryScopes.length) {\n      return this.temporaryScopes[this.temporaryScopes.length - 1];\n    }\n    if (\n      this.functionScope &&\n      (varGroup === 'function' || varGroup === 'lexical')\n    ) {\n      return this.functionScope;\n    }\n    return this.globalScope;\n  }\n\n  get isInGlobalScope() {\n    return !this.functionScope;\n  }\n\n  isNameGlobal(\n    [ns, name]: readonly [string, string],\n    varGroup: VarGroup = 'lexical'\n  ) {\n    for (const scope of this.getVisibleScopes(varGroup)) {\n      if ((ns === '' && scope.has(name)) || scope.get(ns)?.has(name)) {\n        return scope === this.globalScope;\n      }\n    }\n    return false;\n  }\n\n  get globalVariables(): ReadonlyMap<string, T> {\n    const out = new Map<string, T>();\n\n    for (const [ns, scope] of this.globalScope.entries()) {\n      if (ns !== '') out.set(ns, this.namespaceJoiner(scope, ns));\n      else {\n        for (const [key, val] of scope.entries()) {\n          out.set(key, val);\n        }\n      }\n    }\n\n    return out;\n  }\n\n  get namespaces(): Iterable<[string, ReadonlyMap<string, T>]> {\n    return (function* getNs(globals) {\n      for (const [ns, items] of globals.entries()) {\n        if (ns !== '') yield [ns, items];\n      }\n    })(this.globalScope);\n  }\n\n  getNamespace(ns: string, varGroup: VarGroup) {\n    for (const scope of this.getVisibleScopes(varGroup)) {\n      const namespace = scope.get(ns);\n      if (namespace) return namespace;\n    }\n\n    return undefined;\n  }\n\n  getNsNameFromId(id: string) {\n    return this.idMap.get(id);\n  }\n\n  createNamespace(ns: string, varGroup: VarGroup = 'lexical') {\n    const scope = this.getAssignmentScope(varGroup);\n    if (scope.get('')?.get(ns)) {\n      throw new Error(`panic: cannot create the namespace ${ns}`);\n    }\n    if (!scope.has(ns)) scope.set(ns, new Map());\n  }\n\n  set(\n    varName: string,\n    value: T,\n    varGroup: VarGroup = 'lexical',\n    id: string | undefined = undefined\n  ) {\n    return this.setNamespaced(['', varName], value, varGroup, id);\n  }\n\n  setNamespaced(\n    [ns, name]: readonly [namespace: string, name: string],\n    value: T,\n    varGroup: VarGroup,\n    id: string | undefined = undefined\n  ) {\n    let asSplitNs;\n    if (ns === '' && (asSplitNs = this.namespaceSplitter(value))) {\n      this.createNamespace(name);\n      for (const [colName, value] of asSplitNs) {\n        this.setNamespaced([name, colName], value, varGroup, id);\n      }\n      return;\n    }\n\n    if (id && this.isInGlobalScope && !this.temporaryScopes.length) {\n      // Only set the ID if we're not in a global scope\n      this.idMap.set(id, [ns, name]);\n    }\n\n    const map = this.getAssignmentScope(varGroup);\n\n    if (ns === '' && map.has(name)) {\n      throw new Error(\n        `panic: assigning a value to an existing namespace ${name}`\n      );\n    }\n    let subMap = map.get(ns);\n    if (!subMap) {\n      map.set(ns, (subMap = new Map()));\n    }\n    subMap.set(name, value);\n  }\n\n  setMulti(variables: AnyMapping<T>, varGroup: VarGroup = 'lexical') {\n    for (const [k, v] of anyMappingToMap(variables).entries()) {\n      this.set(k, v, varGroup);\n    }\n  }\n\n  has(varName: string, varGroup: VarGroup = 'lexical') {\n    return this.hasNamespaced(['', varName], varGroup);\n  }\n\n  hasNamespaced(\n    [ns, name]: [namespace: string, name: string],\n    varGroup: VarGroup\n  ) {\n    for (const scope of this.getVisibleScopes(varGroup)) {\n      if (ns === '' && scope.has(name)) return true;\n      if (scope.get(ns)?.has(name)) return true;\n    }\n    return false;\n  }\n\n  get(varName: string, varGroup: VarGroup = 'lexical') {\n    return this.getNamespaced(['', varName], varGroup);\n  }\n\n  getNamespaced(\n    [ns, name]: readonly [namespace: string, name: string],\n    varGroup: VarGroup\n  ): T | null {\n    const foundWithId = ns === '' && this.idMap.get(name);\n    if (foundWithId) {\n      return this.getNamespaced(foundWithId, varGroup);\n    }\n\n    for (const scope of this.getVisibleScopes(varGroup)) {\n      if (ns === '' && scope.has(name)) {\n        return this.namespaceJoiner(getDefined(scope.get(name)), name);\n      }\n\n      if (scope.get(ns)?.has(name)) {\n        let value = getDefined(scope.get(ns)?.get(name));\n        if (ns !== '') {\n          value = this.namespaceRetriever(\n            value,\n            getDefined(this.get(ns, varGroup))\n          );\n        }\n        return getDefined(value);\n      }\n    }\n\n    return null;\n  }\n\n  delete(varName: string, varGroup: VarGroup = 'lexical') {\n    return this.deleteNamespaced(['', varName], varGroup);\n  }\n\n  deleteNamespaced(\n    [ns, name]: readonly [namespace: string, name: string],\n    varGroup: VarGroup\n  ) {\n    for (const scope of this.getVisibleScopes(varGroup)) {\n      if (ns === '' && scope.has(name)) {\n        scope.delete(name);\n      }\n\n      if (scope.get(ns)?.has(name)) {\n        scope.get(ns)?.delete(name);\n        return;\n      }\n    }\n  }\n\n  async withPush<T>(wrapper: () => Promise<T>): Promise<T> {\n    this.temporaryScopes.push(new Map());\n\n    try {\n      return await wrapper();\n    } finally {\n      getDefined(this.temporaryScopes.pop());\n    }\n  }\n\n  async withPushCall<T>(wrapper: () => Promise<T>): Promise<T> {\n    const preCallTemporaryScope = this.temporaryScopes;\n    const preCallFunctionScope = this.functionScope;\n\n    this.temporaryScopes = [];\n    this.functionScope = new Map();\n\n    try {\n      return await wrapper();\n    } finally {\n      this.temporaryScopes = preCallTemporaryScope;\n      this.functionScope = preCallFunctionScope;\n    }\n  }\n}\n","import { AnyMapping, anyMappingToMap, zip } from '@decipad/utils';\n\nimport { AST, ExternalDataMap } from '..';\nimport { Type, SerializedType, build as t } from '../type';\nimport {\n  Stack,\n  StackNamespaceJoiner,\n  StackNamespaceSplitter,\n  StackNamespaceRetrieverHackForTypesystemTables,\n  VarGroup,\n} from '../stack';\nimport { Result } from '../result';\n\nexport interface Context {\n  stack: Stack<Type>;\n  functionDefinitions: Map<string, AST.FunctionDefinition>;\n  previous?: Type;\n  inTableBraces?: string | null;\n  nodeTypes: Map<AST.Node, Type>;\n  externalData: ExternalDataMap;\n  previousStatement?: SerializedType;\n  autoGeneratedVarNames: Set<string>;\n  statementId?: string;\n  /** Marks names retrieved during typecheck */\n  usedNames?: (readonly [string, string])[];\n}\n\ninterface MakeContextArgs {\n  initialGlobalScope: AnyMapping<Type>;\n  initialTables: AnyMapping<Type>;\n  externalData: AnyMapping<Result>;\n  autoGeneratedVarNames: Set<string>;\n}\n\nexport const makeContext = ({\n  initialGlobalScope = new Map(),\n  externalData = new Map(),\n  autoGeneratedVarNames = new Set(),\n}: Partial<MakeContextArgs> = {}): Context => {\n  return {\n    stack: new Stack(\n      initialGlobalScope,\n      typesToTable,\n      tableToTypes,\n      getTableColumnAsAGoddamnColumn\n    ),\n    functionDefinitions: new Map(),\n    nodeTypes: new Map(),\n    externalData: anyMappingToMap(externalData),\n    autoGeneratedVarNames,\n    usedNames: undefined,\n  };\n};\n\nconst typesToTable: StackNamespaceJoiner<Type> = (tableMapping, indexName) =>\n  t.table({\n    indexName,\n    columnNames: [...tableMapping.keys()],\n    columnTypes: [...tableMapping.values()],\n  });\n\nconst tableToTypes: StackNamespaceSplitter<Type> = (tableMapping) => {\n  if (tableMapping.columnNames && tableMapping.columnTypes) {\n    return zip(tableMapping.columnNames, tableMapping.columnTypes);\n  }\n  return undefined;\n};\n\nconst getTableColumnAsAGoddamnColumn: StackNamespaceRetrieverHackForTypesystemTables<\n  Type\n> = (column, table) => {\n  return t.column(column, undefined, table.indexName);\n};\n\n/** Push the stack and set Context.previous for the duration of `fn` */\nexport const pushTableContext = async <T>(\n  ctx: Context,\n  tableName: string | null,\n  fn: () => Promise<T>\n): Promise<T> => {\n  const previousPrevious = ctx.previous;\n  const previousTable = ctx.inTableBraces;\n  ctx.inTableBraces = tableName;\n  try {\n    return await ctx.stack.withPush(fn);\n  } finally {\n    ctx.previous = previousPrevious;\n    ctx.inTableBraces = previousTable;\n  }\n};\n\nexport const logRetrievedName = (\n  ctx: Context,\n  name: string | readonly [string, string],\n  group: VarGroup = 'lexical'\n) => {\n  const nsName = typeof name === 'string' ? (['', name] as const) : name;\n  const tableName = nsName[0] === '' ? nsName[1] : nsName[0];\n  if (\n    ctx.usedNames &&\n    ctx.stack.isNameGlobal(nsName, group) &&\n    tableName !== ctx.inTableBraces\n  ) {\n    ctx.usedNames.push(nsName);\n  }\n};\n\nexport const logRetrievedFunctionName = (ctx: Context, name: string) => {\n  if (ctx.usedNames && ctx.functionDefinitions.has(name)) {\n    ctx.usedNames.push(['', name]);\n  }\n};\n","import { Type } from '../type';\nimport { linearizeType } from '../dimtools/common';\nimport { dimSwapTypes, dimSwapValues } from '../dimtools';\nimport {\n  Column,\n  ColumnLike,\n  isColumnLike,\n  Value,\n  RuntimeError,\n} from '../value';\n\n/**\n * This module specifies how tables work with 0-dimensional and 2+ dimensional columns.\n *\n * Here's how they work!\n *\n * ```\n * Tbl = { A = 1 }  # Has 1 row\n * Tbl = { Sizer = [1, 2, 3], A = 1 }  # A turns into [1, 2, 3]\n * Tbl = { A = 1, Sizer = [1, 2, 3] }  # Crash! Inconsistent column sizes\n * Tbl = { Nums = [1, 2], TwoD = Tbl.Nums * OtherTable.Nums }  # TwoD indexed by [Tbl, OtherTable.Nums]\n * Tbl = { Nums = [1, 2], TwoD = OtherTable.Nums * Tbl.Nums }  # Same as above even though the operation would've flipped dims\n * ```\n */\n\n/** Make {type} columnar and place {indexName} on top if {type} more than 1D */\nexport const coerceTableColumnTypeIndices = (type: Type, indexName: string) => {\n  if (type.columnSize == null) {\n    // Because we're so very nice, allow `Column = 1` as syntax sugar.\n    return type;\n  } else if (linearizeType(type).some((t) => t.indexedBy === indexName)) {\n    return dimSwapTypes(indexName, type).reduced();\n  } else {\n    // We want our table index on top\n    return type.reduced();\n  }\n};\n\nexport const coerceTableColumnIndices = (\n  type: Type,\n  value: ColumnLike | Value,\n  indexName: string,\n  tableLength?: number\n): ColumnLike => {\n  if (!isColumnLike(value)) {\n    return Column.fromValues(repeat(value, tableLength ?? 1));\n  } else if (linearizeType(type).some((t) => t.indexedBy === indexName)) {\n    return validateLength(dimSwapValues(indexName, type, value), tableLength);\n  } else {\n    return validateLength(value, tableLength);\n  }\n};\n\nconst repeat = <T>(value: T, length: number) =>\n  Array.from({ length }, () => value);\n\nconst validateLength = (value: ColumnLike, wanted: number | undefined) => {\n  if (wanted != null && wanted !== value.rowCount) {\n    // UI tables will never place us in this situation\n    throw new RuntimeError('Inconsistent table column sizes');\n  }\n  return value;\n};\n","import { getDefined } from '@decipad/utils';\n\nimport type { AST } from '..';\nimport { Type, build as t, InferError } from '../type';\nimport { getIdentifierString, walkAst } from '../utils';\nimport { inferExpression, linkToAST } from '../infer';\nimport { Context, pushTableContext } from '../infer/context';\nimport { coerceTableColumnTypeIndices } from './dimensionCoersion';\n\nexport const inferTable = async (ctx: Context, table: AST.Table) => {\n  if (!ctx.stack.isInGlobalScope) {\n    return t.impossible(InferError.forbiddenInsideFunction('table'));\n  }\n\n  const tableName = getIdentifierString(table.args[0]);\n  if (ctx.stack.has(tableName, 'function')) {\n    return t.impossible(InferError.duplicatedName(tableName));\n  }\n\n  if (table.args.some((a) => a.type === 'table-spread')) {\n    const ret = t.impossible(InferError.retiredFeature('table-spread'));\n    ctx.stack.set(tableName, ret, 'function', ctx.statementId);\n    return ret;\n  }\n\n  const tableType = pushTableContext(ctx, tableName, async () => {\n    ctx.stack.createNamespace(tableName, 'function');\n\n    for (const tableItem of table.args.slice(1)) {\n      if (tableItem.type === 'table-column') {\n        // eslint-disable-next-line no-await-in-loop\n        await inferTableColumn(ctx, {\n          tableName,\n          columnAst: tableItem,\n          columnName: getIdentifierString(tableItem.args[0]),\n        });\n      } else {\n        throw new Error('panic: unreachable');\n      }\n    }\n\n    return getDefined(ctx.stack.get(tableName, 'function'));\n  });\n\n  return tableType;\n};\n\nexport async function inferTableColumn(\n  ctx: Context,\n  {\n    columnAst,\n    tableName,\n    columnName,\n  }: {\n    columnAst: AST.TableColumnAssign | AST.TableColumn;\n    tableName: string;\n    columnName: string;\n  }\n): Promise<Type> {\n  ctx.stack.createNamespace(tableName, 'function');\n  const otherColumns = getDefined(\n    ctx.stack.getNamespace(tableName, 'function')\n  );\n\n  const exp: AST.Expression =\n    columnAst.type === 'table-column' ? columnAst.args[1] : columnAst.args[2];\n\n  const type = await pushTableContext(ctx, tableName, async () => {\n    if (refersToOtherColumnsByName(exp, otherColumns)) {\n      return inferTableColumnPerCell(ctx, otherColumns, exp);\n    } else {\n      return coerceTableColumnTypeIndices(\n        await inferExpression(ctx, exp),\n        tableName\n      );\n    }\n  });\n\n  linkToAST(ctx, columnAst, type);\n\n  if (type.errorCause) {\n    return type;\n  }\n\n  ctx.stack.setNamespaced(\n    [tableName, columnName],\n    type,\n    'function',\n    ctx.statementId\n  );\n\n  return type;\n}\n\nexport async function inferTableColumnPerCell(\n  ctx: Context,\n  otherColumns: Map<string, Type>,\n  columnAst: AST.Expression\n) {\n  // Make other cells in this row available\n  for (const [otherColumnName, otherColumn] of otherColumns.entries()) {\n    ctx.stack.set(otherColumnName, otherColumn);\n  }\n\n  return inferExpression(ctx, columnAst);\n}\n\nexport function refersToOtherColumnsByName(\n  expr: AST.Expression,\n  columns: Map<string, unknown>\n) {\n  let isReferringToOtherColumnByName = false;\n\n  walkAst(expr, (node) => {\n    if (node.type === 'ref') {\n      const name = getIdentifierString(node);\n\n      if (columns.has(name)) {\n        isReferringToOtherColumnByName = true;\n      }\n    }\n  });\n\n  return isReferringToOtherColumnByName;\n}\n","// Accumulate values into a list by consuming an async iterable.\n\nimport { Value } from '../value';\nimport { Realm } from './Realm';\n\n// Accumulates values into an array by consuming async iterable of values.\n// Manages realm.previousValue too.\nexport const mapWithPrevious = async (\n  realm: Realm,\n  iter: () => AsyncIterable<Value>\n) => {\n  const ret: Value[] = [];\n\n  // mapWithPrevious can be called again during iter()\n  // For example with nested `given`\n  const savedPrevious = realm.previousValue;\n  realm.previousValue = null;\n\n  for await (const result of iter()) {\n    ret.push(result);\n    realm.previousValue = result;\n  }\n\n  realm.previousValue = savedPrevious;\n\n  return ret;\n};\n","import { Realm } from '../interpreter';\n\n/** If the typecheck failed, we don't execute */\nexport const shouldEvaluate = (\n  realm: Realm,\n  tableName: string,\n  columnName: string\n) => {\n  const type = realm.inferContext.stack.getNamespaced(\n    [tableName, columnName],\n    'function'\n  );\n  return type != null && type.errorCause == null;\n};\n","import { getDefined } from '@decipad/utils';\nimport { AST } from '..';\nimport { refersToOtherColumnsByName } from './inference';\nimport { Column, ColumnLike, Row, Table, Value } from '../value';\nimport { mapWithPrevious } from '../interpreter/previous';\nimport {\n  walkAst,\n  getIdentifierString,\n  isExpression,\n  getInstanceof,\n} from '../utils';\nimport { Realm, evaluate } from '../interpreter';\nimport { coerceTableColumnIndices } from './dimensionCoersion';\nimport { shouldEvaluate } from './shouldEvaluate';\n\nconst isRecursiveReference = (expr: AST.Expression) =>\n  expr.type === 'function-call' &&\n  getIdentifierString(expr.args[0]) === 'previous';\n\nexport const usesRecursion = (expr: AST.Expression) => {\n  let result = false;\n\n  walkAst(expr, (expr) => {\n    if (isExpression(expr) && isRecursiveReference(expr)) {\n      result = true;\n    }\n  });\n\n  return result;\n};\n\nexport const evaluateTableColumn = async (\n  realm: Realm,\n  tableColumns: Map<string, ColumnLike>,\n  column: AST.Expression,\n  indexName: string,\n  rowCount?: number\n): Promise<ColumnLike> => {\n  if (\n    refersToOtherColumnsByName(column, tableColumns) ||\n    usesRecursion(column)\n  ) {\n    return evaluateTableColumnIteratively(\n      realm,\n      tableColumns,\n      column,\n      rowCount ?? 1\n    );\n  }\n\n  // Evaluate the column as a whole\n  return coerceTableColumnIndices(\n    realm.getTypeAt(column),\n    await evaluate(realm, column),\n    indexName,\n    rowCount\n  );\n};\n\nexport const evaluateTableColumnIteratively = async (\n  realm: Realm,\n  otherColumns: Map<string, ColumnLike>,\n  column: AST.Expression,\n  rowCount: number\n): Promise<ColumnLike> =>\n  realm.stack.withPush(async () => {\n    const cells = await mapWithPrevious(realm, async function* mapper() {\n      for (let index = 0; index < rowCount; index++) {\n        // Make other cells available\n        for (const [otherColName, otherCol] of otherColumns) {\n          realm.stack.set(otherColName, otherCol.atIndex(index));\n        }\n        // eslint-disable-next-line no-await-in-loop\n        yield evaluate(realm, column);\n      }\n    });\n\n    return Column.fromValues(cells);\n  });\n\nexport const evaluateTable = async (\n  realm: Realm,\n  table: AST.Table\n): Promise<Table> => {\n  const tableColumns = new Map<string, ColumnLike>();\n  const {\n    args: [tName, ...items],\n  } = table;\n\n  const tableName = getIdentifierString(tName);\n  const indexName = getDefined(realm.getTypeAt(table).indexName);\n\n  realm.stack.createNamespace(tableName, 'function');\n\n  let tableLength: number | undefined;\n  return realm.stack.withPush(async () => {\n    const addColumn = (name: string, value: ColumnLike) => {\n      tableLength ??= value.rowCount;\n\n      tableColumns.set(name, value);\n      realm.stack.setNamespaced(\n        [tableName, name],\n        value,\n        'function',\n        realm.statementId\n      );\n    };\n\n    for (const item of items) {\n      if (item.type === 'table-column') {\n        const [def, column] = item.args;\n        const colName = getIdentifierString(def);\n\n        if (!shouldEvaluate(realm, tableName, colName)) {\n          // Avoid differing type and value\n          continue;\n        }\n\n        // eslint-disable-next-line no-await-in-loop\n        const columnData = await evaluateTableColumn(\n          realm,\n          tableColumns,\n          column,\n          indexName,\n          tableLength\n        );\n\n        addColumn(colName, columnData);\n      } else if (item.type === 'table-spread') {\n        throw new Error('unreachable retired feature');\n      } else {\n        throw new Error('panic: unreachable');\n      }\n    }\n\n    return getInstanceof(\n      getDefined(realm.stack.get(tableName, 'function')),\n      Table\n    );\n  });\n};\n\nexport const getProperty = (object: Value, property: string): Value => {\n  if (object instanceof Row) {\n    return object.getCell(property);\n  } else {\n    return getInstanceof(object, Table).getColumn(property);\n  }\n};\n","import DeciNumber, { N, ONE, ZERO } from '@decipad/number';\nimport { getDefined } from '@decipad/utils';\nimport { AST, Time, DateValue } from '..';\nimport { getIdentifierString, getOfType } from '../utils';\nimport { InferError, build as t, Type } from '../type';\nimport {\n  dateToArray,\n  getJSDateUnitAndMultiplier,\n  cmpSpecificities,\n  getSpecificity,\n  getTimeUnit,\n  getDateFromAstForm,\n  dateNodeToTimeUnit,\n  sortTimeUnits,\n} from '../date';\nimport { Context } from './context';\n\nconst millisecondsInDay = 24 * 60 * 60 * 1000;\n\nexport const getNumberSequenceError = (\n  start: DeciNumber,\n  end: DeciNumber,\n  by: DeciNumber\n): InferError | undefined => {\n  const diff = start.compare(end);\n  if (diff === 0) {\n    return undefined;\n  } else if (by.equals(ZERO)) {\n    return InferError.sequenceStepZero();\n  } else if (Math.sign(diff) === by.compare(ZERO)) {\n    return InferError.invalidSequenceStep(\n      start.valueOf(),\n      end.valueOf(),\n      by.valueOf()\n    );\n  } else if (diff > 0) {\n    return getNumberSequenceError(end, start, by.neg());\n  } else {\n    return undefined;\n  }\n};\n\nexport const getNumberSequenceErrorN = (\n  start: number | bigint,\n  end: number | bigint,\n  by: number | bigint\n): InferError | undefined => getNumberSequenceError(N(start), N(end), N(by));\n\ntype SimplerUnit = 'month' | 'day' | 'millisecond';\n\nconst toSimpleTimeUnit: Record<string, [SimplerUnit, number]> = {\n  year: ['month', 12],\n  hour: ['millisecond', 60 * 60 * 1000],\n  minute: ['millisecond', 60 * 1000],\n  second: ['millisecond', 1000],\n};\n\nexport const getDateSequenceError = (\n  start: bigint,\n  end: bigint,\n  boundsSpecificity: Time.Specificity,\n  by: Time.Unit\n): InferError | undefined => {\n  // Get the end of the year, month or day.\n  end = DateValue.fromDateAndSpecificity(end, boundsSpecificity).getEnd();\n\n  let [stepUnit, steps] = getJSDateUnitAndMultiplier(by);\n  if (start > end) {\n    steps = -steps;\n  }\n\n  if (stepUnit in toSimpleTimeUnit) {\n    const [newUnit, multiplier] = toSimpleTimeUnit[stepUnit];\n\n    stepUnit = newUnit;\n    steps *= BigInt(multiplier);\n  }\n\n  switch (stepUnit) {\n    case 'month': {\n      const [startYear, startMonth] = dateToArray(start);\n      const [endYear, endMonth] = dateToArray(end);\n\n      const monthDiff = (endYear - startYear) * 12n + (endMonth - startMonth);\n      return getNumberSequenceErrorN(0, monthDiff, steps);\n    }\n    case 'day': {\n      // Taken from date-fns differenceInCalendarDays\n\n      const differenceInDays = Math.round(\n        Number(end - start) / millisecondsInDay\n      );\n\n      return getNumberSequenceErrorN(0, differenceInDays - 1, steps);\n    }\n    case 'millisecond': {\n      return getNumberSequenceErrorN(start, end, steps);\n    }\n    /* istanbul ignore next */\n    default: {\n      throw new Error(`panic: unexpected step unit ${stepUnit}`);\n    }\n  }\n};\n\nconst tryGetNumber = (n: AST.Expression): DeciNumber | undefined => {\n  if (n.type === 'literal' && n.args[0] === 'number') {\n    return n.args[1];\n  }\n  return undefined;\n};\n\nexport const getDateSequenceIncrement = (\n  byExpr: AST.Expression | void,\n  startUnit: Time.Unit,\n  endUnit: Time.Unit\n) => {\n  if (byExpr) {\n    return getTimeUnit(getIdentifierString(getOfType('ref', byExpr)));\n  }\n\n  return getDefined(sortTimeUnits([startUnit, endUnit]).pop());\n};\n\nexport const inferSequence = async (\n  ctx: Context,\n  expr: AST.Sequence,\n  inferExpression: (ctx: Context, expr: AST.Expression) => Promise<Type>\n): Promise<Type> => {\n  const [startN, endN, byN] = expr.args;\n  const startType = await inferExpression(ctx, startN);\n  const endType = await inferExpression(ctx, endN);\n  const boundTypes = startType.sameAs(endType);\n\n  if (boundTypes.errorCause != null) {\n    return boundTypes;\n  } else if (startN.type === 'date' && endN.type === 'date') {\n    const [start, startSpec] = getDateFromAstForm(startN.args);\n    const [end] = getDateFromAstForm(endN.args);\n    const boundsSpecificity = getSpecificity(startSpec);\n\n    let increment;\n    let specificity;\n\n    try {\n      increment = getDateSequenceIncrement(\n        byN,\n        dateNodeToTimeUnit(startN.args),\n        dateNodeToTimeUnit(endN.args)\n      );\n      specificity = getSpecificity(increment);\n    } catch {\n      return t.impossible('Invalid increment clause in date sequence');\n    }\n\n    if (cmpSpecificities(specificity, boundsSpecificity) < 0) {\n      return t.impossible(`An increment clause of ${increment} is too broad`);\n    }\n\n    const countOrError = getDateSequenceError(\n      start,\n      end,\n      boundsSpecificity,\n      increment\n    );\n\n    return countOrError\n      ? t.impossible(countOrError)\n      : t.column(t.date(specificity));\n  } else {\n    const type = startType.isScalar('number');\n    if (type.errorCause) {\n      return type;\n    }\n    const start = tryGetNumber(startN);\n    const end = tryGetNumber(endN);\n\n    if (start && end) {\n      const by = byN\n        ? tryGetNumber(byN)\n        : start.compare(end) < 0\n        ? ONE\n        : N(-1n);\n      if (by) {\n        const countOrError = getNumberSequenceError(start, end, by);\n        return countOrError instanceof InferError\n          ? t.impossible(countOrError)\n          : t.column(boundTypes, countOrError);\n      }\n    }\n    return t.column(boundTypes, 'unknown');\n  }\n};\n","export const previousRefSymbols = new Set(['_', 'previous']);\n\nexport function isPreviousRef(ref: string): boolean {\n  return previousRefSymbols.has(ref);\n}\n","import { AST, Context } from '..';\nimport { Realm, RuntimeError } from '../interpreter';\nimport { isColumnLike } from '../value';\nimport { build as t, Type, InferError } from '../type';\nimport { getIdentifierString } from '../utils';\n\nexport const getIndexName = (type: Type) =>\n  type.indexedBy ?? type.indexName ?? null;\n\nexport const inferVariable = (\n  context: Context,\n  varName: RefLike,\n  expectedDim?: string | null\n) => {\n  const variable = context.stack.get(refName(varName));\n\n  if (!variable) {\n    return t.impossible(InferError.missingVariable(refName(varName)));\n  } else if (expectedDim && getIndexName(variable) !== expectedDim) {\n    const expectedTable = expectedDim\n      ? context.stack.get(expectedDim)\n      : undefined;\n    return t.impossible(\n      InferError.expectedTableAndAssociatedColumn(expectedTable, variable)\n    );\n  } else {\n    return variable.isColumn();\n  }\n};\n\nexport const evaluateVariable = (realm: Realm, varName: RefLike) => {\n  const variable = realm.stack.get(refName(varName));\n\n  if (!variable) {\n    throw new RuntimeError(InferError.missingVariable(refName(varName)));\n  } else if (!isColumnLike(variable)) {\n    throw new RuntimeError('Expected column');\n  } else {\n    return variable;\n  }\n};\n\ntype RefLike = AST.Ref | AST.Def | string;\nconst refName = (refLike: RefLike) => {\n  if (typeof refLike === 'string') {\n    return refLike;\n  } else {\n    return getIdentifierString(refLike);\n  }\n};\n","import pSeries from 'p-series';\nimport { getOnly } from '@decipad/utils';\nimport { AST, Column, Context } from '..';\nimport { getCardinality } from '../dimtools/common';\nimport { inferExpression, logRetrievedName } from '../infer';\nimport { evaluate, Realm } from '../interpreter';\nimport { compare } from '../value';\nimport { build as t, Type, InferError } from '../type';\nimport { getIdentifierString, getOfType } from '../utils';\nimport type { NumberValue, Value } from '../value';\nimport { evaluateVariable, getIndexName } from './getVariable';\n\n/** Read inside the square brackets */\nexport const readSimpleMatchers = (ctx: Context, matcher: AST.Expression) => {\n  if (matcher.type === 'ref') {\n    const dimensionName = getIdentifierString(matcher);\n    // VariableName[DimensionName]\n    logRetrievedName(ctx, dimensionName);\n    return [dimensionName, null] as const;\n  } else {\n    // VariableName[DimensionName == \"Dimension item\"]\n    const [dimNameRef, needleExp] = getOfType('function-call', matcher).args[1]\n      .args;\n    const dimName = getIdentifierString(dimNameRef as AST.Def | AST.Ref);\n\n    return [dimName, needleExp] as const;\n  }\n};\n\nexport const matchTargets = async (\n  ctx: Context,\n  realm: Realm,\n  matchers: AST.MatrixMatchers\n): Promise<[number, boolean[]]> => {\n  const matcher = getOnly(matchers.args);\n  const [dimName, needleExp] = readSimpleMatchers(ctx, matcher);\n  const dimension = evaluateVariable(realm, dimName);\n\n  if (needleExp == null) {\n    // VariableName[DimensionName]\n    const { length } = (dimension as Column).values;\n    return [length, Array.from({ length }, () => true)];\n  } else {\n    // VariableName[DimensionName == \"Dimension item\"]\n\n    // We know these are comparable\n    const compareScalars = (a: Value, b: Value) =>\n      compare((a as NumberValue).getData(), (b as NumberValue).getData());\n\n    let length = 0;\n    const matches = await pSeries(\n      dimension.values.map((dimItem) => async () => {\n        const result =\n          compareScalars(dimItem, await evaluate(realm, needleExp)) === 0;\n        if (result) {\n          length++;\n        }\n        return result;\n      })\n    );\n\n    return [length, matches];\n  }\n};\n\nexport const inferMatchers = async (\n  ctx: Context,\n  matchers: AST.MatrixMatchers\n): Promise<Type> => {\n  const matcher = getOnly(matchers.args);\n  const [dimName, needleExp] = readSimpleMatchers(ctx, matcher);\n\n  logRetrievedName(ctx, dimName);\n  const dimension = ctx.stack.get(dimName);\n\n  if (!dimension) {\n    return t.impossible(InferError.missingVariable(dimName));\n  }\n\n  if (getCardinality(dimension) !== 2 && !getIndexName(dimension)) {\n    return t.impossible(\n      InferError.expectedTableAndAssociatedColumn(dimension, undefined)\n    );\n  }\n\n  if (needleExp == null) {\n    // VariableName[DimensionName]\n    return dimension.reduced().isPrimitive();\n  } else {\n    // VariableName[DimensionName == \"Needle\"]\n    return (await inferExpression(ctx, needleExp))\n      .isPrimitive()\n      .sameAs(dimension.reduced());\n  }\n};\n","import { getDefined } from '@decipad/utils';\n\nimport { AST, Column, Type } from '..';\nimport { evaluate, Realm, RuntimeError } from '../interpreter';\nimport { ColumnLike, isColumnLike } from '../value';\nimport { build as t, InferError } from '../type';\nimport { getIndexName } from './getVariable';\nimport { matchTargets } from './matcher';\n\nexport function inferMultidimAssignment(\n  dimension: Type,\n  assignee: Type,\n  // eslint-disable-next-line default-param-last\n  outColumnSize = dimension.columnSize,\n  previousMatrix?: Type\n) {\n  let returnedCellType = assignee;\n  if (assignee.cellType != null) {\n    returnedCellType = assignee.reduced();\n  } else {\n    returnedCellType = assignee;\n  }\n\n  if (previousMatrix) {\n    returnedCellType = returnedCellType.sameAs(previousMatrix.reduced());\n  }\n\n  return t.column(\n    returnedCellType,\n    getDefined(outColumnSize),\n    getIndexName(dimension)\n  );\n}\n\nexport async function evaluateMultidimAssignment(\n  realm: Realm,\n  node: AST.MatrixAssign,\n  dimension: ColumnLike\n) {\n  const [, matchers, assigneeExp] = node.args;\n  const [matchCount, matches] = await matchTargets(\n    realm.inferContext,\n    realm,\n    matchers\n  );\n\n  const assignee = await evaluate(realm, assigneeExp);\n\n  let getAssignee = () => assignee;\n  if (isColumnLike(assignee)) {\n    // There must be one item for each match\n    if (assignee.values.length !== matchCount) {\n      throw new RuntimeError(new InferError('Mismatched column sizes'));\n    }\n\n    let targetIndex = 0;\n    getAssignee = () => assignee.atIndex(targetIndex++);\n  }\n\n  return Column.fromValues(\n    dimension.values.map((valueInCol, index) => {\n      if (matches[index]) {\n        return getAssignee();\n      } else {\n        return valueInCol;\n      }\n    })\n  );\n}\n","import produce from 'immer';\n\nimport { getOnly } from '@decipad/utils';\n\nimport { AST, Context, Type } from '..';\nimport { inferExpression } from '../infer';\nimport { Realm } from '../interpreter';\nimport { getIdentifierString } from '../utils';\nimport {\n  evaluateMultidimAssignment,\n  inferMultidimAssignment,\n} from './assignMultidim';\nimport { evaluateVariable, inferVariable } from './getVariable';\nimport { inferMatchers, matchTargets, readSimpleMatchers } from './matcher';\nimport { ColumnLike, ValueTransforms } from '../value';\n\nexport async function inferMatrixRef(\n  context: Context,\n  ref: AST.MatrixRef\n): Promise<Type> {\n  const {\n    args: [varExp, matchersExp],\n  } = ref;\n\n  const variable = inferVariable(context, getIdentifierString(varExp));\n  const matchers = await inferMatchers(context, matchersExp);\n\n  return Type.combine(variable, matchers).mapType(() =>\n    produce(variable, (returned) => {\n      returned.columnSize = 'unknown';\n    })\n  );\n}\n\nexport async function evaluateMatrixRef(\n  realm: Realm,\n  ref: AST.MatrixRef\n): Promise<ColumnLike> {\n  const {\n    args: [varName, matchers],\n  } = ref;\n\n  // variable[dimname == needle]\n  const variable = evaluateVariable(realm, getIdentifierString(varName));\n  const [, matches] = await matchTargets(realm.inferContext, realm, matchers);\n\n  // Let's run the matcher against every item in Column\n  return ValueTransforms.applyFilterMap(variable, matches);\n}\n\nexport async function inferMatrixAssign(\n  context: Context,\n  assign: AST.MatrixAssign\n): Promise<Type> {\n  const {\n    args: [varExp, matchersExp, assigneeExp],\n  } = assign;\n\n  const varName = getIdentifierString(varExp);\n  const matchers = await inferMatchers(context, matchersExp);\n  const assignee = await inferExpression(context, assigneeExp);\n\n  const matcher = getOnly(matchersExp.args);\n  const [dimName, needle] = readSimpleMatchers(context, matcher);\n\n  const dimension =\n    needle == null\n      ? // Variable[DimName] = ...\n        inferVariable(context, dimName)\n      : // variable[dimname == needle] = ...\n        inferVariable(context, varName, dimName);\n\n  let newMatrix: Type;\n  if (needle == null) {\n    // variable[DimName]\n    newMatrix = Type.combine(matchers, dimension).mapType((dim) =>\n      inferMultidimAssignment(dim, assignee)\n    );\n  } else {\n    newMatrix = Type.combine(dimension, matchers, assignee)\n      .mapType(() =>\n        inferMultidimAssignment(dimension, assignee, 'unknown', dimension)\n      )\n      .mapType((newMatrix) => dimension.sameAs(newMatrix));\n  }\n\n  context.stack.set(varName, newMatrix, 'function', context.statementId);\n  return newMatrix;\n}\n\nexport async function evaluateMatrixAssign(\n  realm: Realm,\n  assign: AST.MatrixAssign\n): Promise<ColumnLike> {\n  const [varRef, matchers] = assign.args;\n\n  const varName = getIdentifierString(varRef);\n  const matcher = getOnly(matchers.args);\n  const [dimName, needle] = readSimpleMatchers(realm.inferContext, matcher);\n\n  const dimension =\n    needle == null\n      ? // Variable[DimName] = ...\n        evaluateVariable(realm, dimName)\n      : // variable[dimname == needle] = ...\n        evaluateVariable(realm, varName);\n\n  const newColumn = await evaluateMultidimAssignment(realm, assign, dimension);\n\n  realm.stack.set(varName, newColumn, 'function', realm.statementId);\n  return newColumn;\n}\n","import pSeries from 'p-series';\nimport { inferExpression, inferStatement } from '.';\nimport { AST } from '..';\nimport { callBuiltinFunctor } from '../builtins';\nimport { build as t, InferError, Type } from '../type';\nimport { getDefined, getIdentifierString, getOfType, zip } from '../utils';\nimport { Context, logRetrievedFunctionName } from './context';\n\nexport function inferFunctionDefinition(\n  ctx: Context,\n  statement: AST.FunctionDefinition\n): Type {\n  const [name, args] = statement.args;\n  const fName = getIdentifierString(name);\n\n  ctx.functionDefinitions.set(fName, statement);\n\n  return t.functionPlaceholder(fName, args.args.length);\n}\n\nexport const inferFunction = async (\n  ctx: Context,\n  func: AST.FunctionDefinition,\n  givenArguments: Type[]\n): Promise<Type> => {\n  return ctx.stack.withPushCall(async () => {\n    const [fName, fArgs, fBody] = func.args;\n\n    if (givenArguments.length !== fArgs.args.length) {\n      const error = InferError.expectedArgCount(\n        getIdentifierString(fName),\n        fArgs.args.length,\n        givenArguments.length\n      );\n\n      return t.impossible(error);\n    }\n\n    for (const [argDef, arg] of zip(fArgs.args, givenArguments)) {\n      ctx.stack.set(getIdentifierString(argDef), arg);\n    }\n\n    let returned;\n    for (const statement of fBody.args) {\n      // eslint-disable-next-line no-await-in-loop\n      returned = await inferStatement(ctx, statement);\n    }\n\n    return getDefined(returned, 'panic: function did not return');\n  });\n};\n\n/** set while calling a function to avoid infinite recursion */\nconst isCurrentlyCallingFunctions = new Set<string>();\n\nexport async function inferFunctionCall(ctx: Context, expr: AST.FunctionCall) {\n  const fName = getIdentifierString(expr.args[0]);\n  const fArgs = getOfType('argument-list', expr.args[1]).args;\n  const givenArguments: Type[] = await pSeries(\n    fArgs.map((arg) => () => inferExpression(ctx, arg))\n  );\n\n  logRetrievedFunctionName(ctx, fName);\n\n  if (fName === 'previous') {\n    return givenArguments[0];\n  }\n\n  const functionDefinition = ctx.functionDefinitions.get(fName);\n\n  if (functionDefinition != null) {\n    if (isCurrentlyCallingFunctions.has(fName)) {\n      return t.impossible(InferError.formulaCannotCallItself(fName));\n    }\n    try {\n      isCurrentlyCallingFunctions.add(fName);\n      return await inferFunction(ctx, functionDefinition, givenArguments);\n    } finally {\n      isCurrentlyCallingFunctions.delete(fName);\n    }\n  } else {\n    return callBuiltinFunctor(ctx, fName, givenArguments, fArgs);\n  }\n}\n","/* eslint-disable no-await-in-loop */\nimport { getDefined } from '@decipad/utils';\nimport { Context, inferExpression } from '../infer';\nimport { AST } from '../parser';\nimport { Type, build as T } from '../type';\n\nconst inferMatchDef = async (\n  ctx: Context,\n  def: AST.MatchDef\n): Promise<Type> => {\n  const [condition, result] = def.args;\n  const conditionType = (await inferExpression(ctx, condition)).isScalar(\n    'boolean'\n  );\n  if (conditionType.errorCause) {\n    return conditionType;\n  }\n  return inferExpression(ctx, result);\n};\n\nexport const inferMatch = async (\n  ctx: Context,\n  node: AST.Match\n): Promise<Type> => {\n  if (node.args.length < 1) {\n    return T.nothing();\n  }\n  let resultType: Type | undefined;\n  for (const matchDef of node.args) {\n    const matchDefType = await inferMatchDef(ctx, matchDef);\n    if (resultType) {\n      resultType = resultType.sameAs(matchDefType);\n    } else {\n      resultType = matchDefType;\n    }\n    if (resultType.errorCause) {\n      return resultType;\n    }\n  }\n  return getDefined(resultType);\n};\n","/* eslint-disable no-await-in-loop */\nimport { Context, inferExpression } from '../infer';\nimport { AST } from '../parser';\nimport { Type, build as t } from '../type';\nimport { getIdentifierString } from '../utils';\n\nexport const predicateSymbols = new Set(['rest', 'max', 'min']);\n\nconst isPredicate = (exp: AST.Expression): boolean => {\n  if (exp.type === 'ref') {\n    return predicateSymbols.has(getIdentifierString(exp));\n  }\n  return false;\n};\n\nconst inferTieredDef = async (\n  initialType: Type,\n  ctx: Context,\n  def: AST.TieredDef\n): Promise<Type> => {\n  return ctx.stack.withPush(async () => {\n    ctx.stack.set('tier', initialType);\n    ctx.stack.set('slice', initialType);\n\n    const [condition, result] = def.args;\n    let conditionType: Type | undefined;\n    if (!isPredicate(condition)) {\n      conditionType = (await inferExpression(ctx, condition))\n        .isScalar('number')\n        .sameAs(initialType);\n    }\n    const resultType = await inferExpression(ctx, result);\n    if (conditionType?.errorCause) {\n      return conditionType;\n    }\n    return resultType;\n  });\n};\n\nexport const inferTiered = async (\n  ctx: Context,\n  node: AST.Tiered\n): Promise<Type> => {\n  const [initial, ...tieredDefs] = node.args;\n  const argType = (await inferExpression(ctx, initial)).isScalar('number');\n\n  if (!tieredDefs.length) {\n    return t.impossible('tiered definitions are empty');\n  }\n  return (\n    await Promise.all(\n      tieredDefs.map((def) => inferTieredDef(argType, ctx, def))\n    )\n  ).reduce((type, other) => type.sameAs(other));\n};\n","import pSeries from 'p-series';\n\nimport { AST } from '..';\nimport { InferError, Type, build as t, deserializeType } from '../type';\nimport { matchUnitArraysForColumn } from '../type/units';\nimport { getDefined, getIdentifierString } from '../utils';\nimport { getDateFromAstForm } from '../date';\nimport { expandDirectiveToType } from '../directives';\nimport { parseUnit } from '../units';\nimport { inferTable } from '../tables/inference';\nimport { inferColumnAssign } from '../tables/column-assign';\n\nimport { Context, makeContext, logRetrievedName } from './context';\nimport { inferSequence } from './sequence';\nimport { isPreviousRef } from '../previous-ref';\nimport { inferMatrixAssign, inferMatrixRef } from '../matrix';\nimport { inferCategories } from '../categories';\nimport { inferFunctionDefinition, inferFunctionCall } from './functions';\nimport { getConstantByName } from '../builtins';\nimport { inferMatch } from '../match/inferMatch';\nimport { inferTiered } from '../tiered/inferTiered';\n\nexport { makeContext, logRetrievedName };\nexport type { Context };\n\nexport const linkToAST = (ctx: Context, node: AST.Node, type: Type) => {\n  ctx.nodeTypes.set(node, type);\n\n  if (type.errorCause != null && type.node == null) {\n    return type.inNode(node);\n  } else {\n    return type;\n  }\n};\n\nconst wrap =\n  <T extends AST.Node>(\n    fn: (ctx: Context, thing: T, cohercingTo?: Type) => Promise<Type>\n  ) =>\n  async (ctx: Context, thing: T, cohercingTo?: Type): Promise<Type> => {\n    let type = await fn(ctx, thing);\n    if (cohercingTo) {\n      type = type.sameAs(cohercingTo);\n    }\n    return linkToAST(ctx, thing, type);\n  };\n\n/**\n Walk depth-first into an expanded AST.Expression, collecting the type of things beneath and checking it against the current iteration's constraints.\n\n Given a literal, this type is always known (barring casting).\n Given a function call, this type is given by calling the functor with the arguments' types.\n Given a condition, the functor is (thentype == elsetype) and its condition must be boolean\n\n AST.Assign is special-cased by looking at its expression and returning just that\n*/\nexport const inferExpression = wrap(\n  // exhaustive switch\n  // eslint-disable-next-line consistent-return\n  async (ctx: Context, expr: AST.Expression): Promise<Type> => {\n    switch (expr.type) {\n      case 'noop': {\n        return t.nothing();\n      }\n      case 'ref': {\n        const name = getIdentifierString(expr);\n        if (isPreviousRef(name)) {\n          return (\n            (ctx.previousStatement && deserializeType(ctx.previousStatement)) ||\n            t.impossible(InferError.noPreviousStatement())\n          );\n        }\n        const c = getConstantByName(name);\n        if (c) {\n          return c.type;\n        }\n\n        const fromStack = ctx.stack.get(name);\n        if (fromStack) {\n          logRetrievedName(ctx, name);\n          return fromStack;\n        }\n\n        // create a unit with the name of the ref\n        return ctx.autoGeneratedVarNames.has(name)\n          ? t.impossible(new InferError({ errType: 'unknown-reference' }), expr)\n          : t.number([parseUnit(name)]); // defaults to a unit with the ref name\n      }\n      case 'externalref': {\n        const [id] = expr.args;\n        const data = ctx.externalData.get(id);\n        if (data) {\n          return deserializeType(data.type);\n        }\n        return t.impossible(\n          new InferError({ errType: 'unknown-reference' }),\n          expr\n        );\n      }\n      case 'literal': {\n        const [litType] = expr.args;\n\n        if (litType === 'number') {\n          return t.number(null, expr.args[2]);\n        }\n\n        return t[litType]();\n      }\n      case 'range': {\n        const [start, end] = await pSeries(\n          expr.args.map((expr) => () => inferExpression(ctx, getDefined(expr)))\n        );\n\n        return Type.combine(start, end).mapType(() => {\n          const rangeOf =\n            start.date != null\n              ? start.sameAs(end)\n              : start.isScalar('number').sameAs(end);\n\n          return t.range(rangeOf);\n        });\n      }\n      case 'sequence': {\n        return inferSequence(ctx, expr, inferExpression);\n      }\n      case 'date': {\n        const [, specificity] = getDateFromAstForm(expr.args);\n        return t.date(specificity);\n      }\n      case 'column': {\n        const [columnItems, optionalIndex] = expr.args;\n        if (columnItems.args.length === 0) {\n          return t.impossible(InferError.unexpectedEmptyColumn());\n        }\n        const [firstCellNode, ...restCellNodes] = columnItems.args;\n        const firstCellType = await inferExpression(ctx, firstCellNode);\n        const restCellTypes = await pSeries(\n          restCellNodes.map((a) => () => inferExpression(ctx, a, firstCellType))\n        );\n\n        const erroredCell = [firstCellType, ...restCellTypes].find(\n          (cell) => cell.errorCause != null\n        );\n        if (erroredCell != null) return erroredCell;\n\n        for (const restCell of restCellTypes) {\n          if (\n            !matchUnitArraysForColumn(\n              firstCellType.reducedToLowest().unit,\n              restCell.reducedToLowest().unit\n            )\n          ) {\n            return t.impossible(\n              InferError.columnContainsInconsistentType(firstCellType, restCell)\n            );\n          }\n        }\n        return t.column(\n          firstCellType,\n          columnItems.args.length,\n          optionalIndex?.args[0]\n        );\n      }\n      case 'property-access': {\n        const [thing, propName] = expr.args;\n        const table = (await inferExpression(ctx, thing)).isTableOrRow();\n        const tableName =\n          thing.type === 'ref' ? thing.args[0] : table.indexName;\n\n        const getFromTableOrRow = (\n          names: string[],\n          types: Type[]\n        ): [Type, number] => {\n          const index = names.indexOf(propName);\n          if (index < 0) {\n            return [\n              t.impossible(\n                `A column named ${propName} does not exist in ${tableName}`\n              ),\n              index,\n            ];\n          }\n\n          const originTable = table.indexName || table.rowIndexName;\n          if (originTable) {\n            logRetrievedName(ctx, [originTable, propName]);\n          }\n          return [types[index], index];\n        };\n\n        if (table.errorCause) {\n          return table;\n        } else if (table.columnNames != null && table.columnTypes != null) {\n          const [column, columnIndex] = getFromTableOrRow(\n            table.columnNames,\n            table.columnTypes\n          );\n          return t.column(column, 'unknown', table.indexName, columnIndex);\n        } else {\n          const { rowCellNames, rowCellTypes } = table;\n          const [type] = getFromTableOrRow(\n            getDefined(rowCellNames),\n            getDefined(rowCellTypes)\n          );\n          return type;\n        }\n      }\n      case 'matrix-ref': {\n        return inferMatrixRef(ctx, expr);\n      }\n      case 'function-call': {\n        return inferFunctionCall(ctx, expr);\n      }\n      case 'directive': {\n        return expandDirectiveToType(ctx, expr);\n      }\n      case 'match':\n        return inferMatch(ctx, expr);\n      case 'tiered':\n        return inferTiered(ctx, expr);\n    }\n  }\n);\n\nconst inferStatementInternal = wrap(\n  async (\n    /* Mutable! */ ctx: Context,\n    statement: AST.Statement\n  ): Promise<Type> => {\n    switch (statement.type) {\n      case 'assign': {\n        const [nName, nValue] = statement.args;\n\n        const varName = getIdentifierString(nName);\n\n        const constant = getConstantByName(varName);\n        const type =\n          constant || ctx.stack.has(varName, 'function')\n            ? t.impossible(InferError.duplicatedName(varName))\n            : await inferExpression(ctx, nValue);\n\n        ctx.stack.set(varName, type, 'function', ctx.statementId);\n        return type;\n      }\n      case 'table': {\n        return inferTable(ctx, statement);\n      }\n      case 'table-column-assign': {\n        return inferColumnAssign(ctx, statement);\n      }\n      case 'matrix-assign': {\n        return inferMatrixAssign(ctx, statement);\n      }\n      case 'categories': {\n        return inferCategories(ctx, statement);\n      }\n      case 'function-definition': {\n        return inferFunctionDefinition(ctx, statement);\n      }\n      default: {\n        return inferExpression(ctx, statement);\n      }\n    }\n  }\n);\n\nexport const inferStatement = async (\n  ...args: Parameters<typeof inferStatementInternal>\n) => {\n  const [ctx] = args;\n  const { usedNames: previoususedNames } = ctx;\n\n  if (previoususedNames == null) {\n    return inferStatementInternal(...args);\n  }\n\n  // Do not keep track of names retrieved here if we errored out\n  ctx.usedNames = [...previoususedNames];\n\n  const type = await inferStatementInternal(...args);\n\n  if (type.errorCause) {\n    ctx.usedNames = previoususedNames;\n  }\n\n  return type;\n};\n\nexport const inferBlock = async (\n  block: AST.Block,\n  ctx = makeContext()\n): Promise<Type> => {\n  let last;\n  for (const stmt of block.args) {\n    // eslint-disable-next-line no-await-in-loop\n    last = await inferStatement(ctx, stmt);\n  }\n  return getDefined(last, 'Unexpected empty block');\n};\n\nexport const inferProgram = async (\n  program: AST.Block[],\n  ctx = makeContext()\n): Promise<Context> => {\n  for (const block of program) {\n    // eslint-disable-next-line no-await-in-loop\n    await inferBlock(block, ctx);\n  }\n  return ctx;\n};\n","import { zip } from '@decipad/utils';\nimport { AST } from '..';\nimport { Context } from '../infer';\nimport { build as t, InferError } from '../type';\nimport { getDefined, getIdentifierString, getInstanceof } from '../utils';\nimport { Realm } from '../interpreter';\nimport { Table, UnknownValue, Value } from '../value';\nimport { inferTableColumn } from './inference';\nimport { evaluateTableColumn } from './evaluate';\nimport { shouldEvaluate } from './shouldEvaluate';\n\nexport const inferColumnAssign = async (\n  ctx: Context,\n  assign: AST.TableColumnAssign\n) => {\n  if (!ctx.stack.isInGlobalScope) {\n    return t.impossible(InferError.forbiddenInsideFunction('table'));\n  }\n\n  const [tableNameAst, colNameAst] = assign.args;\n  const tableName = getIdentifierString(tableNameAst);\n  const columnName = getIdentifierString(colNameAst);\n\n  const table = ctx.stack.get(tableName)?.isTable();\n\n  if (table == null || table?.errorCause) {\n    return table ?? t.impossible(InferError.missingVariable(tableName));\n  }\n\n  if (ctx.stack.hasNamespaced([tableName, columnName], 'function')) {\n    return t.impossible(InferError.duplicateTableColumn(columnName));\n  }\n\n  const newColumnAtParentIndex = getDefined(table.columnNames).length;\n\n  const newColumn = await inferTableColumn(ctx, {\n    columnAst: assign,\n    tableName,\n    columnName,\n  });\n\n  if (newColumn.errorCause) {\n    return newColumn;\n  }\n\n  return t.column(newColumn, 'unknown', tableName, newColumnAtParentIndex);\n};\n\nexport async function evaluateColumnAssign(\n  realm: Realm,\n  assign: AST.TableColumnAssign\n): Promise<Value> {\n  const [tableNameAst, tableColAst, expAst] = assign.args;\n\n  const tableName = getIdentifierString(tableNameAst);\n  const columnName = getIdentifierString(tableColAst);\n\n  if (!shouldEvaluate(realm, tableName, columnName)) {\n    return UnknownValue;\n  }\n\n  const table = getInstanceof(getDefined(realm.stack.get(tableName)), Table);\n\n  const columns = new Map(zip(table.columnNames, table.columns));\n\n  const newColumn = await evaluateTableColumn(\n    realm,\n    columns,\n    expAst,\n    tableName,\n    table.tableRowCount\n  );\n\n  realm.stack.setNamespaced(\n    [tableName, columnName],\n    newColumn,\n    'function',\n    realm.statementId\n  );\n\n  return getDefined(\n    realm.stack.getNamespaced([tableName, columnName], 'function')\n  );\n}\n","import { getDefined } from '@decipad/utils';\nimport { AST, Context } from '..';\nimport { inferExpression } from '../infer';\nimport { evaluate, Realm } from '../interpreter';\nimport { ColumnLike, getColumnLike } from '../value';\nimport { build as t, InferError, Type } from '../type';\nimport { getIdentifierString } from '../utils';\n\nexport const inferCategories = async (\n  ctx: Context,\n  category: AST.Categories\n): Promise<Type> => {\n  if (!ctx.stack.isInGlobalScope) {\n    return t.impossible(InferError.forbiddenInsideFunction('category'));\n  }\n\n  const [nameExp, contentsExp] = category.args;\n\n  const name = getIdentifierString(nameExp);\n  const contents = await inferExpression(ctx, contentsExp);\n\n  const theSet = contents\n    .isColumn()\n    .reduced()\n    .isPrimitive()\n    .mapType((setCell) => {\n      if (ctx.stack.has(name)) {\n        return t.impossible(InferError.duplicatedName(name));\n      }\n      return t.column(setCell, getDefined(contents.columnSize), name);\n    });\n\n  ctx.stack.set(name, theSet, 'function', ctx.statementId);\n  return theSet;\n};\n\nexport const evaluateCategories = async (\n  realm: Realm,\n  category: AST.Categories\n): Promise<ColumnLike> => {\n  const [nameExp, contentsExp] = category.args;\n\n  const name = getIdentifierString(nameExp);\n  const contents = await evaluate(realm, contentsExp);\n\n  const theSet = getColumnLike(contents);\n\n  realm.stack.set(name, theSet, 'function', realm.statementId);\n  return theSet;\n};\n","import DeciNumber, { N } from '@decipad/number';\nimport produce from 'immer';\nimport { getDefined } from '@decipad/utils';\nimport { evaluate, RuntimeError } from '../interpreter';\nimport { automapTypes, automapValues } from '../dimtools';\nimport { NumberValue, fromJS, Value } from '../value';\nimport { AST } from '../parser';\nimport {\n  build as t,\n  convertToMultiplierUnit,\n  InferError,\n  Type,\n  Unit,\n} from '../type';\nimport { matchUnitArrays } from '../type/units';\nimport { areUnitsConvertible, convertBetweenUnits, parseUnit } from '../units';\nimport type { DirectiveImpl } from './types';\nimport { getIdentifierString, getInstanceof, U } from '../utils';\nimport { inferExpression } from '../infer';\n\nfunction isUserUnit(exp: AST.Expression, targetUnit: Unit[]) {\n  if (exp.type !== 'ref') {\n    return false;\n  }\n  const unit: Unit[] = [parseUnit(getIdentifierString(exp))];\n  return !matchUnitArrays(unit, targetUnit);\n}\n\nfunction multiplyUnitMultipliers(units: Unit[] | null | undefined): DeciNumber {\n  return (units || []).reduce(\n    (acc, unit) => acc.mul(unit.multiplier.pow(unit.exp)),\n    N(1)\n  );\n}\n\nfunction multiplyUnitMultipliersIfNeedsEnforcing(\n  units: Unit[] | null | undefined\n): DeciNumber {\n  return (units || []).reduce(\n    (acc, unit) =>\n      unit.enforceMultiplier ? acc.mul(unit.multiplier.pow(unit.exp)) : acc,\n    N(1)\n  );\n}\n\nexport const getType: DirectiveImpl<AST.AsDirective>['getType'] = async (\n  ctx,\n  { args: [, expr, unitExpr] }\n): Promise<Type> => {\n  const expressionType = await inferExpression(ctx, expr);\n  if (expressionType.errorCause) {\n    return expressionType;\n  }\n\n  if (representsPercentage(unitExpr)) {\n    return automapTypes([expressionType.isScalar('number')], (): Type => {\n      return t.number(null, 'percentage');\n    });\n  }\n\n  const unitExpressionType = (await inferExpression(ctx, unitExpr)).isScalar(\n    'number'\n  );\n  if (unitExpressionType.errorCause) {\n    return unitExpressionType;\n  }\n  const { unit } = unitExpressionType.reducedToLowest();\n  let targetUnit = unit;\n  if (unitExpr.type === 'ref' && unit && isUserUnit(unitExpr, unit)) {\n    targetUnit = U(getIdentifierString(unitExpr), {\n      known: false,\n      aliasFor: unit,\n    });\n  }\n  const ret = automapTypes(\n    [expressionType],\n    ([expressionType]: Type[]): Type => {\n      const sourceUnits = expressionType.unit;\n      if (!sourceUnits || sourceUnits.length === 0) {\n        return t.number(targetUnit);\n      }\n\n      if (unit && !areUnitsConvertible(sourceUnits, unit)) {\n        if (\n          areUnitsConvertible(sourceUnits, unit, { tolerateImprecision: true })\n        ) {\n          // Only imprecision available today\n          return t.number(targetUnit, undefined, 'month-day-conversion');\n        }\n        return t.impossible(\n          InferError.cannotConvertBetweenUnits(sourceUnits, unit)\n        );\n      }\n\n      return t.number(targetUnit);\n    }\n  );\n  return ret;\n};\n\nfunction inlineUnitAliases(units: Unit[] | null): Unit[] | null {\n  if (!units) {\n    return null;\n  }\n  return units.reduce<Unit[]>((units, oneUnit) => {\n    if (oneUnit.aliasFor != null) {\n      const unit = getDefined(inlineUnitAliases(oneUnit.aliasFor));\n      for (const u of unit) {\n        units.push(\n          produce(u, (unit) => {\n            unit.enforceMultiplier = true;\n          })\n        );\n      }\n    } else {\n      units.push(oneUnit);\n    }\n    return units;\n  }, []);\n}\n\nexport const getValue: DirectiveImpl<AST.AsDirective>['getValue'] = async (\n  realm,\n  root\n): Promise<Value> => {\n  const [, expression, unitsExpression] = root.args;\n  const expressionType = realm.getTypeAt(expression);\n  const expressionValue = await evaluate(realm, expression);\n  const sourceUnits = inlineUnitAliases(expressionType.reducedToLowest().unit);\n\n  if (representsPercentage(unitsExpression)) {\n    return automapValues(\n      [expressionType],\n      [expressionValue],\n      ([value], [type]) => {\n        const noMultiplier = convertToMultiplierUnit(\n          getInstanceof(value, NumberValue).value,\n          type.unit\n        );\n        return NumberValue.fromValue(noMultiplier);\n      }\n    );\n  }\n\n  const targetUnitsEvalResult = await evaluate(realm, unitsExpression);\n  const targetUnitsData = getInstanceof(\n    targetUnitsEvalResult.getData(),\n    DeciNumber,\n    `units needs to be a number`\n  );\n\n  const returnExpressionType = realm.getTypeAt(root);\n  const returnTypeDivider = multiplyUnitMultipliersIfNeedsEnforcing(\n    inlineUnitAliases(returnExpressionType.unit)\n  );\n\n  const targetUnitsExpressionType = realm.getTypeAt(unitsExpression);\n  const targetUnits = inlineUnitAliases(targetUnitsExpressionType.unit);\n\n  const targetUnitsMultiplier = multiplyUnitMultipliers(targetUnits);\n  const targetMultiplierConversionRate = targetUnitsData.div(\n    targetUnitsMultiplier\n  );\n\n  const conversionRate = targetMultiplierConversionRate.mul(returnTypeDivider);\n\n  return automapValues([expressionType], [expressionValue], ([value]) => {\n    if (value instanceof NumberValue) {\n      if (!targetUnits || !sourceUnits || sourceUnits.length < 1) {\n        return fromJS(value.getData().div(conversionRate));\n      }\n\n      const converted = convertBetweenUnits(\n        value.getData(),\n        sourceUnits,\n        targetUnits,\n        { tolerateImprecision: true }\n      );\n\n      return fromJS(converted.div(conversionRate));\n    }\n\n    throw targetUnits\n      ? InferError.cannotConvertToUnit(targetUnits)\n      : new RuntimeError(\n          `Don't know how to convert value to ${value.getData().toString()}`\n        );\n  });\n};\n\nexport const as: DirectiveImpl<AST.AsDirective> = {\n  getType,\n  getValue,\n};\n\nfunction representsPercentage(\n  unitExpr: AST.Expression | AST.GenericIdentifier\n): unitExpr is AST.GenericIdentifier {\n  // Parser only uses \"generic-identifier\" to represent percentage here\n  return unitExpr.type === 'generic-identifier';\n}\n","import { AST, getColumnLike, inferExpression } from '..';\nimport { dimSwapTypes, dimSwapValues } from '../dimtools';\nimport { evaluate } from '../interpreter';\nimport { getIdentifierString } from '../utils';\nimport { DirectiveImpl } from './types';\n\nexport const over: DirectiveImpl<AST.OverDirective> = {\n  async getType(ctx, overExp) {\n    const [, matrix, indexName] = overExp.args;\n\n    return dimSwapTypes(\n      getIdentifierString(indexName),\n      await inferExpression(ctx, matrix)\n    );\n  },\n  async getValue(realm, overExp) {\n    const [, matrix, indexName] = overExp.args;\n\n    const value = await evaluate(realm, matrix);\n    const type = realm.getTypeAt(matrix);\n\n    return dimSwapValues(\n      getIdentifierString(indexName),\n      type,\n      getColumnLike(value)\n    );\n  },\n};\n","import produce from 'immer';\nimport { AST, Context, inferExpression } from '..';\nimport { automapTypes } from '../dimtools';\nimport { evaluate, Realm } from '../interpreter';\nimport { InferError, Type, build as t } from '../type';\nimport { getIdentifierString } from '../utils';\nimport { DirectiveImpl } from './types';\n\nexport const getType: DirectiveImpl<AST.OfDirective>['getType'] = async (\n  ctx: Context,\n  { args: [, expr, quality] }\n): Promise<Type> => {\n  const expressionType = await inferExpression(ctx, expr);\n  if (expressionType.errorCause) {\n    return expressionType;\n  }\n  return automapTypes([expressionType], ([expressionType]: Type[]): Type => {\n    return expressionType.isScalar('number').mapType((type): Type => {\n      if (!type.unit || type.unit.length !== 1) {\n        return t.impossible(InferError.needOneAndOnlyOneUnit());\n      }\n\n      return produce(type, (t) => {\n        if (t.unit) {\n          t.unit[0] = produce(t.unit[0], (u) => {\n            u.quality = getIdentifierString(quality);\n          });\n        }\n      });\n    });\n  });\n};\n\nexport const getValue: DirectiveImpl<AST.OfDirective>['getValue'] = (\n  realm: Realm,\n  { args: [, expr] }\n) => evaluate(realm, expr);\n\nexport const of: DirectiveImpl<AST.OfDirective> = {\n  getType,\n  getValue,\n};\n","import type { DirectiveImpl } from './types';\nimport { as } from './as-directive';\nimport { over } from './over-directive';\nimport { select } from './select-directive';\nimport { of } from './of-directive';\n\nexport const directives: Record<string, DirectiveImpl> = {\n  as,\n  over,\n  select,\n  of,\n};\n","import { AST } from '../parser';\nimport { build as t, InferError } from '../type';\nimport { DirectiveImpl } from './types';\n\nexport const select: DirectiveImpl<AST.SelectDirective> = {\n  async getType() {\n    return t.impossible(InferError.retiredFeature('select'));\n  },\n  async getValue() {\n    throw new Error('unreachable');\n  },\n};\n","import type { AST, Context, Type } from '..';\nimport type { Realm } from '../interpreter';\nimport type { Value } from '../value';\n\nimport { directives } from './directives';\n\nexport const expandDirectiveToType = (\n  ctx: Context,\n  root: AST.Directive\n): Promise<Type> => directives[root.args[0]].getType(ctx, root);\n\nexport const expandDirectiveToValue = (\n  realm: Realm,\n  root: AST.Directive\n): Promise<Value> => directives[root.args[0]].getValue(realm, root);\n","/* eslint-disable no-await-in-loop */\nimport { evaluate, Realm, RuntimeError } from '../interpreter';\nimport { AST } from '../parser';\nimport { Value } from '../value';\n\nconst evaluateMatchDef = async (\n  realm: Realm,\n  def: AST.MatchDef\n): Promise<Value | undefined> => {\n  const [condition, result] = def.args;\n  const conditionValue = await evaluate(realm, condition);\n  if (conditionValue.getData()) {\n    return evaluate(realm, result);\n  }\n  return undefined;\n};\n\nexport const evaluateMatch = async (\n  realm: Realm,\n  node: AST.Match\n): Promise<Value> => {\n  for (const matchDef of node.args) {\n    const matchDefValue = await evaluateMatchDef(realm, matchDef);\n    if (matchDefValue != null) {\n      return matchDefValue;\n    }\n  }\n  throw new RuntimeError(\n    'None of the match condition were true. At least one of the conditions must be true.'\n  );\n};\n","/* eslint-disable no-loop-func */\n/* eslint-disable no-await-in-loop */\nimport DeciNumber, { min, max, ZERO } from '@decipad/number';\nimport { NumberValue, Value } from '../value';\nimport { evaluate, Realm, RuntimeError } from '../interpreter';\nimport { AST } from '../parser';\nimport { Type, Unit } from '../type';\nimport { convertBetweenUnits } from '../units';\nimport { getDefined, getIdentifierString, getInstanceof } from '../utils';\nimport { predicateSymbols } from './inferTiered';\n\nconst maybeConvertBetweenUnits = (\n  f: DeciNumber,\n  from: Unit[] | null,\n  to: Unit[] | null\n) => {\n  if (!from || !to) {\n    return f;\n  }\n  return convertBetweenUnits(f, from, to);\n};\n\ninterface Predicates {\n  max?: AST.Expression;\n  min?: AST.Expression;\n  rest?: AST.Expression;\n}\n\ntype Tier = [AST.Expression, AST.Expression];\n\nconst getPredicate = (exp: AST.Expression): keyof Predicates | undefined => {\n  const id = exp.type === 'ref' && getIdentifierString(exp);\n  if (id && predicateSymbols.has(id)) {\n    return id as keyof Predicates;\n  }\n  return undefined;\n};\n\nconst collectTieredDef = (\n  def: AST.TieredDef\n): [AST.Expression | keyof Predicates, AST.Expression] => {\n  const [predicateOrTier, result] = def.args;\n  const predicate = getPredicate(predicateOrTier);\n  if (predicate) {\n    return [predicate, result];\n  }\n  return [predicateOrTier, result];\n};\n\nconst collectDefs = (tierDefs: AST.TieredDef[]) => {\n  const predicates: Predicates = {};\n  const tiers: Array<Tier> = [];\n\n  // collect defs\n  for (const tierDef of tierDefs) {\n    const [predicateOrTierSizeExp, predicateOrTierValueExp] =\n      collectTieredDef(tierDef);\n    if (typeof predicateOrTierSizeExp === 'string') {\n      predicates[predicateOrTierSizeExp] = predicateOrTierValueExp;\n    } else {\n      tiers.push([predicateOrTierSizeExp, predicateOrTierValueExp]);\n    }\n  }\n\n  return { predicates, tiers };\n};\n\nconst evaluateTier = async (\n  realm: Realm,\n  tierValueExp: AST.Expression,\n  tierSize: DeciNumber,\n  tierResultType: Type\n): Promise<DeciNumber> => {\n  const tierValueType = getDefined(\n    realm.inferContext.nodeTypes.get(tierValueExp)\n  );\n  const tierSizeValue = NumberValue.fromValue(tierSize);\n  const tierValue = await realm.stack.withPush(async () => {\n    realm.stack.set('tier', tierSizeValue);\n    realm.stack.set('slice', tierSizeValue);\n    return evaluate(realm, tierValueExp);\n  });\n  return maybeConvertBetweenUnits(\n    getInstanceof(tierValue.getData(), DeciNumber),\n    tierValueType.unit,\n    tierResultType.unit\n  );\n};\n\ninterface IterateTierResult {\n  slice: DeciNumber;\n  tierResult: DeciNumber;\n  tierCutOff: DeciNumber;\n}\n\nconst iterateTier = async (\n  realm: Realm,\n  globalTierSizeType: Type,\n  tierResultType: Type,\n  tier: Tier,\n  tierIndex: number,\n  remaining: DeciNumber,\n  previousCutoff: DeciNumber\n): Promise<IterateTierResult> => {\n  const [tierSizeExp, tierValueExp] = tier;\n  const tierSizeType = getDefined(\n    realm.inferContext.nodeTypes.get(tierSizeExp)\n  );\n\n  const tierCutOff = maybeConvertBetweenUnits(\n    getInstanceof((await evaluate(realm, tierSizeExp)).getData(), DeciNumber),\n    tierSizeType.unit,\n    globalTierSizeType.unit\n  );\n  const tierSize = tierCutOff.sub(previousCutoff);\n  if (tierSize.compare(ZERO) < 0) {\n    throw new RuntimeError(\n      `Error on tier definition number ${tierIndex}. Each tier level needs to be bigger than the previous one`\n    );\n  }\n  const slice = min(remaining, tierSize);\n  const tierResult = await evaluateTier(\n    realm,\n    tierValueExp,\n    slice,\n    tierResultType\n  );\n\n  return { tierResult, slice, tierCutOff };\n};\n\nexport const evaluateTiered = async (\n  realm: Realm,\n  node: AST.Tiered\n): Promise<Value> => {\n  const [initial, ...tierDefs] = node.args;\n  const initialNumber = getInstanceof(\n    (await evaluate(realm, initial)).getData(),\n    DeciNumber\n  );\n  const tierSizeType = getDefined(realm.inferContext.nodeTypes.get(initial));\n  const resultType = getDefined(realm.inferContext.nodeTypes.get(node));\n\n  const { predicates, tiers } = collectDefs(tierDefs);\n\n  // evaluate\n  let remaining = initialNumber;\n  let acc = ZERO;\n  let previousCutoff = ZERO;\n  let tierIndex = 0;\n  while (remaining.compare(ZERO) > 0 && tiers.length) {\n    tierIndex += 1;\n    const tier = tiers.shift();\n    if (tier) {\n      const { slice, tierResult, tierCutOff } = await iterateTier(\n        realm,\n        tierSizeType,\n        resultType,\n        tier,\n        tierIndex,\n        remaining,\n        previousCutoff\n      );\n      acc = acc.add(tierResult);\n      remaining = remaining.sub(slice);\n      previousCutoff = tierCutOff;\n    }\n  }\n\n  if (remaining.compare(ZERO) > 0) {\n    const { rest } = predicates;\n    if (rest) {\n      const restValue = await evaluateTier(realm, rest, remaining, resultType);\n      acc = acc.add(restValue);\n    }\n  }\n\n  if (predicates.min) {\n    const minType = getDefined(\n      realm.inferContext.nodeTypes.get(predicates.min)\n    );\n    const minimumValue = maybeConvertBetweenUnits(\n      getInstanceof(\n        (await evaluate(realm, predicates.min)).getData(),\n        DeciNumber\n      ),\n      minType.unit,\n      resultType.unit\n    );\n    acc = max(acc, minimumValue);\n  }\n\n  if (predicates.max) {\n    const maxType = getDefined(\n      realm.inferContext.nodeTypes.get(predicates.max)\n    );\n    const maximumValue = maybeConvertBetweenUnits(\n      getInstanceof(\n        (await evaluate(realm, predicates.max)).getData(),\n        DeciNumber\n      ),\n      maxType.unit,\n      resultType.unit\n    );\n    acc = min(acc, maximumValue);\n  }\n\n  return NumberValue.fromValue(acc);\n};\n","import DeciNumber from '@decipad/number';\nimport { lenientZip, zip } from '@decipad/utils';\nimport { Type } from '..';\nimport { getSpecificity } from '../date';\nimport { Interpreter } from '../interpreter';\nimport { Unknown } from '../value';\nimport { SerializedType, SerializedTypeKind, serializeType } from '../type';\n\nfunction validate(\n  type: SerializedType,\n  value: Interpreter.OneResult | null | undefined\n): boolean {\n  const getTrue = (cond: boolean, failureMessage: string) => {\n    if (cond) return true;\n    reportError(type, value);\n    throw new Error(failureMessage);\n  };\n  const getArray = <T>(thing: T) => {\n    if (Array.isArray(thing)) return thing;\n    reportError(type, value);\n    throw new Error('panic: expected array');\n  };\n  const getOfKind = (type: SerializedType, ...kinds: SerializedTypeKind[]) => {\n    if (kinds.includes(type.kind)) return type;\n    reportError(type, value);\n    throw new Error(`panic: wanted ${kinds.join('/')} and got ${type.kind}`);\n  };\n\n  switch (type.kind) {\n    case 'number': {\n      return getTrue(value instanceof DeciNumber, 'panic: expected fraction');\n    }\n    case 'boolean':\n    case 'string': {\n      return getTrue(\n        typeof value === type.kind,\n        `panic: expected ${type.kind}`\n      );\n    }\n    case 'date': {\n      return (\n        getTrue(\n          getSpecificity(type.date) === type.date,\n          `invalid date specificity ${type.date}`\n        ) &&\n        getTrue(\n          typeof value === 'bigint' || value instanceof DeciNumber,\n          'expected date to be represented as a bigint'\n        )\n      );\n    }\n    case 'range': {\n      const values = getArray(value as Interpreter.ResultRange);\n\n      getTrue(\n        values.length === 2,\n        'panic: expected range to be represented by an array of 2'\n      );\n\n      const rangeType = getOfKind(type.rangeOf, 'date', 'number');\n\n      return validate(rangeType, values[0]) && validate(rangeType, values[1]);\n    }\n    case 'column': {\n      const array = getArray(value as Interpreter.ResultColumn);\n      return array.every((cell) => validate(type.cellType, cell));\n    }\n    case 'table': {\n      return lenientZip(\n        type.columnTypes,\n        getArray(value as Interpreter.ResultTable)\n      ).every(([cellType, value]) => {\n        if (cellType) {\n          const implicitColumn: SerializedType = {\n            kind: 'column',\n            cellType,\n            columnSize: 'unknown',\n            indexedBy: null,\n          };\n          validate(implicitColumn, value);\n        }\n      });\n    }\n    case 'row': {\n      return zip(\n        type.rowCellTypes,\n        getArray(value as Interpreter.ResultRow)\n      ).every(([type, value]) => validate(type, value));\n    }\n    case 'nothing': {\n      return getTrue(value == null || value === Unknown, 'expected no value');\n    }\n    case 'function': {\n      return getTrue(value == null || value === Unknown, 'expected no value');\n    }\n  }\n  return true;\n}\n\nconst reportError = (\n  type: SerializedType,\n  value: Interpreter.OneResult | null | undefined\n) => {\n  console.error('Failed to validate a Result:');\n  console.error({ type, value });\n};\n\nexport function validateResult(\n  type: Type | SerializedType,\n  value: Interpreter.OneResult | null | undefined\n) {\n  if (type instanceof Type) {\n    type = serializeType(type);\n  }\n\n  try {\n    return validate(type, value);\n  } catch (e) {\n    reportError(type, value);\n    throw e;\n  }\n}\n","import { N } from '@decipad/number';\nimport { Result, Value, Table, Column, SerializedTypes } from '..';\nimport { fromJS, Range, Row, Scalar } from '../value';\nimport {\n  ResultBoolean,\n  ResultColumn,\n  ResultDate,\n  ResultNumber,\n  ResultRange,\n  ResultRow,\n  ResultString,\n  ResultTable,\n} from '../interpreter/interpreter-types';\n\nexport const resultToValue = (result: Result.Result): Value => {\n  const { type, value } = result;\n  switch (type.kind) {\n    case 'type-error':\n    case 'nothing':\n    case 'function':\n    case 'anything':\n      return Result.UnknownValue;\n\n    case 'table': {\n      const tableValue = value as ResultTable;\n      const tableType = type as SerializedTypes.Table;\n      const columns = tableType.columnTypes.map((columnType, index) => {\n        return resultToValue({\n          type: {\n            kind: 'column',\n            indexedBy: tableType.columnNames[0],\n            cellType: columnType,\n            columnSize: 'unknown',\n          },\n          value: tableValue[index],\n        });\n      });\n      return Table.fromNamedColumns(columns, tableType.columnNames);\n    }\n\n    case 'column': {\n      const columnValue = value as ResultColumn;\n      if (columnValue == null) {\n        return Column.fromValues([fromJS(0)]);\n      }\n      const columnType = type as SerializedTypes.Column;\n      return Column.fromValues(\n        columnValue.map((cell) =>\n          resultToValue({ type: columnType.cellType, value: cell })\n        )\n      );\n    }\n\n    case 'number': {\n      return Scalar.fromValue(N(value as ResultNumber));\n    }\n\n    case 'date': {\n      let dateValue = value as ResultDate;\n      if (typeof dateValue !== 'bigint') {\n        dateValue = BigInt(dateValue);\n      }\n      return Scalar.fromValue(dateValue);\n    }\n\n    case 'boolean':\n      return Scalar.fromValue(value as ResultBoolean | ResultDate);\n\n    case 'string':\n      return Scalar.fromValue((value as ResultString).toString());\n\n    case 'range':\n      const rangeValue = value as ResultRange;\n      const [start, end] = rangeValue.map(Scalar.fromValue);\n      return Range.fromBounds(start, end);\n\n    case 'row':\n      const rowValue = value as ResultRow;\n      const rowType = type as SerializedTypes.Row;\n      return Row.fromNamedCells(\n        rowValue.map((cell, index) =>\n          resultToValue({ type: rowType.rowCellTypes[index], value: cell })\n        ),\n        rowType.rowCellNames\n      );\n  }\n};\n","import { Type } from '..';\nimport type { Interpreter } from '../interpreter';\nimport { SerializedType, SerializedTypeKind, serializeType } from '../type';\nimport { UnknownValue } from '../value';\nimport { validateResult } from './validate';\n\nexport { validateResult } from './validate';\n\ntype OneResult = Interpreter.OneResult;\nexport type { OneResult };\n\nexport { UnknownValue };\n\n// Can be used as Result to represent the entire spectrum of possible result values and types or\n// Result<'number'> to represent a specific kind of result value and type.\nexport interface Result<T extends SerializedTypeKind = SerializedTypeKind> {\n  value: T extends 'number'\n    ? Interpreter.ResultNumber\n    : T extends 'boolean'\n    ? Interpreter.ResultBoolean\n    : T extends 'string'\n    ? Interpreter.ResultString\n    : T extends 'date'\n    ? Interpreter.ResultDate\n    : T extends 'range'\n    ? Interpreter.ResultRange\n    : T extends 'column'\n    ? Interpreter.ResultColumn\n    : T extends 'table'\n    ? Interpreter.ResultTable\n    : T extends 'row'\n    ? Interpreter.ResultRow\n    : T extends 'function'\n    ? Interpreter.ResultUnknown | null\n    : T extends 'type-error'\n    ? Interpreter.ResultUnknown | null\n    : never;\n  type: T extends SerializedTypeKind ? Extract<SerializedType, { kind: T }> : T;\n}\n\nexport * from './resultToValue';\nexport * as ResultTransforms from './ResultTransforms';\nexport { Column } from './Column';\nexport type { ColumnLike, Comparable } from './Column';\n\nexport function serializeResult<T extends SerializedTypeKind>(\n  type: Type,\n  value: Interpreter.OneResult | null | undefined\n): Result<T> {\n  validateResult(type, value);\n  const serializedType = serializeType(type);\n  return {\n    value,\n    type: serializedType,\n  } as Result<T>;\n}\n","import pSeries from 'p-series';\nimport { AST, prettyPrintAST } from '..';\nimport { callBuiltin, getConstantByName } from '../builtins';\nimport {\n  getOfType,\n  getDefined,\n  getIdentifierString,\n  multiplyMultipliers,\n} from '../utils';\nimport { dateNodeToTimeUnit, getDateFromAstForm } from '../date';\nimport { expandDirectiveToValue } from '../directives';\n\nimport { Realm } from './Realm';\nimport {\n  Scalar,\n  Range,\n  DateValue,\n  Column,\n  Value,\n  UnknownValue,\n  columnFromDateSequence,\n  columnFromSequence,\n} from '../value';\nimport { evaluateTable, getProperty } from '../tables/evaluate';\nimport { getDateSequenceIncrement } from '../infer/sequence';\nimport { isPreviousRef } from '../previous-ref';\nimport { evaluateMatrixRef, evaluateMatrixAssign } from '../matrix';\nimport { evaluateCategories } from '../categories';\nimport { evaluateColumnAssign } from '../tables/column-assign';\nimport { evaluateMatch } from '../match/evaluateMatch';\nimport { evaluateTiered } from '../tiered/evaluateTiered';\nimport { RuntimeError } from '.';\nimport { resultToValue } from '../result';\n\n// Gets a single value from an expanded AST.\n\n// exhaustive switch\n// eslint-disable-next-line consistent-return\nexport async function evaluate(\n  realm: Realm,\n  node: AST.Statement\n): Promise<Value> {\n  switch (node.type) {\n    case 'noop': {\n      return UnknownValue;\n    }\n    case 'literal': {\n      switch (node.args[0]) {\n        case 'number': {\n          const type = realm.maybeGetTypeAt(node);\n          if (type && type.unit) {\n            return Scalar.fromValue(\n              multiplyMultipliers(type.unit, node.args[1])\n            );\n          }\n          return Scalar.fromValue(node.args[1]);\n        }\n        case 'string':\n        case 'boolean': {\n          return Scalar.fromValue(node.args[1]);\n        }\n        default: {\n          throw new Error(\n            `not implemented: literals with type ${node.args[0]}`\n          );\n        }\n      }\n    }\n    case 'assign': {\n      const varName = getIdentifierString(node.args[0]);\n      const value = await evaluate(realm, node.args[1]);\n      realm.stack.set(varName, value, 'function', realm.statementId);\n      return value;\n    }\n    case 'ref': {\n      const identifier = getIdentifierString(node);\n      if (isPreviousRef(identifier)) {\n        if (realm.previousStatementValue == null) {\n          throw new RuntimeError('No previous value');\n        }\n        return realm.previousStatementValue;\n      }\n      const c = getConstantByName(identifier);\n      if (c) {\n        return c.value;\n      }\n      const value = realm.stack.get(identifier);\n      if (value != null) {\n        return value;\n      }\n\n      const type = realm.getTypeAt(node);\n      const unit = getDefined(\n        type.unit,\n        `no unit for ${identifier}, which probably means that ${identifier} is not a number`\n      );\n      return Scalar.fromValue(multiplyMultipliers(unit));\n    }\n    case 'externalref': {\n      const data = realm.externalData.get(node.args[0]);\n      if (data) {\n        return resultToValue(data);\n      }\n      return UnknownValue;\n    }\n    case 'function-call': {\n      const funcName = getIdentifierString(node.args[0]);\n      const funcArgs = getOfType('argument-list', node.args[1]).args;\n      const args = await pSeries(\n        funcArgs.map((arg) => () => evaluate(realm, arg))\n      );\n\n      if (funcName === 'previous') {\n        return realm.previousValue ?? args[0];\n      } else if (realm.functions.has(funcName)) {\n        const customFunc = getDefined(realm.functions.get(funcName));\n\n        return realm.stack.withPushCall(async () => {\n          for (let i = 0; i < args.length; i++) {\n            const argName = getIdentifierString(customFunc.args[1].args[i]);\n\n            realm.stack.set(argName, args[i]);\n          }\n\n          const funcBody: AST.Block = customFunc.args[2];\n\n          for (let i = 0; i < funcBody.args.length; i++) {\n            // eslint-disable-next-line no-await-in-loop\n            const value = await evaluate(realm, funcBody.args[i]);\n\n            if (i === funcBody.args.length - 1) {\n              return value;\n            }\n          }\n\n          throw new Error('function is empty');\n        });\n      } else {\n        const argTypes = funcArgs.map((arg) =>\n          getDefined(\n            realm.inferContext.nodeTypes.get(arg),\n            () => `Could not get type for node ${prettyPrintAST(arg)}`\n          )\n        );\n        const returnType = getDefined(realm.inferContext.nodeTypes.get(node));\n        return callBuiltin(realm, funcName, args, argTypes, returnType);\n      }\n    }\n    case 'range': {\n      const [start, end] = await pSeries(\n        node.args.map((arg) => () => evaluate(realm, getDefined(arg)))\n      );\n\n      return Range.fromBounds(start, end);\n    }\n    case 'sequence': {\n      const start = await evaluate(realm, getDefined(node.args[0]));\n      const end = await evaluate(realm, getDefined(node.args[1]));\n\n      if (start instanceof DateValue && end instanceof DateValue) {\n        const startUnit = dateNodeToTimeUnit(\n          getOfType('date', node.args[0]).args\n        );\n        const endUnit = dateNodeToTimeUnit(\n          getOfType('date', node.args[1]).args\n        );\n\n        const step = getDateSequenceIncrement(node.args[2], startUnit, endUnit);\n        return columnFromDateSequence(start, end, step);\n      } else {\n        const step = node.args[2]\n          ? await evaluate(realm, node.args[2])\n          : undefined;\n        return columnFromSequence(start, end, step);\n      }\n    }\n    case 'date': {\n      const [dateMs, specificity] = getDateFromAstForm(node.args);\n      return DateValue.fromDateAndSpecificity(dateMs, specificity);\n    }\n    case 'column': {\n      const values: Value[] = await pSeries(\n        node.args[0].args.map((v) => () => evaluate(realm, v))\n      );\n\n      return Column.fromValues(values);\n    }\n    case 'table': {\n      return evaluateTable(realm, node);\n    }\n    case 'property-access': {\n      const tableOrRow = await evaluate(realm, node.args[0]);\n      return getProperty(tableOrRow, node.args[1]);\n    }\n    case 'table-column-assign': {\n      return evaluateColumnAssign(realm, node);\n    }\n    case 'matrix-assign': {\n      return evaluateMatrixAssign(realm, node);\n    }\n    case 'matrix-ref': {\n      return evaluateMatrixRef(realm, node);\n    }\n    case 'categories': {\n      return evaluateCategories(realm, node);\n    }\n    case 'function-definition': {\n      const funcName = getIdentifierString(getDefined(node.args[0]));\n      realm.functions.set(funcName, node);\n\n      // Typecheck ensures this isn't used as a result\n      // but we want to always return something\n      return UnknownValue;\n    }\n    case 'directive': {\n      return expandDirectiveToValue(realm, node);\n    }\n    case 'match': {\n      return evaluateMatch(realm, node);\n    }\n    case 'tiered': {\n      return evaluateTiered(realm, node);\n    }\n  }\n}\n\nexport async function evaluateStatement(\n  realm: Realm,\n  statement: AST.Statement\n) {\n  const value = await evaluate(realm, statement);\n  return value;\n}\n\nexport async function evaluateBlock(\n  realm: Realm,\n  block: AST.Block\n): Promise<Value> {\n  let previous;\n  for (const statement of block.args) {\n    // eslint-disable-next-line no-await-in-loop\n    previous = await evaluateStatement(realm, statement);\n  }\n\n  return getDefined(previous, 'panic: Unexpected empty block');\n}\n","import { zip } from '@decipad/utils';\nimport { isColumnLike, ColumnLike, Table, Value } from '../value';\nimport type { AST, ExternalDataMap, Context } from '..';\nimport { Stack, StackNamespaceJoiner, StackNamespaceSplitter } from '../stack';\nimport { getDefined } from '../utils';\n\n// The name \"realm\" comes from V8.\n// It's passed around during interpretation and\n// contains a stack of variables and a map of\n// function names to AST.FunctionDefinition.\nexport class Realm {\n  stack = new Stack<Value>(undefined, tableItemsToTable, tableToTableItems);\n  functions = new Map<string, AST.FunctionDefinition>();\n  previousValue: Value | null = null;\n  inferContext: Context;\n  previousStatementValue?: Value;\n  statementId?: string;\n\n  get externalData() {\n    return this.inferContext.externalData;\n  }\n  set externalData(value: ExternalDataMap) {\n    this.inferContext.externalData = value;\n  }\n\n  maybeGetTypeAt(node: AST.Node) {\n    return this.inferContext.nodeTypes.get(node);\n  }\n\n  getTypeAt(node: AST.Node) {\n    return getDefined(\n      this.maybeGetTypeAt(node),\n      `Could not find type for ${node.type}`\n    );\n  }\n\n  constructor(context: Context) {\n    this.inferContext = context;\n  }\n}\n\nconst tableItemsToTable: StackNamespaceJoiner<Value> = (tableItems) => {\n  for (const v of tableItems.values()) {\n    if (!isColumnLike(v)) throw new Error('expected column-like');\n  }\n  return Table.fromMapping(tableItems as Map<string, ColumnLike>);\n};\n\nconst tableToTableItems: StackNamespaceSplitter<Value> = (table) => {\n  if (table instanceof Table) {\n    return zip(table.columnNames, table.columns);\n  }\n  return undefined;\n};\n","import { getDefined } from '@decipad/utils';\nimport type { AST } from '..';\nimport { block } from '../utils';\nimport { inferProgram } from '../infer';\nimport { Realm } from './Realm';\nimport type * as Interpreter from './interpreter-types';\nimport { evaluate } from './evaluate';\nimport { evaluateTargets } from './selective';\n// TODO replace these with the ones in src/run, or move them there\n\nexport const run = async (\n  program: AST.Block[],\n  desiredTargets: Array<string | number | [number, number]>,\n  realm?: Realm\n): Promise<Interpreter.OneResult[]> => {\n  realm = realm ?? new Realm(await inferProgram(program));\n\n  return (await evaluateTargets(program, desiredTargets, realm)).map((v) => {\n    return v.getData();\n  });\n};\n\nexport const runOne = async (statement: AST.Statement, realm?: Realm) => {\n  realm = realm ?? new Realm(await inferProgram([block(statement)]));\n\n  const value = await evaluate(realm, statement);\n  return value.getData();\n};\n\nexport const runBlock = async (block: AST.Block, realm?: Realm) => {\n  realm = realm ?? new Realm(await inferProgram([block]));\n\n  let last;\n  for (const stmt of block.args) {\n    // eslint-disable-next-line no-await-in-loop\n    last = await evaluate(realm, stmt);\n  }\n\n  return getDefined(last, 'Unexpected empty block').getData();\n};\n","import { narrowFunctionCall, parseFunctionSignature, Type } from '../type';\n\nexport const parseFunctor = (signature: string) => {\n  const { expectedArgs, returnType } = parseFunctionSignature(signature);\n  return (args: Type[]) =>\n    narrowFunctionCall({ args, expectedArgs, returnType });\n};\n","import { BuiltinSpec } from './interfaces';\nimport { InferError, Type, build as t } from '../type';\nimport {\n  Value,\n  DateValue,\n  Range,\n  StringValue,\n  BooleanValue,\n  NumberValue,\n} from '../value';\nimport { getDefined } from '../utils';\nimport { AST } from '..';\nimport { parseFunctor } from './parseFunctor';\n\nexport type OverloadTypeName =\n  | 'number'\n  | 'string'\n  | 'boolean'\n  | 'unit'\n  | 'date'\n  | 'range';\n\nexport type OverloadedBuiltinSpec =\n  | {\n      argTypes: OverloadTypeName[];\n      fnValues: (values: Value[], types?: Type[]) => Value;\n      functor: (types: Type[], values?: AST.Expression[]) => Type;\n      functionSignature?: undefined;\n    }\n  | {\n      argTypes: OverloadTypeName[];\n      fnValues: (values: Value[], types?: Type[]) => Value;\n      functor?: undefined;\n      functionSignature: string;\n    };\n\nexport const overloadBuiltin = (\n  fName: string,\n  argCount: number,\n  overloads: OverloadedBuiltinSpec[],\n  operatorKind?: 'prefix' | 'infix'\n): BuiltinSpec => {\n  const byArgTypes = new Map(\n    overloads.map((o) => [argTypesKey(o.argTypes), o])\n  );\n\n  function getOverload(values: Value[]): OverloadedBuiltinSpec {\n    const argTypeNames = values.map(getOverloadedTypeFromValue);\n    return getDefined(\n      byArgTypes.get(argTypesKey(argTypeNames)),\n      `panic: did not find version of function ${fName} for arg types ${argTypeNames.join(\n        ', '\n      )}`\n    );\n  }\n\n  const fnValues = (values: Value[], types?: Type[]) => {\n    return getOverload(values).fnValues(values, types);\n  };\n\n  const functor = (types: Type[]) => {\n    const argTypeNames = types.map(getOverloadedTypeFromType);\n    const overload = byArgTypes.get(argTypesKey(argTypeNames));\n\n    if (overload == null) {\n      return t.impossible(InferError.badOverloadedBuiltinCall(fName, types));\n    } else {\n      const resolvedFunctor =\n        overload.functor ?? parseFunctor(overload.functionSignature);\n      return resolvedFunctor(types);\n    }\n  };\n\n  return {\n    argCount,\n    fnValues,\n    functor,\n    operatorKind,\n  };\n};\n\n// for string Maps\nconst argTypesKey = (types: (OverloadTypeName | null)[]) => types.join(';');\n\nexport const getOverloadedTypeFromValue = (\n  val: Value\n): OverloadTypeName | null => {\n  if (val instanceof StringValue) {\n    return 'string';\n  } else if (val instanceof BooleanValue) {\n    return 'boolean';\n  } else if (val instanceof NumberValue) {\n    return 'number';\n  } else if (val instanceof DateValue) {\n    return 'date';\n  } else if (val instanceof Range) {\n    return 'range';\n  } else {\n    return null;\n  }\n};\n\nexport const getOverloadedTypeFromType = (t: Type): OverloadTypeName | null => {\n  if (t.type != null) {\n    return t.type;\n  } else if (t.date != null) {\n    return 'date';\n  } else if (t.rangeOf) {\n    return 'range';\n  } else {\n    return null;\n  }\n};\n","import { N } from '@decipad/number';\nimport { DateValue, NumberValue } from '../value';\nimport {\n  addTime,\n  cmpSpecificities,\n  getHighestSpecificity as getMostSpecific,\n  subtractDates,\n  Time,\n  timeUnitFromUnits,\n} from '../date';\nimport { getDefined, getInstanceof } from '../utils';\nimport { Type, build as t, InferError } from '../type';\nimport { OverloadedBuiltinSpec } from './overloadBuiltin';\n\nexport const addDateAndTimeQuantity = (\n  date: DateValue,\n  unit: Time.Unit,\n  amount: bigint\n) => {\n  const newDate = addTime(date.getData(), unit, amount);\n\n  return DateValue.fromDateAndSpecificity(newDate, date.specificity);\n};\n\nexport const dateAndTimeQuantityFunctor = ([date, timeQuantity]: Type[]) =>\n  Type.combine(date.isDate(), timeQuantity.isTimeQuantity()).mapType(() => {\n    const dateSpecificity = getDefined(date.date);\n\n    const lowestUnit = getMostSpecific(getDefined(timeQuantity.unit));\n\n    if (cmpSpecificities(dateSpecificity, lowestUnit) < 0) {\n      return t.impossible(\n        InferError.mismatchedSpecificity(dateSpecificity, lowestUnit)\n      );\n    } else {\n      return date;\n    }\n  });\n\nexport const subtractDatesFunctor = ([t1, t2]: Type[]) => {\n  const d1Specificity = getDefined(t1.date);\n  const d2Specificity = getDefined(t2.date);\n\n  if (cmpSpecificities(d1Specificity, d2Specificity) !== 0) {\n    return t.impossible(\n      InferError.mismatchedSpecificity(d1Specificity, d2Specificity)\n    );\n  }\n\n  return Type.combine(\n    t1.isDate(),\n    t2.isDate(),\n    t.number([\n      {\n        unit: d1Specificity,\n        exp: N(1),\n        multiplier: N(1),\n        known: true,\n      },\n    ])\n  );\n};\n\nexport const dateOverloads: Record<string, OverloadedBuiltinSpec[]> = {\n  '+': [\n    {\n      argTypes: ['date', 'number'],\n      fnValues: ([v1, v2], [, t2] = []) =>\n        addDateAndTimeQuantity(\n          getInstanceof(v1, DateValue),\n\n          timeUnitFromUnits(getDefined(t2?.unit)),\n          BigInt(getInstanceof(v2, NumberValue).getData().valueOf())\n        ),\n      functor: ([t1, t2]) =>\n        Type.combine(t2.isTimeQuantity(), () =>\n          dateAndTimeQuantityFunctor([t1, t2])\n        ),\n    },\n    {\n      argTypes: ['number', 'date'],\n      fnValues: ([v1, v2], [t1] = []) =>\n        addDateAndTimeQuantity(\n          getInstanceof(v2, DateValue),\n          timeUnitFromUnits(getDefined(t1?.unit)),\n          BigInt(getInstanceof(v1, NumberValue).getData().valueOf())\n        ),\n      functor: ([t1, t2]) =>\n        Type.combine(t1.isTimeQuantity(), () =>\n          dateAndTimeQuantityFunctor([t2, t1])\n        ),\n    },\n  ],\n  '-': [\n    {\n      argTypes: ['date', 'number'],\n      fnValues: ([v1, v2], [, t2] = []) => {\n        const number = getInstanceof(v2, NumberValue);\n\n        const negatedQuantity = BigInt(number.getData().neg().valueOf());\n\n        return addDateAndTimeQuantity(\n          getInstanceof(v1, DateValue),\n          timeUnitFromUnits(getDefined(t2?.unit)),\n          negatedQuantity\n        );\n      },\n      functor: dateAndTimeQuantityFunctor,\n    },\n    {\n      argTypes: ['date', 'date'],\n      fnValues: ([v1, v2]) => {\n        const d1 = getInstanceof(v1, DateValue);\n        const d2 = getInstanceof(v2, DateValue);\n        const difference = subtractDates(d1, d2, d1.specificity);\n\n        return NumberValue.fromValue(difference);\n      },\n      functor: subtractDatesFunctor,\n    },\n  ],\n};\n","import { AST } from '..';\nimport { callBuiltin } from '../builtins';\nimport { getOfType, getDefined, getIdentifierString } from '../utils';\n\nimport { Realm } from './Realm';\nimport { NumberValue } from '../value';\n\nimport { InferError } from '../type';\n\n// Gets a single value from a simple expression (literals and\n// zero-dimension builtin functions only) expanded AST.\n\n// eslint-disable-next-line consistent-return\nexport function simpleExpressionEvaluate(\n  realm: Realm,\n  node: AST.Statement\n): NumberValue {\n  switch (node.type) {\n    case 'literal': {\n      switch (node.args[0]) {\n        case 'number': {\n          return NumberValue.fromValue(node.args[1]);\n        }\n        default: {\n          throw InferError.expectedButGot('number', node.args[0]);\n        }\n      }\n    }\n    case 'function-call': {\n      const funcName = getIdentifierString(node.args[0]);\n      const funcArgs = getOfType('argument-list', node.args[1]).args;\n      const args = funcArgs.map((arg) => simpleExpressionEvaluate(realm, arg));\n      const argTypes = funcArgs.map((arg) =>\n        getDefined(\n          realm.inferContext.nodeTypes.get(arg),\n          'exponent type should be defined'\n        )\n      );\n      const returnType = getDefined(realm.inferContext.nodeTypes.get(node));\n      const res = callBuiltin(realm, funcName, args, argTypes, returnType);\n      if (!(res instanceof NumberValue)) {\n        throw InferError.complexExpressionExponent();\n      }\n      return res;\n    }\n    default: {\n      throw InferError.complexExpressionExponent();\n    }\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport produce from 'immer';\nimport DeciNumber, { N, ZERO, ONE, TWO } from '@decipad/number';\nimport { getDefined, zip } from '@decipad/utils';\nimport { RuntimeError, Realm } from '../../interpreter';\nimport { getInstanceof, multiplyMultipliers } from '../../utils';\nimport { InferError, Type, build as t } from '../../type';\nimport {\n  fromJS,\n  Scalar,\n  Value,\n  isColumnLike,\n  NumberValue,\n  compare,\n} from '../../value';\nimport { AST } from '../../parser';\nimport { overloadBuiltin } from '../overloadBuiltin';\nimport { dateOverloads } from '../dateOverloads';\nimport { BuiltinSpec } from '../interfaces';\nimport { Context } from '../../infer';\n\nimport { simpleExpressionEvaluate } from '../../interpreter/simple-expression-evaluate';\n\nconst binopFunctor = ([a, b]: Type[]) =>\n  Type.combine(a.isScalar('number'), b.sameAs(a));\n\nconst removeUnit = produce((t: Type) => {\n  if (t.type === 'number') t.unit = null;\n});\n\nconst exponentiationFunctor = (\n  [a, b]: Type[],\n  values?: AST.Expression[],\n  context?: Context\n) => {\n  const bValue = getDefined(values?.[1]);\n  const ctx = getDefined(context, 'context should be defined');\n\n  let u: DeciNumber;\n  if (a.unit && a.unit.length > 0) {\n    const realm = new Realm(ctx);\n    try {\n      u = simpleExpressionEvaluate(realm, bValue).getData();\n    } catch (err) {\n      if (err instanceof InferError) {\n        return t.impossible(err);\n      } else {\n        throw err;\n      }\n    }\n    return binopFunctor([a, removeUnit(b)]).mapType(\n      produce((arg1) => {\n        for (const unit of arg1.unit ?? []) {\n          unit.exp = (unit.exp || N(1)).mul(u);\n        }\n      })\n    );\n  } else {\n    return binopFunctor([a, removeUnit(b)]);\n  }\n};\n\nconst roundFunctor: BuiltinSpec['functor'] = ([\n  n,\n  decimalPrecision = t.number(),\n]) => Type.combine(decimalPrecision.isScalar('number'), n.isScalar('number'));\n\nconst roundWrap = (\n  round: (f: DeciNumber, decimalPrecisionValue: number) => DeciNumber\n): BuiltinSpec['fn'] => {\n  return ([nValue, decimalPrecisionValue], [type] = []) => {\n    const n = getInstanceof(nValue, DeciNumber);\n    const multiplier = multiplyMultipliers(type.unit);\n    const decimalPrecision = decimalPrecisionValue\n      ? getInstanceof(decimalPrecisionValue, DeciNumber)\n      : ZERO;\n    // in order for the round function to round at the correct precision, we need to first divide by\n    // the unit multiplier, do the rouding, and *then* multiply by it at the end.\n    return round(n.div(multiplier), decimalPrecision.valueOf()).mul(multiplier);\n  };\n};\n\nconst firstArgumentReducedFunctor = ([t]: Type[]) => t.reduced();\n\nconst coherceToFraction = (value: unknown): DeciNumber => {\n  return getInstanceof(value, DeciNumber);\n};\n\nconst max = ([value]: Value[]): Value => {\n  let max: Value | undefined;\n  if (!isColumnLike(value)) {\n    return value;\n  }\n  for (let i = 0; i < value.rowCount; i += 1) {\n    const cellValue = value.atIndex(i);\n    if (max) {\n      if (compare(cellValue, max) > 0) {\n        max = cellValue;\n      }\n    } else {\n      max = cellValue;\n    }\n  }\n  if (max == null) {\n    throw new RuntimeError('max: no elements');\n  }\n  return max;\n};\n\nconst min = ([value]: Value[]): Value => {\n  let min: Value | undefined;\n  if (!isColumnLike(value)) {\n    return value;\n  }\n  for (let i = 0; i < value.rowCount; i += 1) {\n    const cellValue = value.atIndex(i);\n    if (min) {\n      if (compare(cellValue, min) < 0) {\n        min = cellValue;\n      }\n    } else {\n      min = cellValue;\n    }\n  }\n  if (min == null) {\n    throw new RuntimeError('min: no elements');\n  }\n  return min;\n};\n\nconst average = ([value]: Value[]): Value => {\n  const fractions = (value.getData() as DeciNumber[]).map(coherceToFraction);\n  if (fractions.length === 0) {\n    throw new RuntimeError('average needs at least one element');\n  }\n  return fromJS(\n    fractions.reduce((acc, n) => acc.add(n), ZERO).div(N(fractions.length))\n  );\n};\n\nconst median = ([value]: Value[]): Value => {\n  const fractions = (value.getData() as DeciNumber[]).map(coherceToFraction);\n  if (fractions.length === 0) {\n    throw new RuntimeError('median needs at least one element');\n  }\n  const sortedValues = fractions.sort((f1, f2) => f1.compare(f2));\n  const { length } = sortedValues;\n  const rightCenterPos = Math.floor(length / 2);\n  const rightCenter = sortedValues[rightCenterPos];\n  if (length % 2 === 1) {\n    return fromJS(rightCenter);\n  }\n  const leftCenter = sortedValues[rightCenterPos - 1];\n  return fromJS(leftCenter.add(rightCenter).div(TWO));\n};\n\nconst secondArgIsPercentage = (types?: Type[]) =>\n  types?.[0].numberFormat == null && types?.[1].numberFormat === 'percentage';\n\nexport const mathOperators: Record<string, BuiltinSpec> = {\n  abs: {\n    argCount: 1,\n    noAutoconvert: true,\n    fn: ([n]) => Math.abs(n as number),\n    functionSignature: 'number:R -> R',\n  },\n  round: {\n    argCount: [1, 2],\n    noAutoconvert: true,\n    functor: roundFunctor,\n    fn: roundWrap((n: DeciNumber, decimalPlaces: number) =>\n      n.round(decimalPlaces)\n    ),\n  },\n  roundup: {\n    argCount: [1, 2],\n    noAutoconvert: true,\n    functor: roundFunctor,\n    fn: roundWrap((n: DeciNumber, decimalPlaces: number) =>\n      n.ceil(decimalPlaces)\n    ),\n  },\n  ceil: {\n    aliasFor: 'roundup',\n  },\n  rounddown: {\n    argCount: [1, 2],\n    noAutoconvert: true,\n    functor: roundFunctor,\n    fn: roundWrap((n: DeciNumber, decimalPlaces: number) =>\n      n.floor(decimalPlaces)\n    ),\n  },\n  floor: {\n    aliasFor: 'rounddown',\n  },\n  max: {\n    argCount: 1,\n    argCardinalities: [2],\n    isReducer: true,\n    functor: firstArgumentReducedFunctor,\n    fnValues: max,\n  },\n  min: {\n    argCount: 1,\n    argCardinalities: [2],\n    isReducer: true,\n    functor: firstArgumentReducedFunctor,\n    fnValues: min,\n  },\n  average: {\n    argCount: 1,\n    argCardinalities: [2],\n    isReducer: true,\n    fnValues: average,\n    functionSignature: 'column<R> -> R',\n  },\n  avg: { aliasFor: 'average' },\n  mean: { aliasFor: 'average' },\n  averageif: {\n    argCount: 2,\n    noAutoconvert: true,\n    argCardinalities: [2, 2],\n    fnValues: ([_numbers, _bools]: Value[]) => {\n      const numbers = _numbers.getData() as DeciNumber[];\n      const bools = _bools.getData() as boolean[];\n      if (numbers.length === 0) {\n        throw new RuntimeError(\n          'average: cannot compute average on zero elements'\n        );\n      }\n\n      let count = ZERO;\n      let sum = N(0);\n\n      for (const [bool, num] of zip(bools, numbers)) {\n        if (bool) {\n          count = count.add(ONE);\n          sum = sum.add(num);\n        }\n      }\n\n      return fromJS(sum.div(count));\n    },\n    functor: ([numbers, booleans]) =>\n      Type.combine(\n        booleans.reduced().isScalar('boolean'),\n        numbers.reduced().isScalar('number')\n      ),\n  },\n  avgif: { aliasFor: 'averageif' },\n  meanif: { aliasFor: 'averageif' },\n  median: {\n    argCount: 1,\n    argCardinalities: [2],\n    isReducer: true,\n    fnValues: median,\n    functionSignature: 'column<R> -> R',\n  },\n  sqrt: {\n    argCount: 1,\n    fn: ([n]) => {\n      let result: DeciNumber | undefined;\n      try {\n        result = getInstanceof(n, DeciNumber).pow(N(1, 2));\n      } catch (err) {\n        console.error(err);\n      }\n      if (result == null) {\n        // TODO: fraction.js gives us a null result when the result is non-rational\n        // TODO: this is an approximation, so we should warn the user\n        const nonRationalResult = n.valueOf() ** 0.5;\n        if (Number.isNaN(nonRationalResult)) {\n          throw new RuntimeError(\n            `square root of ${n.toString()} is not a number`\n          );\n        }\n        result = N(nonRationalResult);\n      }\n      return result;\n    },\n    functor: ([n]) => Type.combine(n.isScalar('number'), n.divideUnit(2)),\n  },\n  ln: {\n    argCount: 1,\n    noAutoconvert: true,\n    fn: ([n]) => Math.log(n),\n    functionSignature: 'number:R -> R',\n  },\n  factorial: {\n    argCount: 1,\n    fnValues: (() => {\n      const lookupTable = Array(100_000);\n\n      return ([n]) => {\n        const frac = getInstanceof(n.getData(), DeciNumber);\n\n        if (frac.compare(ZERO) < 0) {\n          throw new RuntimeError(\n            'factorial() requires a positive number or zero'\n          );\n        }\n\n        if (frac.compare(N(100000)) > 0) {\n          throw new RuntimeError('factorial() number too large');\n        }\n\n        if (frac.compare(TWO) < 0) {\n          return new NumberValue(ONE);\n        }\n\n        if (frac.valueOf() !== Math.round(frac.valueOf())) {\n          throw new RuntimeError('factorial() number not an integer');\n        }\n\n        if (lookupTable[frac.valueOf()]) {\n          return new NumberValue(N(lookupTable[frac.valueOf()]));\n        }\n\n        let i = BigInt(frac.valueOf() - 1);\n        let fact = BigInt(frac.valueOf());\n        for (; i >= 1; i--) {\n          fact *= i;\n        }\n\n        lookupTable[frac.valueOf()] = fact;\n\n        return new NumberValue(N(fact));\n      };\n    })(),\n    functor: ([n]) => n,\n  },\n  '+': overloadBuiltin(\n    '+',\n    2,\n    [\n      {\n        argTypes: ['number', 'number'],\n        fnValues: ([n1, n2], types) => {\n          if (secondArgIsPercentage(types)) {\n            return Scalar.fromValue(\n              (n1.getData() as DeciNumber).mul(\n                (n2.getData() as DeciNumber).add(ONE)\n              )\n            );\n          }\n\n          return Scalar.fromValue(\n            (n1.getData() as DeciNumber).add(n2.getData() as DeciNumber)\n          );\n        },\n        functor: binopFunctor,\n      },\n      {\n        argTypes: ['string', 'string'],\n        fnValues: ([n1, n2]) =>\n          Scalar.fromValue(String(n1.getData()) + String(n2.getData())),\n        functor: ([a, b]) =>\n          Type.combine(a.isScalar('string'), b.isScalar('string')),\n      },\n      ...dateOverloads['+'],\n    ],\n    'infix'\n  ),\n  '-': overloadBuiltin(\n    '-',\n    2,\n    [\n      {\n        argTypes: ['number', 'number'],\n        fnValues: ([a, b], types) => {\n          if (secondArgIsPercentage(types)) {\n            return Scalar.fromValue(\n              (a.getData() as DeciNumber).mul(\n                ONE.sub(b.getData() as DeciNumber)\n              )\n            );\n          }\n\n          return Scalar.fromValue(\n            (a.getData() as DeciNumber).sub(b.getData() as DeciNumber)\n          );\n        },\n        functor: binopFunctor,\n      },\n      ...dateOverloads['-'],\n    ],\n    'infix'\n  ),\n  'unary-': {\n    argCount: 1,\n    noAutoconvert: true,\n    fn: ([a]) => a.neg(),\n    functionSignature: 'number:R -> R',\n    operatorKind: 'prefix',\n  },\n  '*': {\n    argCount: 2,\n    fn: ([a, b]) => getInstanceof(a, DeciNumber).mul(b),\n    functor: ([a, b]) =>\n      Type.combine(\n        a.isScalar('number'),\n        b.isScalar('number'),\n        a.sharePercentage(b).multiplyUnit(b.unit)\n      ),\n    operatorKind: 'infix',\n  },\n  // this is added when we use implicit multiplication instead of '*'\n  // there is a separate function because this way we can tell it apart from '*'\n  'implicit*': {\n    aliasFor: '*',\n    operatorKind: 'prefix',\n  },\n  for: {\n    aliasFor: '*',\n    operatorKind: 'prefix',\n  },\n  '/': {\n    argCount: 2,\n    fn: ([a, b]) => getInstanceof(a, DeciNumber).div(b),\n    functor: ([a, b]) =>\n      Type.combine(\n        a.isScalar('number'),\n        b.isScalar('number'),\n        a.sharePercentage(b).divideUnit(b.unit)\n      ),\n    operatorKind: 'infix',\n  },\n  per: {\n    aliasFor: '/',\n    operatorKind: 'infix',\n  },\n  mod: {\n    argCount: 2,\n    fn: ([a, b]) => a.mod(b),\n    functor: binopFunctor,\n    operatorKind: 'infix',\n  },\n  modulo: {\n    aliasFor: 'mod',\n    operatorKind: 'infix',\n  },\n  '**': {\n    argCount: 2,\n    fn: ([a, b]) => getInstanceof(a, DeciNumber).pow(b),\n    noAutoconvert: true,\n    absoluteNumberInput: true,\n    functor: exponentiationFunctor,\n    operatorKind: 'infix',\n  },\n  '^': {\n    aliasFor: '**',\n  },\n  smooth: {\n    argCount: 2,\n    fn: () => 69,\n    functor: () => t.number(),\n  },\n};\n","import { BuiltinSpec } from '../interfaces';\nimport { Type, build as t, InferError } from '../../type';\nimport { compare } from '../../value';\n\nconst cmpFunctor = ([left, right]: Type[]): Type => {\n  if (left.type === 'boolean') {\n    return t.impossible(InferError.expectedButGot('number', left));\n  }\n  return Type.combine(right.sameAs(left), t.boolean());\n};\n\nexport const comparisonOperators: Record<string, BuiltinSpec> = {\n  '<': {\n    argCount: 2,\n    fn: ([a, b]) => compare(a, b) < 0,\n    functor: cmpFunctor,\n    operatorKind: 'infix',\n  },\n  '>': {\n    argCount: 2,\n    fn: ([a, b]) => compare(a, b) > 0,\n    functor: cmpFunctor,\n    operatorKind: 'infix',\n  },\n  '<=': {\n    argCount: 2,\n    fn: ([a, b]) => compare(a, b) <= 0,\n    functor: cmpFunctor,\n    operatorKind: 'infix',\n  },\n  '>=': {\n    argCount: 2,\n    fn: ([a, b]) => compare(a, b) >= 0,\n    functor: cmpFunctor,\n    operatorKind: 'infix',\n  },\n};\n","import { BuiltinSpec } from '../interfaces';\nimport { compare } from '../../value';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isEqual = (a: any, b: any) => {\n  if (typeof a === 'boolean' && typeof b === 'boolean') {\n    return a === b;\n  }\n  return compare(a, b) === 0;\n};\n\nexport const equalityOperators: Record<string, BuiltinSpec> = {\n  '==': {\n    argCount: 2,\n    fn: ([a, b]) => isEqual(a, b),\n    functionSignature: 'A, A -> boolean',\n    operatorKind: 'infix',\n  },\n  '!=': {\n    argCount: 2,\n    fn: ([a, b]) => !isEqual(a, b),\n    functionSignature: 'A, A -> boolean',\n    operatorKind: 'infix',\n  },\n};\n","import DeciNumber from '@decipad/number';\nimport { getDefined } from '@decipad/utils';\nimport { RuntimeError } from '../../interpreter';\nimport { OneResult } from '../../interpreter/interpreter-types';\nimport {\n  Value,\n  Column,\n  Table,\n  fromJS,\n  getColumnLike,\n  ValueTransforms,\n} from '../../value';\nimport { SwappedHypercube, ConcatenatedColumn } from '../../lazy';\nimport { Type, build as t } from '../../type';\nimport { getInstanceof } from '../../utils';\nimport { BuiltinSpec } from '../interfaces';\nimport { approximateSubsetSumIndices } from '../table';\n\nexport const listOperators: Record<string, BuiltinSpec> = {\n  len: {\n    argCount: 1,\n    isReducer: true,\n    noAutoconvert: true,\n    argCardinalities: [2],\n    fnValues: ([col]: Value[]) => fromJS(getColumnLike(col).rowCount),\n    functionSignature: 'column<A> -> number',\n  },\n  cat: {\n    argCount: 2,\n    argCardinalities: [2, 2],\n    // TODO: make this a varargs function\n    fnValues: ([a, b]: Value[]) =>\n      new ConcatenatedColumn(getColumnLike(a), getColumnLike(b)),\n    functor: ([a, b]) =>\n      Type.combine(a.reduced().sameAs(b.reduced())).mapType(() => {\n        const resultColumnSize =\n          a.columnSize === 'unknown' || b.columnSize === 'unknown'\n            ? 'unknown'\n            : (a.columnSize || 1) + (b.columnSize || 1);\n        return t.column(a.reduced(), resultColumnSize);\n      }),\n  },\n  first: {\n    argCount: 1,\n    argCardinalities: [2],\n    isReducer: true,\n    fnValues: ([arg]: Value[]) => getColumnLike(arg).atIndex(0),\n    functionSignature: 'column<A> -> A',\n  },\n  last: {\n    argCount: 1,\n    argCardinalities: [2],\n    isReducer: true,\n    fnValues: ([arg]: Value[]) => {\n      const col = getColumnLike(arg);\n      return col.atIndex(col.rowCount - 1);\n    },\n    functionSignature: 'column<A> -> A',\n  },\n  count: {\n    aliasFor: 'len',\n  },\n  countif: {\n    argCount: 1,\n    argCardinalities: [2],\n    isReducer: true,\n    fnValues: ([a]: Value[]) => {\n      const aData = getColumnLike(a).getData() as OneResult[];\n      return fromJS(\n        aData.reduce((count, elem) => (elem.valueOf() ? count + 1 : count), 0)\n      );\n    },\n    functionSignature: 'column<boolean> -> number',\n  },\n  stepgrowth: {\n    argCount: 1,\n    argCardinalities: [2],\n    fn: ([a]: number[][]) =>\n      a.map((item, index) => {\n        const previous = a[index - 1] ?? 0;\n        return item - previous;\n      }),\n    functionSignature: 'column<number>:A -> A',\n  },\n  grow: {\n    argCount: 3,\n    argCardinalities: [1, 1, 2],\n    fn: ([initial, growthRate, { length }]) =>\n      Array.from({ length }, (_, i) => {\n        const growth = (1 + growthRate) ** i;\n        return initial * growth;\n      }),\n    functor: ([initial, growthRate, period]) =>\n      Type.combine(\n        initial.isScalar('number'),\n        growthRate.isScalar('number'),\n        period.isColumn()\n      ).mapType(() => t.column(initial, getDefined(period.columnSize))),\n  },\n  transpose: {\n    argCount: 1,\n    argCardinalities: [3],\n    fnValues: ([matrix]) => new SwappedHypercube(getColumnLike(matrix), 1),\n    functor: ([matrix]) =>\n      Type.combine(matrix.isColumn().reduced().isColumn().reduced()).mapType(\n        (cell) => {\n          const horizontal = getDefined(matrix.columnSize);\n          const vertical = getDefined(matrix.reduced().columnSize);\n\n          return t.column(t.column(cell, horizontal), vertical);\n        }\n      ),\n  },\n\n  sort: {\n    argCount: 1,\n    argCardinalities: [2],\n    fnValues: ([column]) => ValueTransforms.sort(getColumnLike(column)),\n    functionSignature: 'column<A>:R -> R',\n  },\n\n  unique: {\n    argCount: 1,\n    argCardinalities: [2],\n    fnValues: ([column]) => ValueTransforms.unique(getColumnLike(column)),\n    functionSignature: 'column<A> -> column<A>',\n  },\n\n  reverse: {\n    argCount: 1,\n    functorNoAutomap: ([column]) =>\n      Type.either(column.isColumn(), column.isTable()),\n    fnValuesNoAutomap: ([column]) => {\n      if (column instanceof Table) {\n        return column.mapColumns((column) => ValueTransforms.reverse(column));\n      } else {\n        return ValueTransforms.reverse(getColumnLike(column));\n      }\n    },\n  },\n\n  // Table stuff\n  approximatesubsetsum: {\n    argCount: 3,\n    fnValues: ([upperBound, _table, columnName]) => {\n      const table = getInstanceof(_table, Table);\n      const { columnNames } = table;\n      const columnIndex = columnNames.indexOf(columnName.getData() as string);\n      if (columnIndex < 0) {\n        throw new RuntimeError(`Column ${columnName} does not exist`);\n      }\n\n      const indices = approximateSubsetSumIndices(\n        upperBound.getData() as DeciNumber,\n        table.getData() as unknown[][],\n        columnIndex\n      );\n\n      return table.mapColumns((column) =>\n        Column.fromValues(\n          column.values.filter((_, i) => indices.includes(i)),\n          []\n        )\n      );\n    },\n    functor: ([upperBound, table, columnName]) =>\n      Type.combine(\n        upperBound.isScalar('number'),\n        table.isTable(),\n        columnName.isScalar('string')\n      ).mapType(() =>\n        t.table({\n          columnNames: getDefined(table.columnNames),\n          columnTypes: getDefined(table.columnTypes),\n        })\n      ),\n  },\n};\n","import DeciNumber, { N } from '@decipad/number';\n\nexport const approximateSubsetSumIndices = (\n  upperBound: DeciNumber,\n  table: unknown[][],\n  columnIndex: number\n): number[] => {\n  const EPSILON = 0.01;\n\n  // initialize a list L to contain one element 0.\n  let l = [{ value: 0, rows: [] as number[] }];\n  // for each i from 1 to n do\n  for (let i = 0; i < table[columnIndex].length; i++) {\n    // let Ui be a list containing all elements y in L, and all sums xi + y for all y in L.\n    const u = [\n      ...l,\n      ...l.map(({ value, rows }) => ({\n        value: value + (table[columnIndex][i] as number),\n        rows: [...rows, i],\n      })),\n    ]\n      // sort Ui in ascending order\n      .sort(({ value: a }, { value: b }) => a - b);\n    // make L empty\n    l = [];\n    // let y be the smallest element of Ui\n    let y = u[0];\n    // add y to L\n    l.push(y);\n    // for each element z of Ui in increasing order do\n    for (const z of u) {\n      // if y +   T/n < z  T then\n      if (\n        y.value + EPSILON < z.value &&\n        N(upperBound).compare(N(z.value)) >= 0\n      ) {\n        y = z;\n        l.push(z);\n      }\n    }\n  }\n\n  const best = l.slice(-1)[0];\n  return best.rows;\n};\n","import DeciNumber, { ZERO } from '@decipad/number';\nimport type { BuiltinSpec } from '../interfaces';\nimport { Value, fromJS } from '../../value';\n\nexport const reducerOperators: { [fname: string]: BuiltinSpec } = {\n  total: {\n    noAutoconvert: true,\n    argCount: 1,\n    argCardinalities: [2],\n    isReducer: true,\n    fn: ([nums]: DeciNumber[][]) => nums.reduce((a, b) => a.add(b), ZERO),\n    functionSignature: 'column<number:R> -> R',\n  },\n  sum: {\n    aliasFor: 'total',\n  },\n  sumif: {\n    argCount: 2,\n    noAutoconvert: true,\n    argCardinalities: [2, 2],\n    fnValues: ([_numbers, _bools]: Value[]) => {\n      const numbers = _numbers.getData() as DeciNumber[];\n      const bools = _bools.getData() as boolean[];\n\n      return fromJS(\n        numbers.reduce<DeciNumber>(\n          (count, elem, index) =>\n            bools[index] ? count.add(elem as DeciNumber) : count,\n          ZERO\n        )\n      );\n    },\n    functionSignature: 'column<number:R>, column<boolean> -> R',\n  },\n};\n","import { getDefined } from '@decipad/utils';\nimport { dequal } from 'dequal';\nimport produce from 'immer';\nimport {\n  compare,\n  getColumnLike,\n  isColumnLike,\n  Row,\n  Table,\n  ValueTransforms,\n  RuntimeError,\n} from '../../value';\nimport { OneResult } from '../../interpreter/interpreter-types';\nimport { ConcatenatedColumn } from '../../lazy/ConcatenatedColumn';\nimport { build as t, Type } from '../../type';\nimport { getInstanceof, zip } from '../../utils';\nimport { BuiltinSpec } from '../interfaces';\n\nexport const tableOperators: { [fname: string]: BuiltinSpec } = {\n  lookup: {\n    argCount: 2,\n    functorNoAutomap: ([table, cond]) => {\n      const isBoolColumn = cond.isColumn().reduced().isScalar('boolean');\n\n      const whenTable = (table: Type) =>\n        table\n          .isTable()\n          .withMinimumColumnCount(1)\n          .mapType((table) => {\n            const columnTypes = getDefined(table.columnTypes);\n            const columnNames = getDefined(table.columnNames);\n\n            return Type.either(\n              isBoolColumn,\n              columnTypes[0].sameAs(cond)\n            ).mapType(() => t.row(columnTypes, columnNames, table.indexName));\n          });\n\n      if (table.cellType != null) {\n        return table.isColumn().reduced();\n      } else {\n        return whenTable(table);\n      }\n    },\n    // eslint-disable-next-line default-param-last\n    fnValuesNoAutomap: ([tableOrColumn, needle], [tableType] = [], realm) => {\n      const getNeedleIndexAtTable = (table: Table) => {\n        const needleVal = needle.getData();\n        const firstColumn = table.columns[0];\n\n        return firstColumn.values.findIndex(\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (value) => compare(value.getData() as any, needleVal as any) === 0\n        );\n      };\n\n      if (isColumnLike(tableOrColumn)) {\n        const originalTable = getInstanceof(\n          getDefined(realm).stack.get(\n            getDefined(tableType.indexedBy),\n            'global'\n          ),\n          Table\n        );\n\n        const index = getNeedleIndexAtTable(originalTable);\n        if (index === -1) {\n          throw new RuntimeError(\n            `Could not find a row with the given condition`\n          );\n        }\n\n        return tableOrColumn.atIndex(index);\n      }\n\n      const table = getInstanceof(tableOrColumn, Table);\n\n      let rowIndex: number;\n      if (isColumnLike(needle)) {\n        rowIndex = (needle.getData() as OneResult[]).findIndex(Boolean);\n      } else {\n        rowIndex = getNeedleIndexAtTable(table);\n      }\n\n      if (rowIndex === -1) {\n        throw new RuntimeError(`Could not find a row with the given condition`);\n      }\n\n      return Row.fromNamedCells(\n        table.columns.map((column) => column.atIndex(rowIndex)),\n        table.columnNames\n      );\n    },\n  },\n\n  concatenate: {\n    argCount: 2,\n    functor: ([tab1, tab2]) =>\n      Type.combine(tab1.isTable(), tab2.isTable()).mapType(() => {\n        if (\n          !dequal(tab1.columnNames, tab2.columnNames) ||\n          !dequal(tab1.columnTypes, tab2.columnTypes)\n        ) {\n          return t.impossible('Incompatible tables');\n        } else {\n          return tab1;\n        }\n      }),\n    fnValues: ([tab1, tab2]) => {\n      const { columns: cols1, columnNames } = getInstanceof(tab1, Table);\n      const { columns: cols2 } = getInstanceof(tab2, Table);\n\n      return Table.fromNamedColumns(\n        zip(cols1, cols2).map(([c1, c2]) => new ConcatenatedColumn(c1, c2)),\n        getDefined(columnNames)\n      );\n    },\n  },\n\n  sortby: {\n    argCount: 2,\n    argCardinalities: [1, 2],\n    functor: ([table, column]) =>\n      Type.combine(column.isColumn().withAtParentIndex(), table.isTable()),\n    fnValues: ([_table, _column]) => {\n      const column = getColumnLike(_column);\n      const sortMap = ValueTransforms.sortMap(column);\n      const table = getInstanceof(_table, Table);\n      return table.mapColumns((col) => ValueTransforms.applyMap(col, sortMap));\n    },\n  },\n\n  filter: {\n    argCount: 2,\n    functorNoAutomap: ([table, column]) =>\n      Type.combine(\n        column.isColumn().reduced().isScalar('boolean'),\n        table.isTable(),\n        produce((table) => {\n          table.indexName = null;\n        })\n      ),\n    fnValuesNoAutomap: ([_table, _column]) => {\n      const filterMap = getColumnLike(_column).getData() as boolean[];\n      const table = getInstanceof(_table, Table);\n      return table.mapColumns((col) =>\n        ValueTransforms.applyFilterMap(col, filterMap)\n      );\n    },\n  },\n  grab: {\n    aliasFor: 'filter',\n  },\n};\n","import { BuiltinSpec } from '../interfaces';\nimport { build as t, InferError } from '../../type';\n\nexport const tableGroupingOperators: { [fname: string]: BuiltinSpec } = {\n  splitby: {\n    argCount: 2,\n    hidden: true,\n    functor: () => t.impossible(InferError.retiredFeature('splitby')),\n    fnValuesNoAutomap: () => {\n      throw new Error('unreachable');\n    },\n  },\n};\n","import DeciNumber from '@decipad/number';\nimport { getInstanceof } from '../../utils';\nimport { DateValue, Range, fromJS, compare } from '../../value';\nimport { Type, build as t } from '../../type';\nimport { overloadBuiltin } from '../overloadBuiltin';\nimport { BuiltinSpec } from '../interfaces';\n\nexport const miscOperators: Record<string, BuiltinSpec> = {\n  if: {\n    argCount: 3,\n    fnValues: ([cond, then, otherwise]) => (cond.getData() ? then : otherwise),\n    functor: ([cond, then, otherwise]) =>\n      Type.combine(cond.isScalar('boolean'), otherwise.sameAs(then)),\n  },\n\n  // Range stuff\n  contains: overloadBuiltin('contains', 2, [\n    {\n      argTypes: ['range', 'number'],\n      fnValues: ([a, b]) => {\n        const [aStart, aEnd] = a.getData() as DeciNumber[];\n        const bNumber = b.getData() as DeciNumber;\n        return fromJS(\n          compare(bNumber, aStart) >= 0 && compare(bNumber, aEnd) <= 0\n        );\n      },\n      functor: ([a, b]): Type =>\n        Type.combine(\n          a.isRange(),\n          b.isScalar('number').sameAs(a.getRangeOf()),\n          t.boolean()\n        ),\n    },\n    {\n      argTypes: ['date', 'date'],\n      fnValues: ([a, b]) => {\n        const aVal = getInstanceof(a, DateValue);\n        const bVal = getInstanceof(b, DateValue);\n        return fromJS(\n          aVal.getData() <= bVal.getData() && aVal.getEnd() >= bVal.getEnd()\n        );\n      },\n      functor: ([a, b]) => Type.combine(a.isDate(), b.isDate(), t.boolean()),\n    },\n    {\n      argTypes: ['range', 'date'],\n      fnValues: ([rangeV, dateD]) => {\n        const { start, end } = getInstanceof(rangeV, Range);\n        const startDate = getInstanceof(start, DateValue);\n        const endDate = getInstanceof(end, DateValue);\n        const date = getInstanceof(dateD, DateValue);\n\n        return fromJS(\n          startDate.getData() <= date.getData() &&\n            endDate.getData() >= date.getEnd()\n        );\n      },\n      functor: ([range, date]) =>\n        Type.combine(range.isRange(), date.isDate(), t.boolean()),\n    },\n  ]),\n};\n","import { BuiltinSpec } from '../interfaces';\nimport { RuntimeError } from '../../value';\n\nexport const contractOperators: Record<string, BuiltinSpec> = {\n  assert: {\n    argCount: 1,\n    fn: ([preconditionNotMet]) => {\n      if (!preconditionNotMet) {\n        throw new RuntimeError('User defined pre-condition was not met');\n      }\n      return true;\n    },\n    functionSignature: 'boolean -> boolean',\n  },\n};\n","import { N } from '@decipad/number';\nimport { once } from 'ramda';\nimport { Type, build as t } from '../../type';\nimport { BuiltinSpec } from '../interfaces';\n\nconst radian = once(() =>\n  t.number([\n    {\n      unit: 'radian',\n      exp: N(1),\n      multiplier: N(1),\n      known: true,\n    },\n  ])\n);\n\nconst angleOpFunctor = ([n]: Type[]) =>\n  n\n    .isScalar('number')\n    .sameAs(radian())\n    .mapType(() => t.number());\n\nconst arcFunctor = ([n]: Type[]) =>\n  n.isScalar('number').mapType(() => radian());\n\nexport const trignometricOperators: Record<string, BuiltinSpec> = {\n  sin: {\n    argCount: 1,\n    autoConvertArgs: true,\n    fn: ([n]) => Math.sin(N(n).valueOf()),\n    functor: angleOpFunctor,\n  },\n  asin: {\n    argCount: 1,\n    autoConvertArgs: true,\n    fn: ([n]) => Math.asin(N(n).valueOf()),\n    functor: arcFunctor,\n  },\n  cos: {\n    argCount: 1,\n    autoConvertArgs: true,\n    fn: ([n]) => Math.cos(N(n).valueOf()),\n    functor: angleOpFunctor,\n  },\n  acos: {\n    argCount: 1,\n    autoConvertArgs: true,\n    fn: ([n]) => Math.acos(N(n).valueOf()),\n    functor: arcFunctor,\n  },\n  tan: {\n    argCount: 1,\n    autoConvertArgs: true,\n    fn: ([n]) => Math.tan(N(n).valueOf()),\n    functor: angleOpFunctor,\n  },\n  atan: {\n    argCount: 1,\n    autoConvertArgs: true,\n    fn: ([n]) => Math.atan(N(n).valueOf()),\n    functor: arcFunctor,\n  },\n};\n","import { BuiltinSpec } from '../interfaces';\nimport { mathOperators } from './math-operators';\nimport { comparisonOperators } from './comparison-operators';\nimport { equalityOperators } from './equality-operators';\nimport { booleanOperators } from './boolean-operators';\nimport { listOperators } from './list-operators';\nimport { reducerOperators } from './reducer-operators';\nimport { tableOperators } from './table-operators';\nimport { tableGroupingOperators } from './table-grouping-operators';\nimport { miscOperators } from './misc-operators';\nimport { contractOperators } from './contract-operators';\nimport { trignometricOperators } from './trignometric-operators';\n\nexport const operators: { [fname: string]: BuiltinSpec } = {\n  ...mathOperators,\n  ...comparisonOperators,\n  ...equalityOperators,\n  ...booleanOperators,\n  ...listOperators,\n  ...reducerOperators,\n  ...tableOperators,\n  ...tableGroupingOperators,\n  ...miscOperators,\n  ...contractOperators,\n  ...trignometricOperators,\n};\n","import { BuiltinSpec } from '../interfaces';\n\nexport const booleanOperators: Record<string, BuiltinSpec> = {\n  '!': {\n    argCount: 1,\n    fn: ([a]) => !a,\n    functionSignature: 'boolean -> boolean',\n    operatorKind: 'prefix',\n  },\n  not: {\n    aliasFor: '!',\n  },\n  '&&': {\n    argCount: 2,\n    fn: ([a, b]) => a && b,\n    functionSignature: 'boolean, boolean -> boolean',\n    operatorKind: 'infix',\n  },\n  and: {\n    aliasFor: '&&',\n  },\n  '||': {\n    argCount: 2,\n    fn: ([a, b]) => a || b,\n    functionSignature: 'boolean, boolean -> boolean',\n    operatorKind: 'infix',\n  },\n  or: {\n    aliasFor: '||',\n  },\n};\n","import { BuiltinSpec } from '../interfaces';\nimport { operators } from './operators';\n\nexport { operators };\n\nfunction normalizeOpName(name: string): string {\n  return name.toLowerCase();\n}\n\nexport function getOperatorByName(name: string): BuiltinSpec | null {\n  const op = operators[normalizeOpName(name)];\n  if (op?.aliasFor) {\n    return getOperatorByName(op.aliasFor);\n  } else {\n    return op ?? null;\n  }\n}\n","import { getOnly } from '@decipad/utils';\nimport type { AST, Context } from '..';\nimport { Type, build as t, InferError } from '../type';\nimport { automapTypes, automapTypesForReducer } from '../dimtools';\nimport { getOperatorByName } from './operators';\nimport type { BuiltinSpec, Functor } from './interfaces';\nimport { parseFunctor } from './parseFunctor';\n\nexport const callBuiltinFunctor = (\n  context: Context,\n  opName: string,\n  givenArguments: Type[],\n  givenValues?: AST.Expression[]\n): Type => {\n  const error = givenArguments.find(typeHasError);\n  if (error) {\n    return error;\n  }\n\n  const op = getOperatorByName(opName);\n\n  if (op == null) {\n    return t.impossible(InferError.missingFormula(opName));\n  } else {\n    let { argCount: argCounts = [] } = op;\n    if (typeof argCounts === 'number') {\n      argCounts = [argCounts];\n    }\n    if (argCounts.indexOf(givenArguments.length) < 0) {\n      return t.impossible(\n        `The function ${opName} requires ${op.argCount} parameters and ${givenArguments.length} parameters were entered`\n      );\n    }\n\n    if (op.isReducer) {\n      const lowerDimFunctor = getFunctor(op);\n      const onlyArg = getOnly(\n        givenArguments,\n        'panic: isReducer used in a function with multiple arguments'\n      );\n      return automapTypesForReducer(onlyArg, (types: Type[]) =>\n        lowerDimFunctor(types, givenValues, context)\n      );\n    }\n\n    if (op.functorNoAutomap != null) {\n      return op.functorNoAutomap(givenArguments, givenValues, context);\n    }\n\n    return automapTypes(\n      givenArguments,\n      ([type, ...rest]) =>\n        Type.combine(type, ...rest).mapType(() =>\n          getFunctor(op)([type, ...rest], givenValues, context)\n        ),\n      op.argCardinalities\n    );\n  }\n};\n\nfunction typeHasError(t: Type) {\n  return t.errorCause != null;\n}\n\nconst getFunctor = (op: BuiltinSpec): Functor => {\n  if (op.functor) {\n    return op.functor;\n  }\n\n  if (op.functionSignature) {\n    return parseFunctor(op.functionSignature);\n  }\n\n  throw new Error(`must either specify a functor or a functionSignature`);\n};\n","import DeciNumber from '@decipad/number';\nimport { getOnly } from '@decipad/utils';\nimport { getOperatorByName } from './operators';\nimport { automapValues, automapValuesForReducer } from '../dimtools';\n\nimport { Value, fromJS } from '../value';\nimport { getDefined } from '../utils';\nimport { Realm, RuntimeError } from '../interpreter';\nimport { convertToMultiplierUnit, Type } from '../type';\nimport { autoconvertResult, autoconvertArguments } from '../units';\nimport { BuiltinSpec } from './interfaces';\n\nfunction shouldAutoconvert(types: Type[]): boolean {\n  if (types.length === 1) {\n    return false;\n  }\n  if (types.length === 2) {\n    const [typeA, typeB] = types.map((t) => t.reducedToLowest());\n    if ((typeA.unit && !typeB.unit) || (typeB.unit && !typeA.unit)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction callBuiltinAfterAutoconvert(\n  realm: Realm,\n  funcName: string,\n  builtin: BuiltinSpec,\n  args: Value[],\n  argTypes: Type[]\n): Value {\n  if (builtin.fnValuesNoAutomap) {\n    return builtin.fnValuesNoAutomap(args, argTypes, realm);\n  }\n\n  const lowerDimFn = (argsLowerDims: Value[], typesLowerDims: Type[]) => {\n    if (builtin.fn != null) {\n      const argData = argsLowerDims.map((a) => getDefined(a.getData()));\n      try {\n        return fromJS(builtin.fn(argData, typesLowerDims));\n      } catch (err) {\n        if (err instanceof RuntimeError) {\n          throw err;\n        }\n        console.error(err);\n        throw new TypeError(\n          `Error calling builtin ${funcName}: ${(err as Error).message}`\n        );\n      }\n    } else if (builtin.fnValues != null) {\n      return builtin.fnValues(argsLowerDims as Value[], typesLowerDims, realm);\n    } else {\n      /* istanbul ignore next */\n      throw new Error('unreachable');\n    }\n  };\n\n  if (builtin.isReducer) {\n    const onlyArgType = getOnly(\n      argTypes,\n      'panic: isReducer used in a function with multiple arguments'\n    );\n    const onlyArg = getOnly(\n      args,\n      'panic: isReducer used in a function with multiple arguments'\n    );\n\n    return automapValuesForReducer(onlyArgType, onlyArg, lowerDimFn);\n  }\n\n  return automapValues(argTypes, args, lowerDimFn, builtin.argCardinalities);\n}\n\nconst stages = ['autoConvertArguments', 'builtin', 'autoConvertResult'];\n\nexport function callBuiltin(\n  realm: Realm,\n  funcName: string,\n  argsBeforeConvert: Value[],\n  argTypes: Type[],\n  returnType: Type\n): Value {\n  const op = getDefined(\n    getOperatorByName(funcName),\n    `panic: builtin not found: ${funcName}`\n  );\n\n  let stage = 0;\n  try {\n    const autoConvert =\n      !!op.autoConvertArgs ||\n      (!op.noAutoconvert && shouldAutoconvert(argTypes));\n    let args = autoConvert\n      ? autoconvertArguments(argsBeforeConvert, argTypes)\n      : argsBeforeConvert;\n\n    if (op.absoluteNumberInput && !returnType.unit) {\n      args = args.map((value, index) => {\n        const type = argTypes[index];\n        if (type.type === 'number') {\n          const data = value.getData();\n          if (data instanceof DeciNumber) {\n            return fromJS(convertToMultiplierUnit(data, type.unit));\n          }\n        }\n        return value;\n      });\n    }\n\n    stage += 1;\n    const resultBeforeConvertingBack = callBuiltinAfterAutoconvert(\n      realm,\n      funcName,\n      op,\n      args,\n      argTypes\n    );\n    stage += 1;\n    return autoConvert\n      ? autoconvertResult(resultBeforeConvertingBack, returnType)\n      : resultBeforeConvertingBack;\n  } catch (err) {\n    if (process.env.NODE_ENV !== 'test' && typeof jest === 'undefined') {\n      console.error(`Error at stage ${stages[stage]}`, err);\n    }\n    throw new RuntimeError((err as Error)?.message || 'Unknown error');\n  }\n}\n","import { N } from '@decipad/number';\nimport { once } from 'ramda';\nimport { fromJS, Value } from '../value';\nimport { Type, build as t } from '../type';\n\nexport interface Constant {\n  type: Type;\n  value: Value;\n}\n\nconst builtinConstants = once((): Record<string, Constant> => {\n  const pi = {\n    type: t.number(),\n    value: fromJS(N(3141592653589793, 10 ** 15)),\n  };\n  return {\n    e: {\n      type: t.number(),\n      value: fromJS(N(2718281828459045, 10 ** 15)),\n    },\n    pi,\n    : pi,\n  };\n});\n\nexport const getConstantByName = (name: string): undefined | Constant => {\n  return builtinConstants()[name.toLowerCase()];\n};\n","import moo from 'moo';\nimport { getDefined } from '@decipad/utils';\n\nconst parenTypes = ['Paren', 'SquareBracket', 'CurlyBracket', 'PartialIf'];\n\ntype ParenType = typeof parenTypes[number];\n\nconst openersToTypes: Record<string, ParenType> = {\n  leftParen: 'Paren',\n  leftSquareBracket: 'SquareBracket',\n  leftCurlyBracket: 'CurlyBracket',\n  'if keyword': 'PartialIf',\n};\n\nconst closersToTypes: Record<string, ParenType> = {\n  rightParen: 'Paren',\n  rightSquareBracket: 'SquareBracket',\n  rightCurlyBracket: 'CurlyBracket',\n  'else keyword': 'PartialIf',\n};\n\nexport type BracketError =\n  | { type: 'never-opened'; close: moo.Token }\n  | { type: 'mismatched-brackets'; open: moo.Token; close: moo.Token }\n  | { type: 'never-closed'; open: moo.Token };\n\n/**\n * Keeps track of open ([{}])\n * Helps implement https://xkcd.com/859/\n */\nexport class BracketCounter {\n  openStack: moo.Token[] = [];\n  validationError?: BracketError;\n  get isValid() {\n    return !this.validationError;\n  }\n  feed(tok?: moo.Token) {\n    if (!tok?.type || !this.isValid) return;\n\n    const opener = openersToTypes[tok.type];\n    const closer = closersToTypes[tok.type];\n\n    if (opener) this.openStack.push(tok);\n    if (closer) {\n      const previouslyOpened = this.openStack.pop();\n      const previouslyOpenedType = openersToTypes[previouslyOpened?.type ?? ''];\n\n      if (!previouslyOpened) {\n        this.validationError = {\n          type: 'never-opened',\n          close: tok,\n        };\n      } else if (previouslyOpenedType !== closer) {\n        this.validationError = {\n          type: 'mismatched-brackets',\n          open: previouslyOpened,\n          close: tok,\n        };\n      }\n    }\n  }\n  noBrackets() {\n    return !this.isValid || this.openStack.length === 0;\n  }\n  finalize() {\n    if (this.isValid && this.openStack.length) {\n      this.validationError = {\n        type: 'never-closed',\n        open: getDefined(this.openStack.pop()),\n      };\n    }\n  }\n}\n\ninterface SeparateStatementArgs {\n  tok: moo.Token;\n  prevTok: moo.Token | null | undefined;\n  nextTok: moo.Token | null | undefined;\n  openCounter: BracketCounter;\n}\n\nexport const doSeparateStatement = ({\n  tok,\n  prevTok,\n  nextTok,\n  openCounter,\n}: SeparateStatementArgs) => {\n  const { type, text } = tok;\n\n  if (type === 'ws' && text.includes('\\n') && openCounter.noBrackets()) {\n    // allow \"then\" and \"else\" to head the line for breaking up if exprs\n    // And allow to break line after \"=>\" denoting function\n    if (['then keyword', 'else keyword'].includes(nextTok?.type ?? '')) {\n      return false;\n    }\n    return prevTok?.type !== 'arrow';\n  }\n\n  return false;\n};\n","import moo, { error, Token } from 'moo';\nimport { BracketCounter, doSeparateStatement } from './containmentCounting';\n\nexport type { Token };\nexport { BracketCounter };\n\nconst keywordStrings = [\n  'if',\n  'then',\n  'else',\n  'true',\n  'false',\n  'and',\n  'in',\n  'is',\n  'by',\n  'date',\n  'through',\n  'fetch',\n  'categories',\n  'mod',\n  'modulo',\n];\nconst keywords = moo.keywords(\n  Object.fromEntries(keywordStrings.map((kw) => [`${kw} keyword`, kw]))\n);\n\n/** HACK: Our toolchain doesn't support regex expressions with the /u flag. Using a\n * function adds some indirection to avoid failing the build */\nconst regexHack = (text: string, flags = 'u') => {\n  return new RegExp(text, flags);\n};\nconst identifierRegExp = regexHack(\n  '[\\\\p{L}\\\\p{Sc}\\\\p{Emoji_Presentation}_][\\\\p{L}\\\\p{Nd}\\\\p{Sc}\\\\p{Emoji_Presentation}_]*'\n);\nconst currencies = ['r$', 'R$', '$', '', ''];\nexport const identifierRegExpGlobal = regexHack(\n  identifierRegExp.source,\n  `${identifierRegExp.flags}g`\n);\n\nexport const tokenRules = {\n  main: {\n    ws: { match: regexHack('[ \\\\t\\\\n\\\\v\\\\f]+'), lineBreaks: true },\n\n    // Punctuation\n    notEquals: '!=',\n    equals: '==',\n    lessThanOrEquals: '<=',\n    greaterThanOrEquals: '>=',\n    arrow: '=>',\n    twoStars: '**',\n    threeDots: '...',\n    threeDotsEllipsis: '',\n    twoDots: '..',\n\n    dot: '.',\n    bang: '!',\n    percent: '%',\n    permille: '',\n    permyriad: '',\n    leftParen: '(',\n    rightParen: ')',\n    leftSquareBracket: '[',\n    rightSquareBracket: ']',\n    leftCurlyBracket: '{',\n    rightCurlyBracket: '}',\n    // This is a RegExp because if we use '-', moo will place `\\-` (an invalid escape) into\n    // a RegExp, and then cause a SyntaxError\n    minus: regexHack('-'),\n    plus: '+',\n    times: '*',\n    caret: '^',\n    slash: '/',\n    lessThan: '<',\n    greaterThan: '>',\n    colon: ':',\n    comma: ',',\n    equalSign: '=',\n\n    andSign: '&&',\n    orSign: '||',\n\n    // Move into the \"date\" state\n    // https://www.npmjs.com/package/moo#states\n    beginDate: {\n      match: regexHack('date *\\\\('),\n      push: 'date',\n    },\n    numberWithScientificNotation: {\n      // This regular expression matches a numeric string in the following format:\n      //  [0-9]+ matches one or more digits from 0 to 9.\n      //  (?:[ _]*[0-9]+)* matches zero or more occurrences of an optional space or underscore followed by one or more digits from 0 to 9.\n      //  (?:\\.[0-9]+)? matches an optional decimal point followed by one or more digits from 0 to 9.\n      //  (?:e|E) matches the character \"e\" or \"E\".\n      //  \\-?[0-9]+ matches an optional minus sign followed by one or more digits from 0 to 9.\n      match: regexHack('[0-9]+(?:[ _]*[0-9]+)*(?:\\\\.[0-9]+)?(?:e|E)-?[0-9]+'),\n      value: (splitUp: string) => splitUp.replace(/[_ ]+/g, ''),\n    },\n    number: {\n      // This regular expression matches a numeric string in the following format:\n      //  [0-9]+ matches one or more digits from 0 to 9.\n      //  (?:[ _]*[0-9]+)* matches zero or more occurrences of an optional space or underscore followed by one or more digits from 0 to 9.\n      //  (?:\\.[0-9]+)? matches an optional decimal point followed by one or more digits from 0 to 9.\n      match: regexHack('[0-9]+(?:[ _]*[0-9]+)*(?:\\\\.[0-9]+)?'),\n      value: (splitUp: string) => splitUp.replace(/[_ ]+/g, ''),\n    },\n    currency: currencies,\n    identifier: {\n      match: identifierRegExp,\n      type: keywords,\n    },\n    string: {\n      // Adding control characters to comply with https://json.org\n      /* eslint-disable-next-line no-control-regex */\n      match: regexHack(\n        '\"(?:\\\\\\\\[\"bfnrt/\\\\\\\\]|\\\\\\\\u[a-fA-F0-9]{4}|[^\\n\"\\\\\\\\])*\"'\n      ),\n      value: (validJsonString: string) => JSON.parse(validJsonString),\n    },\n    // Moo crashes by default, but we can give it an error token to return us\n    error,\n  },\n  date: {\n    digits: regexHack('[0-9]+'),\n    punc: regexHack('[T.:/+-]'),\n    ws: regexHack('[ \\\\t]+'),\n    monthName: regexHack('[a-zA-Z]+'),\n    endDate: {\n      match: regexHack('\\\\)'),\n      pop: 1,\n    },\n    // See above. This needs to be passed into date mode as well\n    error,\n  },\n} as const;\n\nexport const STATEMENT_SEP_TOKEN_TYPE = 'statementSep';\n\nconst basicTokenizer = moo.states(tokenRules);\n\nexport interface ParensCountingTokenizer extends moo.Lexer {\n  peek: () => moo.Token | undefined;\n  prev: () => moo.Token | undefined;\n}\n/**\n * A tokenizer that keeps track of how many parens are open,\n * so that it knows when there's a new statement.\n *\n * Emits the special token type \"statementSep\" for this purpose\n */\nexport const tokenizer = (() => {\n  let openCounter = new BracketCounter();\n  let peeked: moo.Token | undefined;\n  let prev: moo.Token | undefined;\n\n  const getNextToken = () => {\n    if (peeked) {\n      const tok = peeked;\n      peeked = undefined;\n      return tok;\n    }\n    return basicTokenizer.next();\n  };\n\n  const extendedTokenizer: ParensCountingTokenizer = Object.assign(\n    Object.create(basicTokenizer),\n    {\n      next() {\n        const tok = getNextToken();\n        openCounter.feed(tok);\n\n        if (\n          tok &&\n          doSeparateStatement({\n            tok,\n            prevTok: this.prev(),\n            nextTok: this.peek(),\n            openCounter,\n          })\n        ) {\n          // Clear any negative parens\n          openCounter = new BracketCounter();\n\n          prev = Object.assign(Object.create(tok), {\n            type: STATEMENT_SEP_TOKEN_TYPE,\n          });\n        } else {\n          prev = tok;\n        }\n\n        return prev;\n      },\n      peek() {\n        // if peek() has been called already, don't call next() again\n        if (peeked) return peeked;\n\n        peeked = basicTokenizer.next();\n        return peeked;\n      },\n      prev() {\n        return prev;\n      },\n      reset(code: string, info?: moo.LexerState) {\n        openCounter = new BracketCounter();\n        basicTokenizer.reset(code, info);\n        peeked = undefined;\n        return this;\n      },\n    }\n  );\n\n  return extendedTokenizer;\n})();\n\nexport const tokenize = (source: string): Token[] =>\n  Array.from(tokenizer.reset(source));\n","// Generated automatically by nearley, version 2.20.1\n// http://github.com/Hardmath123/nearley\nfunction id(x) {\n  return x[0];\n}\n\n/* eslint-disable */\nimport { tokenizer } from '../tokenizer';\n\nconst initialReservedWords = new Set([\n  'in',\n  'as',\n  'to',\n  'of',\n  'by',\n  'contains',\n  'where',\n  'given',\n  'per',\n  'set',\n  'categories',\n  'true',\n  'false',\n  'for',\n  'if',\n  'then',\n  'else',\n  'through',\n  'select',\n  'range',\n  'date',\n  'and',\n  'not',\n  'or',\n  'with',\n  'when',\n  'over',\n  'smooth',\n]);\n\nconst monthStrings = new Set([\n  'Jan',\n  'January',\n  'Feb',\n  'February',\n  'Mar',\n  'March',\n  'Apr',\n  'April',\n  'May',\n  'Jun',\n  'June',\n  'Jul',\n  'July',\n  'Aug',\n  'August',\n  'Sep',\n  'September',\n  'Oct',\n  'October',\n  'Nov',\n  'November',\n  'Dec',\n  'December',\n]);\n\n// fixme: this is repeated in units.ts\n// fixme: lots of other reserved words i think\nconst timeUnitStrings = new Set([\n  'millennium',\n  'millenniums',\n  'millennia',\n  'century',\n  'centuries',\n  'decade',\n  'decades',\n  'year',\n  'years',\n  'quarter',\n  'quarters',\n  'month',\n  'months',\n  'weeks',\n  'week',\n  'day',\n  'days',\n  'hour',\n  'hours',\n  'minute',\n  'minutes',\n  'second',\n  'seconds',\n  'millisecond',\n  'milliseconds',\n]);\n\nconst reservedWords = new Set(initialReservedWords);\n\nfunction isReservedWord(str) {\n  return reservedWords.has(str);\n}\n\nconst _getStart = (tokOrNode) =>\n  tokOrNode.offset != null ? tokOrNode.offset : tokOrNode.start;\n\nconst _getEnd = (tokOrNode) =>\n  tokOrNode.offset != null\n    ? tokOrNode.offset + tokOrNode.text.length - 1\n    : tokOrNode.end;\n\nconst noEndToken = Symbol('no end token was passed');\nfunction addLoc(node, start, end = start) {\n  node.start = _getStart(start);\n  node.end = _getEnd(end);\n\n  if (typeof node.start !== 'number' || typeof node.end !== 'number') {\n    throw new Error(\n      'Bad start or end at ' +\n        JSON.stringify(node, null, 2) +\n        '\\n\\n-- given: ' +\n        JSON.stringify({ start, end }, null, 2) +\n        ''\n    );\n  } else {\n    return node;\n  }\n}\n\nfunction getLocationFromArray(locArray) {\n  // Most of the time it's really easy to find\n  const shortCircuitStart = locArray[0] && _getStart(locArray[0]);\n  const shortCircuitEnd =\n    locArray[locArray.length - 1] && _getEnd(locArray[locArray.length - 1]);\n  if (shortCircuitEnd != null && shortCircuitStart != null) {\n    return [shortCircuitStart, shortCircuitEnd];\n  }\n\n  let start = null;\n  let end = null;\n\n  const foundToken = (tokOrNode) => {\n    if (tokOrNode != null) {\n      const newStart = _getStart(tokOrNode);\n      const newEnd = _getEnd(tokOrNode);\n\n      if (newStart != null && newEnd != null) {\n        if (start == null) {\n          start = newStart;\n        }\n        end = newEnd;\n      }\n    }\n  };\n\n  (function recurse(array) {\n    if (array == null) return;\n\n    if (Array.isArray(array)) {\n      for (const item of array) {\n        recurse(item);\n      }\n    } else {\n      foundToken(array);\n    }\n  })(locArray);\n\n  return [start, end];\n}\n\nfunction addArrayLoc(node, locArray) {\n  const [start, end] = getLocationFromArray(locArray);\n  node.start = start;\n  node.end = end;\n  if (typeof node.start !== 'number' || typeof node.end !== 'number') {\n    throw new Error(\n      'Bad start or end at ' +\n        JSON.stringify(node, null, 2) +\n        '\\n\\n-- given: ' +\n        JSON.stringify({ start, end }, null, 2) +\n        ''\n    );\n  } else {\n    return node;\n  }\n}\n\nimport DeciNumber, { N } from '@decipad/number';\n\nfunction makeNumber(parentNode, n, numberFormat = undefined) {\n  const fraction = N(n);\n\n  const node = {\n    type: 'literal',\n    args: numberFormat\n      ? ['number', fraction, numberFormat]\n      : ['number', fraction],\n  };\n  if (Array.isArray(parentNode)) {\n    return addArrayLoc(node, parentNode);\n  }\n  return addLoc(node, parentNode);\n}\n\nconst returnMonth = (month) => () => ({ month });\n\nconst joinDateParts = (dateParts) => {\n  let parts = dateParts.args;\n\n  if (dateParts.nextDateInner) {\n    parts = parts.concat(joinDateParts(dateParts.nextDateInner));\n  }\n\n  // Timezone is last, always\n  if (dateParts.timezone) {\n    parts = parts.concat(dateParts.timezone);\n  }\n\n  return parts;\n};\n\nconst makeDateFragmentReader =\n  (key, len, min, max) =>\n  ([{ text }], _l, reject) => {\n    try {\n      const number = BigInt(text);\n      if (text.length !== len || number < min || number > max) {\n        return reject;\n      } else {\n        return { [key]: number };\n      }\n    } catch (err) {\n      return reject;\n    }\n  };\n\nconst implicitMultHandler = (d, _l, reject) => {\n  const left = d[0];\n  const right = d[2] || d[1];\n\n  // disambiguate things like `2 - 1` <- this is not `2 * (- 1)`!\n  if (right.type === 'function-call') {\n    const funcRef = right.args[0];\n    if (funcRef.type === 'funcref') {\n      const funcName = funcRef.args[0];\n      if (funcName === 'unary-') {\n        return reject;\n      }\n    }\n  }\n\n  return addArrayLoc(\n    {\n      type: 'function-call',\n      args: [\n        addArrayLoc(\n          {\n            type: 'funcref',\n            args: ['implicit*'],\n          },\n          d\n        ),\n        addArrayLoc(\n          {\n            type: 'argument-list',\n            args: [left, right],\n          },\n          d\n        ),\n      ],\n    },\n    d\n  );\n};\n\nconst unaryMinusHandler = (d) => {\n  const expr = d[2];\n  return addArrayLoc(\n    {\n      type: 'function-call',\n      args: [\n        addLoc(\n          {\n            type: 'funcref',\n            args: ['unary-'],\n          },\n          d[0]\n        ),\n        addLoc(\n          {\n            type: 'argument-list',\n            args: [d[2]],\n          },\n          d[2]\n        ),\n      ],\n    },\n    d\n  );\n};\n\nconst powHandler = (d, _l, reject) => {\n  const left = d[0];\n  const right = d[4];\n\n  // disambiguate things like `2 - 1` <- this is not `2 * (- 1)`!\n  if (left.type === 'function-call') {\n    const funcRef = left.args[0];\n    if (funcRef.type === 'funcref') {\n      const funcName = funcRef.args[0];\n      if (funcName === 'unary-') {\n        return reject;\n      }\n    }\n  }\n  return basicBinop(d);\n};\n\nfunction basicBinop([left, _spc, op, _spc2, right]) {\n  return addLoc(\n    {\n      type: 'function-call',\n      args: [\n        addLoc({ type: 'funcref', args: [op.name] }, op),\n        addLoc(\n          {\n            type: 'argument-list',\n            args: [left, right],\n          },\n          left,\n          right\n        ),\n      ],\n    },\n    left,\n    right\n  );\n}\n\nfunction simpleOperator(d) {\n  const token = d[0][0];\n  return addLoc({ name: token.value }, token);\n}\nlet Lexer = tokenizer;\nlet ParserRules = [\n  {\n    name: '_$ebnf$1',\n    symbols: [tokenizer.has('ws') ? { type: 'ws' } : ws],\n    postprocess: id,\n  },\n  {\n    name: '_$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  { name: '_', symbols: ['_$ebnf$1'], postprocess: id },\n  {\n    name: '__',\n    symbols: [tokenizer.has('ws') ? { type: 'ws' } : ws],\n    postprocess: id,\n  },\n  {\n    name: '__n',\n    symbols: [tokenizer.has('ws') ? { type: 'ws' } : ws],\n    postprocess: (d, _l, reject) => {\n      if (!d[0].value.includes('\\n')) {\n        return reject;\n      } else {\n        return d[0];\n      }\n    },\n  },\n  {\n    name: 'assign',\n    symbols: ['assignTarget', 'equalSign', 'expression'],\n    postprocess: (d) =>\n      addArrayLoc(\n        {\n          type: 'assign',\n          args: [d[0], d[2]],\n        },\n        d\n      ),\n  },\n  {\n    name: 'assignTarget',\n    symbols: ['identifier'],\n    postprocess: (d) => {\n      return addLoc(\n        {\n          type: 'def',\n          args: [d[0].name],\n        },\n        d[0]\n      );\n    },\n  },\n  {\n    name: 'columnAssign',\n    symbols: [\n      'identifier',\n      '_',\n      { literal: '.' },\n      '_',\n      'identifier',\n      'equalSign',\n      'expression',\n    ],\n    postprocess: (d) => {\n      const table = addLoc(\n        {\n          type: 'tablepartialdef',\n          args: [d[0].name],\n        },\n        d[0]\n      );\n      const column = addLoc(\n        {\n          type: 'coldef',\n          args: [d[4].name],\n        },\n        d[4]\n      );\n\n      return addArrayLoc(\n        {\n          type: 'table-column-assign',\n          args: [table, column, d[6]],\n        },\n        d\n      );\n    },\n  },\n  {\n    name: 'categories',\n    symbols: [\n      'identifier',\n      'equalSign',\n      { literal: 'categories' },\n      '_',\n      'expression',\n    ],\n    postprocess: (d) => {\n      return addArrayLoc(\n        {\n          type: 'categories',\n          args: [\n            addLoc(\n              {\n                type: 'catdef',\n                args: [d[0].name],\n              },\n              d[0]\n            ),\n            d[4],\n          ],\n        },\n        d\n      );\n    },\n  },\n  {\n    name: 'matrixMatchers$ebnf$1',\n    symbols: [{ literal: ',' }],\n    postprocess: id,\n  },\n  {\n    name: 'matrixMatchers$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'matrixMatchers',\n    symbols: [\n      { literal: '[' },\n      '_',\n      'matrixMatchersInner',\n      '_',\n      'matrixMatchers$ebnf$1',\n      '_',\n      { literal: ']' },\n    ],\n    postprocess: (d) => {\n      return addArrayLoc(\n        {\n          type: 'matrix-matchers',\n          args: [...d[2]],\n        },\n        d\n      );\n    },\n  },\n  {\n    name: 'matrixMatchersInner',\n    symbols: ['matcherExp'],\n    postprocess: (d) => [d[0]],\n  },\n  {\n    name: 'matrixMatchersInner$subexpression$1',\n    symbols: ['_', { literal: ',' }, '_'],\n  },\n  {\n    name: 'matrixMatchersInner',\n    symbols: [\n      'matrixMatchersInner',\n      'matrixMatchersInner$subexpression$1',\n      'matcherExp',\n    ],\n    postprocess: ([accum, _, exp]) => [...accum, exp],\n  },\n  {\n    name: 'matrixAssign',\n    symbols: ['assignTarget', '_', 'matrixMatchers', 'equalSign', 'expression'],\n    postprocess: (d) => {\n      return addArrayLoc(\n        {\n          type: 'matrix-assign',\n          args: [d[0], d[2], d[4]],\n        },\n        d\n      );\n    },\n  },\n  {\n    name: 'matrixRef',\n    symbols: ['ref', 'matrixMatchers'],\n    postprocess: (d) => {\n      return addArrayLoc(\n        {\n          type: 'matrix-ref',\n          args: [d[0], d[1]],\n        },\n        d\n      );\n    },\n  },\n  { name: 'matcherExp', symbols: ['ref'], postprocess: id },\n  {\n    name: 'matcherExp',\n    symbols: ['ref', '_', { literal: '==' }, '_', 'expression'],\n    postprocess: (d) => {\n      return addArrayLoc(\n        {\n          type: 'function-call',\n          args: [\n            addArrayLoc(\n              {\n                type: 'funcref',\n                args: ['=='],\n              },\n              d\n            ),\n            addArrayLoc(\n              {\n                type: 'argument-list',\n                args: [d[0], d[4]],\n              },\n              d\n            ),\n          ],\n        },\n        d\n      );\n    },\n  },\n  { name: 'literal', symbols: ['boolean'], postprocess: id },\n  { name: 'literal', symbols: ['string'], postprocess: id },\n  { name: 'literal', symbols: ['number'], postprocess: id },\n  { name: 'literal', symbols: ['percentage'], postprocess: id },\n  { name: 'literal', symbols: ['permille'], postprocess: id },\n  { name: 'literal', symbols: ['permyriad'], postprocess: id },\n  { name: 'literal', symbols: ['column'], postprocess: id },\n  { name: 'literal', symbols: ['date'], postprocess: id },\n  { name: 'literal', symbols: ['range'], postprocess: id },\n  { name: 'literal', symbols: ['sequence'], postprocess: id },\n  {\n    name: 'boolean',\n    symbols: [{ literal: 'true' }],\n    postprocess: (d) =>\n      addLoc(\n        {\n          type: 'literal',\n          args: ['boolean', true],\n        },\n        d[0]\n      ),\n  },\n  {\n    name: 'boolean',\n    symbols: [{ literal: 'false' }],\n    postprocess: (d) =>\n      addLoc(\n        {\n          type: 'literal',\n          args: ['boolean', false],\n        },\n        d[0]\n      ),\n  },\n  { name: 'number', symbols: ['negPosNumber'], postprocess: id },\n  {\n    name: 'number',\n    symbols: [\n      tokenizer.has('numberWithScientificNotation')\n        ? { type: 'numberWithScientificNotation' }\n        : numberWithScientificNotation,\n    ],\n    postprocess: (d) => {\n      const [significand, exponent] = d[0].text.split(/e|E/);\n      const n = N(significand).mul(N(10).pow(N(exponent)));\n      return makeNumber(d, n);\n    },\n  },\n  {\n    name: 'number',\n    symbols: [\n      { literal: '-' },\n      tokenizer.has('numberWithScientificNotation')\n        ? { type: 'numberWithScientificNotation' }\n        : numberWithScientificNotation,\n    ],\n    postprocess: (d) => {\n      const [significand, exponent] = d[1].text.split(/e|E/);\n      const n = N(significand)\n        .mul(N(10).pow(N(exponent)))\n        .neg();\n      return makeNumber(d, n);\n    },\n  },\n  {\n    name: 'number',\n    symbols: ['currency', 'negPosNumber'],\n    postprocess: (d) => {\n      const [currency, num] = d;\n      return addArrayLoc(\n        {\n          type: 'function-call',\n          args: [\n            addArrayLoc(\n              {\n                type: 'funcref',\n                args: ['implicit*'],\n              },\n              d\n            ),\n            addArrayLoc(\n              {\n                type: 'argument-list',\n                args: [currency, num],\n              },\n              d\n            ),\n          ],\n        },\n        d\n      );\n    },\n  },\n  {\n    name: 'number',\n    symbols: ['negPosNumber', 'currency'],\n    postprocess: (d) => {\n      const [num, currency] = d;\n      return addArrayLoc(\n        {\n          type: 'function-call',\n          args: [\n            addArrayLoc(\n              {\n                type: 'funcref',\n                args: ['implicit*'],\n              },\n              d\n            ),\n            addArrayLoc(\n              {\n                type: 'argument-list',\n                args: d,\n              },\n              d\n            ),\n          ],\n        },\n        d\n      );\n    },\n  },\n  {\n    name: 'negPosNumber',\n    symbols: ['unsignedNumber'],\n    postprocess: (d) => {\n      return makeNumber(d, d[0].n);\n    },\n  },\n  {\n    name: 'negPosNumber',\n    symbols: [{ literal: '-' }, 'unsignedNumber'],\n    postprocess: (d) => {\n      return makeNumber(d, N(d[1].n).neg());\n    },\n  },\n  {\n    name: 'percentage',\n    symbols: [{ literal: '-' }, 'decimal', '_', { literal: '%' }],\n    postprocess: (d) => {\n      const n = N(d[1].n.neg()).div(N(100));\n      return makeNumber(d, n, 'percentage');\n    },\n  },\n  {\n    name: 'percentage',\n    symbols: ['decimal', '_', { literal: '%' }],\n    postprocess: (d) => {\n      const n = N(d[0].n).div(N(100));\n      return makeNumber(d, n, 'percentage');\n    },\n  },\n  {\n    name: 'permille',\n    symbols: [{ literal: '-' }, 'decimal', { literal: '' }],\n    postprocess: (d) => {\n      return makeNumber(d, N(d[1].n.neg()).div(N(1000)));\n    },\n  },\n  {\n    name: 'permille',\n    symbols: ['decimal', { literal: '' }],\n    postprocess: (d) => {\n      return makeNumber(d, N(d[0].n).div(N(1000)));\n    },\n  },\n  {\n    name: 'permyriad',\n    symbols: [{ literal: '-' }, 'decimal', { literal: '' }],\n    postprocess: (d) => {\n      return makeNumber(d, N(d[1].n.neg()).div(N(10000)));\n    },\n  },\n  {\n    name: 'permyriad',\n    symbols: ['decimal', { literal: '' }],\n    postprocess: (d) => {\n      return makeNumber(d, N(d[0].n).div(N(10000)));\n    },\n  },\n  {\n    name: 'unsignedNumber',\n    symbols: [tokenizer.has('number') ? { type: 'number' } : number],\n    postprocess: ([number]) => {\n      return addLoc(\n        {\n          n: number.value,\n        },\n        number\n      );\n    },\n  },\n  {\n    name: 'int',\n    symbols: [tokenizer.has('number') ? { type: 'number' } : number],\n    postprocess: ([number], _l, reject) => {\n      return addLoc(\n        {\n          n: BigInt(number.value),\n        },\n        number\n      );\n    },\n  },\n  {\n    name: 'int',\n    symbols: [{ literal: '-' }, 'int'],\n    postprocess: (d) => {\n      const n = -d[1].n;\n      return addArrayLoc({ n }, d);\n    },\n  },\n  {\n    name: 'decimal',\n    symbols: [tokenizer.has('number') ? { type: 'number' } : number],\n    postprocess: ([number], _l, reject) => {\n      return addLoc(\n        {\n          n: N(number.value),\n        },\n        number\n      );\n    },\n  },\n  {\n    name: 'string',\n    symbols: [tokenizer.has('string') ? { type: 'string' } : string],\n    postprocess: ([string]) => {\n      return addLoc(\n        {\n          type: 'literal',\n          args: ['string', string.value],\n        },\n        string\n      );\n    },\n  },\n  {\n    name: 'date',\n    symbols: [\n      tokenizer.has('beginDate') ? { type: 'beginDate' } : beginDate,\n      '_',\n      'dateInner',\n      '_',\n      tokenizer.has('endDate') ? { type: 'endDate' } : endDate,\n    ],\n    postprocess: (d) => {\n      return addLoc(\n        {\n          type: 'date',\n          args: joinDateParts(d[2]),\n        },\n        d[0],\n        d[4]\n      );\n    },\n  },\n  { name: 'dateInner$ebnf$1', symbols: ['dateInnerMonth'], postprocess: id },\n  {\n    name: 'dateInner$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'dateInner',\n    symbols: ['dateYear', 'dateInner$ebnf$1'],\n    postprocess: (d) => ({\n      type: 'date',\n      args: ['year', d[0].year],\n      nextDateInner: d[1],\n    }),\n  },\n  { name: 'dateInnerMonth$ebnf$1', symbols: ['dateInnerDay'], postprocess: id },\n  {\n    name: 'dateInnerMonth$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'dateInnerMonth',\n    symbols: ['dateSeparator', 'dateMonth', 'dateInnerMonth$ebnf$1'],\n    postprocess: (d) => ({\n      type: 'date',\n      args: ['month', d[1].month],\n      nextDateInner: d[2],\n    }),\n  },\n  { name: 'dateInnerDay$ebnf$1', symbols: ['dateInnerHour'], postprocess: id },\n  {\n    name: 'dateInnerDay$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'dateInnerDay',\n    symbols: ['dateSeparator', 'dateDay', 'dateInnerDay$ebnf$1'],\n    postprocess: (d) => ({\n      type: 'date',\n      args: ['day', d[1].day],\n      nextDateInner: d[2],\n    }),\n  },\n  { name: 'dateInnerHour$subexpression$1', symbols: [{ literal: ' ' }] },\n  { name: 'dateInnerHour$subexpression$1', symbols: [{ literal: 'T' }] },\n  {\n    name: 'dateInnerHour$ebnf$1',\n    symbols: ['dateInnerMinute'],\n    postprocess: id,\n  },\n  {\n    name: 'dateInnerHour$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  { name: 'dateInnerHour$ebnf$2', symbols: ['dateTimeZone'], postprocess: id },\n  {\n    name: 'dateInnerHour$ebnf$2',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'dateInnerHour',\n    symbols: [\n      'dateInnerHour$subexpression$1',\n      'dateHour',\n      'dateInnerHour$ebnf$1',\n      'dateInnerHour$ebnf$2',\n    ],\n    postprocess: (d) => ({\n      type: 'date',\n      args: ['hour', d[1].hour],\n      nextDateInner: d[2],\n      timezone: d[3] ? ['timezone', d[3].timezone] : [],\n    }),\n  },\n  {\n    name: 'dateInnerMinute$ebnf$1',\n    symbols: ['dateInnerSecond'],\n    postprocess: id,\n  },\n  {\n    name: 'dateInnerMinute$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'dateInnerMinute',\n    symbols: [{ literal: ':' }, 'dateMinute', 'dateInnerMinute$ebnf$1'],\n    postprocess: (d) => ({\n      type: 'date',\n      args: ['minute', d[1].minute],\n      nextDateInner: d[2],\n    }),\n  },\n  {\n    name: 'dateInnerSecond$ebnf$1',\n    symbols: ['dateInnerMillisecond'],\n    postprocess: id,\n  },\n  {\n    name: 'dateInnerSecond$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'dateInnerSecond',\n    symbols: [{ literal: ':' }, 'dateSecond', 'dateInnerSecond$ebnf$1'],\n    postprocess: (d) => ({\n      type: 'date',\n      args: ['second', d[1].second],\n      nextDateInner: d[2],\n    }),\n  },\n  {\n    name: 'dateInnerMillisecond',\n    symbols: [{ literal: '.' }, 'dateMillisecond'],\n    postprocess: (d) => ({\n      type: 'date',\n      args: ['millisecond', d[1].millisecond],\n      nextDateInner: null,\n    }),\n  },\n  {\n    name: 'dateYear',\n    symbols: [tokenizer.has('digits') ? { type: 'digits' } : digits],\n    postprocess: makeDateFragmentReader('year', 4, 0, 9999),\n  },\n  {\n    name: 'dateMonth',\n    symbols: [tokenizer.has('digits') ? { type: 'digits' } : digits],\n    postprocess: makeDateFragmentReader('month', 2, 1, 12),\n  },\n  { name: 'dateMonth', symbols: ['literalMonth'], postprocess: id },\n  {\n    name: 'dateDay',\n    symbols: [tokenizer.has('digits') ? { type: 'digits' } : digits],\n    postprocess: makeDateFragmentReader('day', 2, 1, 31),\n  },\n  {\n    name: 'dateHour',\n    symbols: [tokenizer.has('digits') ? { type: 'digits' } : digits],\n    postprocess: makeDateFragmentReader('hour', 2, 0, 23),\n  },\n  {\n    name: 'dateMinute',\n    symbols: [tokenizer.has('digits') ? { type: 'digits' } : digits],\n    postprocess: makeDateFragmentReader('minute', 2, 0, 59),\n  },\n  {\n    name: 'dateSecond',\n    symbols: [tokenizer.has('digits') ? { type: 'digits' } : digits],\n    postprocess: makeDateFragmentReader('second', 2, 0, 59),\n  },\n  {\n    name: 'dateMillisecond',\n    symbols: [tokenizer.has('digits') ? { type: 'digits' } : digits],\n    postprocess: makeDateFragmentReader('millisecond', 3, 0, 999),\n  },\n  { name: 'literalMonth$subexpression$1', symbols: [{ literal: 'Jan' }] },\n  { name: 'literalMonth$subexpression$1', symbols: [{ literal: 'January' }] },\n  {\n    name: 'literalMonth',\n    symbols: ['literalMonth$subexpression$1'],\n    postprocess: returnMonth(1n),\n  },\n  { name: 'literalMonth$subexpression$2', symbols: [{ literal: 'Feb' }] },\n  { name: 'literalMonth$subexpression$2', symbols: [{ literal: 'February' }] },\n  {\n    name: 'literalMonth',\n    symbols: ['literalMonth$subexpression$2'],\n    postprocess: returnMonth(2n),\n  },\n  { name: 'literalMonth$subexpression$3', symbols: [{ literal: 'Mar' }] },\n  { name: 'literalMonth$subexpression$3', symbols: [{ literal: 'March' }] },\n  {\n    name: 'literalMonth',\n    symbols: ['literalMonth$subexpression$3'],\n    postprocess: returnMonth(3n),\n  },\n  { name: 'literalMonth$subexpression$4', symbols: [{ literal: 'Apr' }] },\n  { name: 'literalMonth$subexpression$4', symbols: [{ literal: 'April' }] },\n  {\n    name: 'literalMonth',\n    symbols: ['literalMonth$subexpression$4'],\n    postprocess: returnMonth(4n),\n  },\n  {\n    name: 'literalMonth',\n    symbols: [{ literal: 'May' }],\n    postprocess: returnMonth(5n),\n  },\n  { name: 'literalMonth$subexpression$5', symbols: [{ literal: 'Jun' }] },\n  { name: 'literalMonth$subexpression$5', symbols: [{ literal: 'June' }] },\n  {\n    name: 'literalMonth',\n    symbols: ['literalMonth$subexpression$5'],\n    postprocess: returnMonth(6n),\n  },\n  { name: 'literalMonth$subexpression$6', symbols: [{ literal: 'Jul' }] },\n  { name: 'literalMonth$subexpression$6', symbols: [{ literal: 'July' }] },\n  {\n    name: 'literalMonth',\n    symbols: ['literalMonth$subexpression$6'],\n    postprocess: returnMonth(7n),\n  },\n  { name: 'literalMonth$subexpression$7', symbols: [{ literal: 'Aug' }] },\n  { name: 'literalMonth$subexpression$7', symbols: [{ literal: 'August' }] },\n  {\n    name: 'literalMonth',\n    symbols: ['literalMonth$subexpression$7'],\n    postprocess: returnMonth(8n),\n  },\n  { name: 'literalMonth$subexpression$8', symbols: [{ literal: 'Sep' }] },\n  { name: 'literalMonth$subexpression$8', symbols: [{ literal: 'September' }] },\n  {\n    name: 'literalMonth',\n    symbols: ['literalMonth$subexpression$8'],\n    postprocess: returnMonth(9n),\n  },\n  { name: 'literalMonth$subexpression$9', symbols: [{ literal: 'Oct' }] },\n  { name: 'literalMonth$subexpression$9', symbols: [{ literal: 'October' }] },\n  {\n    name: 'literalMonth',\n    symbols: ['literalMonth$subexpression$9'],\n    postprocess: returnMonth(10n),\n  },\n  { name: 'literalMonth$subexpression$10', symbols: [{ literal: 'Nov' }] },\n  { name: 'literalMonth$subexpression$10', symbols: [{ literal: 'November' }] },\n  {\n    name: 'literalMonth',\n    symbols: ['literalMonth$subexpression$10'],\n    postprocess: returnMonth(11n),\n  },\n  { name: 'literalMonth$subexpression$11', symbols: [{ literal: 'Dec' }] },\n  { name: 'literalMonth$subexpression$11', symbols: [{ literal: 'December' }] },\n  {\n    name: 'literalMonth',\n    symbols: ['literalMonth$subexpression$11'],\n    postprocess: returnMonth(12n),\n  },\n  {\n    name: 'dateTimeZone',\n    symbols: [{ literal: 'Z' }],\n    postprocess: (d) => ({\n      timezone: {\n        hours: 0,\n        minutes: 0,\n      },\n    }),\n  },\n  { name: 'dateTimeZone$subexpression$1', symbols: [{ literal: '+' }] },\n  { name: 'dateTimeZone$subexpression$1', symbols: [{ literal: '-' }] },\n  {\n    name: 'dateTimeZone$ebnf$1$subexpression$1',\n    symbols: [\n      { literal: ':' },\n      tokenizer.has('digits') ? { type: 'digits' } : digits,\n    ],\n  },\n  {\n    name: 'dateTimeZone$ebnf$1',\n    symbols: ['dateTimeZone$ebnf$1$subexpression$1'],\n    postprocess: id,\n  },\n  {\n    name: 'dateTimeZone$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'dateTimeZone',\n    symbols: [\n      'dateTimeZone$subexpression$1',\n      tokenizer.has('digits') ? { type: 'digits' } : digits,\n      'dateTimeZone$ebnf$1',\n    ],\n    postprocess: ([sign, h, m]) => {\n      let hours = Number(h.value);\n      let minutes = m ? Number(m[1].value) : 0;\n\n      if (sign[0].value === '-') {\n        hours = -hours;\n        minutes = -minutes;\n      }\n\n      return { timezone: { hours, minutes } };\n    },\n  },\n  { name: 'dateSeparator$subexpression$1', symbols: [{ literal: '-' }] },\n  { name: 'dateSeparator$subexpression$1', symbols: [{ literal: '/' }] },\n  {\n    name: 'dateSeparator',\n    symbols: ['dateSeparator$subexpression$1'],\n    postprocess: id,\n  },\n  {\n    name: 'column',\n    symbols: [{ literal: '[' }, '_', { literal: ']' }],\n    postprocess: (d) =>\n      addLoc(\n        {\n          type: 'column',\n          args: [\n            addLoc(\n              {\n                type: 'column-items',\n                args: [],\n              },\n              d[1] ?? d[0]\n            ),\n          ],\n        },\n        d[0],\n        d[2]\n      ),\n  },\n  {\n    name: 'column',\n    symbols: [{ literal: '[' }, 'columnItems', { literal: ']' }],\n    postprocess: (d, _l, reject) => {\n      return addArrayLoc(\n        {\n          type: 'column',\n          args: [d[1]],\n        },\n        d\n      );\n    },\n  },\n  { name: 'columnItems$ebnf$1', symbols: [] },\n  {\n    name: 'columnItems$ebnf$1$subexpression$1',\n    symbols: ['_', { literal: ',' }, '_', 'expression'],\n  },\n  {\n    name: 'columnItems$ebnf$1',\n    symbols: ['columnItems$ebnf$1', 'columnItems$ebnf$1$subexpression$1'],\n    postprocess: function arrpush(d) {\n      return d[0].concat([d[1]]);\n    },\n  },\n  {\n    name: 'columnItems$ebnf$2$subexpression$1',\n    symbols: ['_', { literal: ',' }],\n  },\n  {\n    name: 'columnItems$ebnf$2',\n    symbols: ['columnItems$ebnf$2$subexpression$1'],\n    postprocess: id,\n  },\n  {\n    name: 'columnItems$ebnf$2',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'columnItems',\n    symbols: [\n      '_',\n      'expression',\n      'columnItems$ebnf$1',\n      'columnItems$ebnf$2',\n      '_',\n    ],\n    postprocess: (d, _l, reject) => {\n      return addArrayLoc(\n        {\n          type: 'column-items',\n          args: [d[1], ...d[2].map((listItem) => listItem[3])],\n        },\n        d\n      );\n    },\n  },\n  {\n    name: 'table',\n    symbols: [\n      'identifier',\n      'equalSign',\n      { literal: '{' },\n      'tableContents',\n      { literal: '}' },\n    ],\n    postprocess: (d) => {\n      const name = addLoc(\n        {\n          type: 'tabledef',\n          args: [d[0].name],\n        },\n        d[0]\n      );\n\n      return addArrayLoc(\n        {\n          type: 'table',\n          args: [name, ...d[3]],\n        },\n        d\n      );\n    },\n  },\n  { name: 'tableContents', symbols: ['_'], postprocess: (d) => [] },\n  { name: 'tableContents$ebnf$1', symbols: [] },\n  {\n    name: 'tableContents$ebnf$1$subexpression$1',\n    symbols: ['tableSep', 'tableItem'],\n  },\n  {\n    name: 'tableContents$ebnf$1',\n    symbols: ['tableContents$ebnf$1', 'tableContents$ebnf$1$subexpression$1'],\n    postprocess: function arrpush(d) {\n      return d[0].concat([d[1]]);\n    },\n  },\n  {\n    name: 'tableContents',\n    symbols: ['_', 'tableItem', 'tableContents$ebnf$1', '_'],\n    postprocess: ([_ws, first, rest]) => {\n      const coldefs = [first];\n\n      for (const [_sep, coldef] of rest ?? []) {\n        coldefs.push(coldef);\n      }\n\n      return coldefs;\n    },\n  },\n  {\n    name: 'tableItem',\n    symbols: ['identifier'],\n    postprocess: ([ref]) => {\n      return addLoc(\n        {\n          type: 'table-column',\n          args: [\n            addLoc({ type: 'coldef', args: [ref.name] }, ref),\n            addLoc({ type: 'ref', args: [ref.name] }, ref),\n          ],\n        },\n        ref\n      );\n    },\n  },\n  { name: 'tableItem$subexpression$1', symbols: [{ literal: '' }] },\n  { name: 'tableItem$subexpression$1', symbols: [{ literal: '...' }] },\n  {\n    name: 'tableItem',\n    symbols: ['tableItem$subexpression$1', '_', 'ref'],\n    postprocess: (d) => {\n      return addArrayLoc(\n        {\n          type: 'table-spread',\n          args: [d[2]],\n        },\n        d\n      );\n    },\n  },\n  {\n    name: 'tableItem',\n    symbols: ['identifier', 'equalSign', 'expression'],\n    postprocess: (d) => {\n      const ref = d[0];\n\n      const colDef = addLoc(\n        {\n          type: 'coldef',\n          args: [ref.name],\n        },\n        ref\n      );\n\n      return addArrayLoc(\n        {\n          type: 'table-column',\n          args: [colDef, d[2]],\n        },\n        d\n      );\n    },\n  },\n  { name: 'tableSep$subexpression$1', symbols: ['__n'] },\n  { name: 'tableSep$subexpression$1', symbols: ['_', { literal: ',' }, '_'] },\n  { name: 'tableSep', symbols: ['tableSep$subexpression$1'], postprocess: id },\n  {\n    name: 'tiered',\n    symbols: [\n      'tieredKeyword',\n      '_',\n      'expression',\n      '_',\n      { literal: '{' },\n      'tieredContents',\n      { literal: '}' },\n    ],\n    postprocess: (d) => {\n      return addArrayLoc(\n        {\n          type: 'tiered',\n          args: [d[2], ...d[5]],\n        },\n        d\n      );\n    },\n  },\n  { name: 'tieredKeyword', symbols: [{ literal: 'tiered' }] },\n  { name: 'tieredKeyword', symbols: [{ literal: 'tiers' }] },\n  { name: 'tieredKeyword', symbols: [{ literal: 'sliced' }] },\n  { name: 'tieredKeyword', symbols: [{ literal: 'slices' }], postprocess: id },\n  { name: 'tieredContents', symbols: ['_'], postprocess: (d) => [] },\n  { name: 'tieredContents$ebnf$1', symbols: [] },\n  {\n    name: 'tieredContents$ebnf$1$subexpression$1',\n    symbols: ['tieredSep', 'tieredDef'],\n  },\n  {\n    name: 'tieredContents$ebnf$1',\n    symbols: ['tieredContents$ebnf$1', 'tieredContents$ebnf$1$subexpression$1'],\n    postprocess: function arrpush(d) {\n      return d[0].concat([d[1]]);\n    },\n  },\n  {\n    name: 'tieredContents',\n    symbols: ['_', 'tieredDef', 'tieredContents$ebnf$1', '_'],\n    postprocess: ([_ws, first, rest]) => {\n      const tieredDefs = [first];\n\n      for (const [_sep, tieredDef] of rest ?? []) {\n        tieredDefs.push(tieredDef);\n      }\n      return tieredDefs;\n    },\n  },\n  {\n    name: 'tieredDef',\n    symbols: ['expression', '_', { literal: ':' }, '_', 'expression'],\n    postprocess: (d) =>\n      addArrayLoc(\n        {\n          type: 'tiered-def',\n          args: [d[0], d[4]],\n        },\n        d\n      ),\n  },\n  { name: 'tieredSep$subexpression$1', symbols: ['__n'] },\n  { name: 'tieredSep$subexpression$1', symbols: ['_', { literal: ',' }, '_'] },\n  {\n    name: 'tieredSep',\n    symbols: ['tieredSep$subexpression$1'],\n    postprocess: id,\n  },\n  {\n    name: 'select',\n    symbols: [\n      { literal: 'select' },\n      '_',\n      { literal: '(' },\n      '_',\n      'selectedColumns',\n      '_',\n      { literal: ')' },\n    ],\n    postprocess: (d) => {\n      const ref = d[4];\n\n      return addArrayLoc(\n        {\n          type: 'directive',\n          args: ['select', ...ref],\n        },\n        d\n      );\n    },\n  },\n  {\n    name: 'selectedColumns$ebnf$1',\n    symbols: [{ literal: ',' }],\n    postprocess: id,\n  },\n  {\n    name: 'selectedColumns$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'selectedColumns$ebnf$2$subexpression$1$ebnf$1',\n    symbols: [{ literal: ',' }],\n    postprocess: id,\n  },\n  {\n    name: 'selectedColumns$ebnf$2$subexpression$1$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'selectedColumns$ebnf$2$subexpression$1',\n    symbols: [\n      'genericIdentifier',\n      '_',\n      'selectedColumns$ebnf$2$subexpression$1$ebnf$1',\n      '_',\n    ],\n  },\n  {\n    name: 'selectedColumns$ebnf$2',\n    symbols: ['selectedColumns$ebnf$2$subexpression$1'],\n  },\n  {\n    name: 'selectedColumns$ebnf$2$subexpression$2$ebnf$1',\n    symbols: [{ literal: ',' }],\n    postprocess: id,\n  },\n  {\n    name: 'selectedColumns$ebnf$2$subexpression$2$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'selectedColumns$ebnf$2$subexpression$2',\n    symbols: [\n      'genericIdentifier',\n      '_',\n      'selectedColumns$ebnf$2$subexpression$2$ebnf$1',\n      '_',\n    ],\n  },\n  {\n    name: 'selectedColumns$ebnf$2',\n    symbols: [\n      'selectedColumns$ebnf$2',\n      'selectedColumns$ebnf$2$subexpression$2',\n    ],\n    postprocess: function arrpush(d) {\n      return d[0].concat([d[1]]);\n    },\n  },\n  {\n    name: 'selectedColumns',\n    symbols: [\n      'ref',\n      '_',\n      'selectedColumns$ebnf$1',\n      '_',\n      'selectedColumns$ebnf$2',\n    ],\n    postprocess: (d) => {\n      const ref = d[0];\n      const cols = addArrayLoc(\n        {\n          type: 'generic-list',\n          args: d[4].map(([ident]) => ident),\n        },\n        d[4]\n      );\n\n      return [ref, cols];\n    },\n  },\n  {\n    name: 'match',\n    symbols: [\n      { literal: 'match' },\n      '_',\n      { literal: '{' },\n      'matchContents',\n      { literal: '}' },\n    ],\n    postprocess: (d) =>\n      addArrayLoc(\n        {\n          type: 'match',\n          args: d[3],\n        },\n        d\n      ),\n  },\n  { name: 'matchContents', symbols: ['_'], postprocess: (d) => [] },\n  { name: 'matchContents$ebnf$1', symbols: [] },\n  {\n    name: 'matchContents$ebnf$1$subexpression$1',\n    symbols: ['matchDefSep', 'matchDef'],\n  },\n  {\n    name: 'matchContents$ebnf$1',\n    symbols: ['matchContents$ebnf$1', 'matchContents$ebnf$1$subexpression$1'],\n    postprocess: function arrpush(d) {\n      return d[0].concat([d[1]]);\n    },\n  },\n  {\n    name: 'matchContents',\n    symbols: ['_', 'matchDef', 'matchContents$ebnf$1', '_'],\n    postprocess: (d) => {\n      const [_ws, first, rest] = d;\n      const matchdefs = [first];\n\n      for (const [_sep, matchdef] of rest ?? []) {\n        matchdefs.push(matchdef);\n      }\n\n      return matchdefs;\n    },\n  },\n  {\n    name: 'matchDef',\n    symbols: ['expression', '_', { literal: ':' }, '_', 'expression'],\n    postprocess: (d) =>\n      addArrayLoc(\n        {\n          type: 'matchdef',\n          args: [d[0], d[4]],\n        },\n        d\n      ),\n  },\n  { name: 'matchDefSep$subexpression$1', symbols: ['__n'] },\n  {\n    name: 'matchDefSep$subexpression$1',\n    symbols: ['_', { literal: ',' }, '_'],\n  },\n  {\n    name: 'matchDefSep',\n    symbols: ['matchDefSep$subexpression$1'],\n    postprocess: id,\n  },\n  { name: 'expression', symbols: ['tiered'], postprocess: id },\n  { name: 'expression', symbols: ['match'], postprocess: id },\n  { name: 'expression', symbols: ['overExp'], postprocess: id },\n  { name: 'overExp', symbols: ['asExp'], postprocess: id },\n  {\n    name: 'overExp',\n    symbols: ['overExp', '_', { literal: 'over' }, '_', 'genericIdentifier'],\n    postprocess: (d) => {\n      return addArrayLoc(\n        {\n          type: 'directive',\n          args: ['over', d[0], d[4]],\n        },\n        d\n      );\n    },\n  },\n  { name: 'asExp', symbols: ['orOp'], postprocess: id },\n  {\n    name: 'asExp',\n    symbols: ['asExp', '_', 'asWord', '_', 'orOp'],\n    postprocess: (d) => {\n      const exp = d[0];\n      const unit = d[4];\n      return addArrayLoc(\n        {\n          type: 'directive',\n          args: ['as', exp, unit],\n        },\n        d\n      );\n    },\n  },\n  {\n    name: 'asExp',\n    symbols: ['asExp', '_', 'asWord', '_', { literal: '%' }],\n    postprocess: (d) => {\n      const percent = addLoc(\n        {\n          type: 'generic-identifier',\n          args: ['%'],\n        },\n        d[4]\n      );\n      return addArrayLoc(\n        {\n          type: 'directive',\n          args: ['as', d[0], percent],\n        },\n        d\n      );\n    },\n  },\n  { name: 'asWord$subexpression$1', symbols: [{ literal: 'as' }] },\n  { name: 'asWord$subexpression$1', symbols: [{ literal: 'to' }] },\n  { name: 'asWord$subexpression$1', symbols: [{ literal: 'in' }] },\n  { name: 'asWord', symbols: ['asWord$subexpression$1'], postprocess: id },\n  { name: 'orOp', symbols: ['andOp'], postprocess: id },\n  {\n    name: 'orOp',\n    symbols: ['orOp', '_', 'orOperator', '_', 'andOp'],\n    postprocess: basicBinop,\n  },\n  { name: 'andOp', symbols: ['equalityOp'], postprocess: id },\n  {\n    name: 'andOp',\n    symbols: ['andOp', '_', 'andOperator', '_', 'equalityOp'],\n    postprocess: basicBinop,\n  },\n  { name: 'equalityOp', symbols: ['compareOp'], postprocess: id },\n  {\n    name: 'equalityOp',\n    symbols: ['equalityOp', '_', 'eqDiffOperator', '_', 'compareOp'],\n    postprocess: basicBinop,\n  },\n  { name: 'compareOp', symbols: ['smoothOp'], postprocess: id },\n  {\n    name: 'compareOp',\n    symbols: ['compareOp', '_', 'cmpOperator', '_', 'smoothOp'],\n    postprocess: basicBinop,\n  },\n  { name: 'smoothOp', symbols: ['addSubOp'], postprocess: id },\n  {\n    name: 'smoothOp',\n    symbols: ['smoothOp', '_', 'smoothOperator', '_', 'addSubOp'],\n    postprocess: basicBinop,\n  },\n  { name: 'addSubOp', symbols: ['divMulOp'], postprocess: id },\n  {\n    name: 'addSubOp',\n    symbols: ['addSubOp', '_', 'additiveOperator', '_', 'divMulOp'],\n    postprocess: (d, _l, reject) => {\n      const left = d[0];\n      const op = d[2];\n      const right = d[4];\n\n      if (\n        op.name === '+' &&\n        left.type === 'date' &&\n        right.type === 'literal' &&\n        right.args[0] === 'number'\n      ) {\n        return reject;\n      }\n\n      return basicBinop(d);\n    },\n  },\n  { name: 'divMulOp', symbols: ['ofExp'], postprocess: id },\n  {\n    name: 'divMulOp',\n    symbols: ['divMulOp', '_', 'divMulOperator', '_', 'ofExp'],\n    postprocess: basicBinop,\n  },\n  {\n    name: 'divMulOp',\n    symbols: ['divMulOp', 'ref'],\n    postprocess: implicitMultHandler,\n  },\n  {\n    name: 'divMulOp',\n    symbols: ['divMulOp', '__', 'ofExp'],\n    postprocess: implicitMultHandler,\n  },\n  { name: 'ofExp', symbols: ['powOp'], postprocess: id },\n  {\n    name: 'ofExp',\n    symbols: ['ofExp', '_', { literal: 'of' }, '_', 'genericIdentifier'],\n    postprocess: (d) => {\n      return addArrayLoc(\n        {\n          type: 'directive',\n          args: ['of', d[0], d[4]],\n        },\n        d\n      );\n    },\n  },\n  { name: 'powOp', symbols: ['primary'], postprocess: id },\n  {\n    name: 'powOp',\n    symbols: ['primary', '_', 'powOperator', '_', 'powOp'],\n    postprocess: powHandler,\n  },\n  { name: 'primary', symbols: ['literal'], postprocess: id },\n  { name: 'primary', symbols: ['functionCall'], postprocess: id },\n  { name: 'primary', symbols: ['select'], postprocess: id },\n  { name: 'primary', symbols: ['matrixRef'], postprocess: id },\n  { name: 'primary', symbols: ['ref'], postprocess: id },\n  { name: 'primary', symbols: ['currency'], postprocess: id },\n  { name: 'primary', symbols: ['parenthesizedExpression'], postprocess: id },\n  {\n    name: 'primary',\n    symbols: [{ literal: '-' }, '_', 'parenthesizedExpression'],\n    postprocess: unaryMinusHandler,\n  },\n  {\n    name: 'primary',\n    symbols: [{ literal: '-' }, '_', 'ref'],\n    postprocess: unaryMinusHandler,\n  },\n  { name: 'primary$subexpression$1', symbols: [{ literal: '!' }] },\n  { name: 'primary$subexpression$1', symbols: [{ literal: 'not' }] },\n  {\n    name: 'primary',\n    symbols: ['primary$subexpression$1', '_', 'expression'],\n    postprocess: (d) => {\n      return addArrayLoc(\n        {\n          type: 'function-call',\n          args: [\n            addLoc(\n              {\n                type: 'funcref',\n                args: ['not'],\n              },\n              d[0][0]\n            ),\n            addLoc(\n              {\n                type: 'argument-list',\n                args: [d[2]],\n              },\n              d[2]\n            ),\n          ],\n        },\n        d\n      );\n    },\n  },\n  { name: 'primary$subexpression$2', symbols: ['ref'] },\n  { name: 'primary$subexpression$2', symbols: ['functionCall'] },\n  { name: 'primary$subexpression$2', symbols: ['parenthesizedExpression'] },\n  { name: 'primary$subexpression$2', symbols: ['select'] },\n  {\n    name: 'primary',\n    symbols: [\n      'primary$subexpression$2',\n      '_',\n      { literal: '.' },\n      '_',\n      tokenizer.has('identifier') ? { type: 'identifier' } : identifier,\n    ],\n    postprocess: (d) =>\n      addArrayLoc(\n        {\n          type: 'property-access',\n          args: [d[0][0], d[4].value],\n        },\n        d\n      ),\n  },\n  {\n    name: 'parenthesizedExpression',\n    symbols: [{ literal: '(' }, '_', 'expression', '_', { literal: ')' }],\n    postprocess: (d) => addArrayLoc(d[2], d),\n  },\n  { name: 'orOperator$subexpression$1', symbols: [{ literal: '||' }] },\n  { name: 'orOperator$subexpression$1', symbols: [{ literal: 'or' }] },\n  {\n    name: 'orOperator',\n    symbols: ['orOperator$subexpression$1'],\n    postprocess: simpleOperator,\n  },\n  { name: 'andOperator$subexpression$1', symbols: [{ literal: '&&' }] },\n  { name: 'andOperator$subexpression$1', symbols: [{ literal: 'and' }] },\n  {\n    name: 'andOperator',\n    symbols: ['andOperator$subexpression$1'],\n    postprocess: simpleOperator,\n  },\n  { name: 'eqDiffOperator$subexpression$1', symbols: [{ literal: '==' }] },\n  { name: 'eqDiffOperator$subexpression$1', symbols: [{ literal: '!=' }] },\n  {\n    name: 'eqDiffOperator',\n    symbols: ['eqDiffOperator$subexpression$1'],\n    postprocess: simpleOperator,\n  },\n  { name: 'cmpOperator$subexpression$1', symbols: [{ literal: '>' }] },\n  { name: 'cmpOperator$subexpression$1', symbols: [{ literal: '<' }] },\n  { name: 'cmpOperator$subexpression$1', symbols: [{ literal: '<=' }] },\n  { name: 'cmpOperator$subexpression$1', symbols: [{ literal: '>=' }] },\n  {\n    name: 'cmpOperator',\n    symbols: ['cmpOperator$subexpression$1'],\n    postprocess: simpleOperator,\n  },\n  { name: 'smoothOperator$subexpression$1', symbols: [{ literal: 'smooth' }] },\n  {\n    name: 'smoothOperator',\n    symbols: ['smoothOperator$subexpression$1'],\n    postprocess: simpleOperator,\n  },\n  { name: 'additiveOperator$subexpression$1', symbols: [{ literal: '-' }] },\n  { name: 'additiveOperator$subexpression$1', symbols: [{ literal: '+' }] },\n  {\n    name: 'additiveOperator',\n    symbols: ['additiveOperator$subexpression$1'],\n    postprocess: simpleOperator,\n  },\n  { name: 'divMulOperator$subexpression$1', symbols: [{ literal: 'for' }] },\n  { name: 'divMulOperator$subexpression$1', symbols: [{ literal: '*' }] },\n  { name: 'divMulOperator$subexpression$1', symbols: [{ literal: '/' }] },\n  { name: 'divMulOperator$subexpression$1', symbols: [{ literal: 'per' }] },\n  {\n    name: 'divMulOperator$subexpression$1',\n    symbols: [{ literal: 'contains' }],\n  },\n  {\n    name: 'divMulOperator',\n    symbols: ['divMulOperator$subexpression$1'],\n    postprocess: simpleOperator,\n  },\n  { name: 'divMulOperator$subexpression$2', symbols: [{ literal: 'mod' }] },\n  { name: 'divMulOperator$subexpression$2', symbols: [{ literal: 'modulo' }] },\n  {\n    name: 'divMulOperator',\n    symbols: ['__', 'divMulOperator$subexpression$2'],\n    postprocess: (d) => {\n      return addArrayLoc({ name: 'mod' }, d);\n    },\n  },\n  { name: 'powOperator$subexpression$1', symbols: [{ literal: '**' }] },\n  { name: 'powOperator$subexpression$1', symbols: [{ literal: '^' }] },\n  {\n    name: 'powOperator',\n    symbols: ['powOperator$subexpression$1'],\n    postprocess: simpleOperator,\n  },\n  {\n    name: 'range',\n    symbols: [\n      { literal: 'range' },\n      '_',\n      { literal: '(' },\n      '_',\n      'rangeInner',\n      '_',\n      { literal: ')' },\n    ],\n    postprocess: (d) => {\n      return addArrayLoc(\n        {\n          type: 'range',\n          args: d[4],\n        },\n        d\n      );\n    },\n  },\n  {\n    name: 'rangeInner',\n    symbols: ['expression', 'rangeParcelSeparator', 'expression'],\n    postprocess: ([start, _through, end]) => [start, end],\n  },\n  {\n    name: 'rangeParcelSeparator$subexpression$1',\n    symbols: [{ literal: 'through' }],\n  },\n  {\n    name: 'rangeParcelSeparator$subexpression$1',\n    symbols: [{ literal: '..' }],\n  },\n  {\n    name: 'rangeParcelSeparator$subexpression$1',\n    symbols: [{ literal: 'to' }],\n  },\n  {\n    name: 'rangeParcelSeparator',\n    symbols: ['_', 'rangeParcelSeparator$subexpression$1', '_'],\n    postprocess: () => null,\n  },\n  {\n    name: 'sequence',\n    symbols: [{ literal: '[' }, '_', 'sequenceInner', '_', { literal: ']' }],\n    postprocess: (d) => addArrayLoc(d[2], d),\n  },\n  {\n    name: 'sequenceInner',\n    symbols: ['expression', 'sequenceThrough', 'expression', 'sequenceBy'],\n    postprocess: (d) => {\n      const [start, _through, end, by] = d;\n\n      const args = [start, end];\n      if (by) {\n        args.push(by);\n      }\n\n      return addArrayLoc({ type: 'sequence', args }, d);\n    },\n  },\n  {\n    name: 'sequenceBy$ebnf$1$subexpression$1',\n    symbols: ['_', { literal: 'by' }, '_', 'expression'],\n  },\n  {\n    name: 'sequenceBy$ebnf$1',\n    symbols: ['sequenceBy$ebnf$1$subexpression$1'],\n    postprocess: id,\n  },\n  {\n    name: 'sequenceBy$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'sequenceBy',\n    symbols: ['sequenceBy$ebnf$1'],\n    postprocess: (d) => d[0]?.[3] ?? null,\n  },\n  {\n    name: 'sequenceThrough$subexpression$1',\n    symbols: [{ literal: 'through' }],\n  },\n  { name: 'sequenceThrough$subexpression$1', symbols: [{ literal: '..' }] },\n  {\n    name: 'sequenceThrough',\n    symbols: ['_', 'sequenceThrough$subexpression$1', '_'],\n    postprocess: () => null,\n  },\n  {\n    name: 'functionDef',\n    symbols: [\n      'functionDefName',\n      '_',\n      'functionDefArgs',\n      'equalSign',\n      'functionBody',\n    ],\n    postprocess: (d) =>\n      addArrayLoc(\n        {\n          type: 'function-definition',\n          args: [d[0], d[2], d[4]],\n        },\n        d\n      ),\n  },\n  {\n    name: 'functionDefName',\n    symbols: ['identifier'],\n    postprocess: (d) =>\n      addLoc(\n        {\n          type: 'funcdef',\n          args: [d[0].name],\n        },\n        d[0]\n      ),\n  },\n  { name: 'functionDefArgs$ebnf$1', symbols: [] },\n  {\n    name: 'functionDefArgs$ebnf$1$subexpression$1',\n    symbols: ['optionalComma', 'argName'],\n  },\n  {\n    name: 'functionDefArgs$ebnf$1',\n    symbols: [\n      'functionDefArgs$ebnf$1',\n      'functionDefArgs$ebnf$1$subexpression$1',\n    ],\n    postprocess: function arrpush(d) {\n      return d[0].concat([d[1]]);\n    },\n  },\n  {\n    name: 'functionDefArgs$ebnf$2$subexpression$1',\n    symbols: ['_', { literal: ',' }],\n  },\n  {\n    name: 'functionDefArgs$ebnf$2',\n    symbols: ['functionDefArgs$ebnf$2$subexpression$1'],\n    postprocess: id,\n  },\n  {\n    name: 'functionDefArgs$ebnf$2',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'functionDefArgs',\n    symbols: [\n      { literal: '(' },\n      '_',\n      'argName',\n      'functionDefArgs$ebnf$1',\n      'functionDefArgs$ebnf$2',\n      '_',\n      { literal: ')' },\n    ],\n    postprocess: (d) =>\n      addArrayLoc(\n        {\n          type: 'argument-names',\n          args: [d[2], ...d[3].map(([_comma, arg]) => arg)],\n        },\n        d\n      ),\n  },\n  {\n    name: 'optionalComma$subexpression$1',\n    symbols: ['_', { literal: ',' }, '_'],\n  },\n  { name: 'optionalComma$subexpression$1', symbols: ['__'] },\n  {\n    name: 'optionalComma',\n    symbols: ['optionalComma$subexpression$1'],\n    postprocess: id,\n  },\n  {\n    name: 'argName',\n    symbols: ['identifier'],\n    postprocess: (d) =>\n      addLoc(\n        {\n          type: 'def',\n          args: [d[0].name],\n        },\n        d[0]\n      ),\n  },\n  {\n    name: 'functionBody',\n    symbols: ['expression'],\n    postprocess: ([exp]) =>\n      addLoc(\n        {\n          type: 'block',\n          args: [exp],\n        },\n        exp\n      ),\n  },\n  {\n    name: 'functionCall',\n    symbols: ['identifier', '_', 'callArgs'],\n    postprocess: (d) => {\n      const func = d[0];\n      const args = d[2];\n\n      return addArrayLoc(\n        {\n          type: 'function-call',\n          args: [\n            addLoc(\n              {\n                type: 'funcref',\n                args: [func.name],\n              },\n              func\n            ),\n            addLoc(\n              {\n                type: 'argument-list',\n                args: args.args,\n              },\n              args\n            ),\n          ],\n        },\n        d\n      );\n    },\n  },\n  { name: 'callArgs$ebnf$1', symbols: [] },\n  {\n    name: 'callArgs$ebnf$1$subexpression$1',\n    symbols: ['_', { literal: ',' }, '_', 'expression'],\n  },\n  {\n    name: 'callArgs$ebnf$1',\n    symbols: ['callArgs$ebnf$1', 'callArgs$ebnf$1$subexpression$1'],\n    postprocess: function arrpush(d) {\n      return d[0].concat([d[1]]);\n    },\n  },\n  { name: 'callArgs$ebnf$2$subexpression$1', symbols: ['_', { literal: ',' }] },\n  {\n    name: 'callArgs$ebnf$2',\n    symbols: ['callArgs$ebnf$2$subexpression$1'],\n    postprocess: id,\n  },\n  {\n    name: 'callArgs$ebnf$2',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'callArgs',\n    symbols: [\n      { literal: '(' },\n      '_',\n      'expression',\n      'callArgs$ebnf$1',\n      'callArgs$ebnf$2',\n      '_',\n      { literal: ')' },\n    ],\n    postprocess: (d) =>\n      addArrayLoc(\n        {\n          type: 'argument-list',\n          args: [d[2], ...d[3].map(([_ws, _comma, _ws2, arg]) => arg)],\n        },\n        d\n      ),\n  },\n  {\n    name: 'block$ebnf$1$subexpression$1',\n    symbols: [\n      tokenizer.has('statementSep') ? { type: 'statementSep' } : statementSep,\n    ],\n  },\n  {\n    name: 'block$ebnf$1$subexpression$1',\n    symbols: [tokenizer.has('ws') ? { type: 'ws' } : ws],\n  },\n  {\n    name: 'block$ebnf$1',\n    symbols: ['block$ebnf$1$subexpression$1'],\n    postprocess: id,\n  },\n  {\n    name: 'block$ebnf$1',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  { name: 'block$ebnf$2', symbols: [] },\n  {\n    name: 'block$ebnf$2$subexpression$1',\n    symbols: [\n      tokenizer.has('statementSep') ? { type: 'statementSep' } : statementSep,\n      'statement',\n    ],\n  },\n  {\n    name: 'block$ebnf$2',\n    symbols: ['block$ebnf$2', 'block$ebnf$2$subexpression$1'],\n    postprocess: function arrpush(d) {\n      return d[0].concat([d[1]]);\n    },\n  },\n  {\n    name: 'block$ebnf$3$subexpression$1',\n    symbols: [\n      tokenizer.has('statementSep') ? { type: 'statementSep' } : statementSep,\n    ],\n  },\n  {\n    name: 'block$ebnf$3$subexpression$1',\n    symbols: [tokenizer.has('ws') ? { type: 'ws' } : ws],\n  },\n  {\n    name: 'block$ebnf$3',\n    symbols: ['block$ebnf$3$subexpression$1'],\n    postprocess: id,\n  },\n  {\n    name: 'block$ebnf$3',\n    symbols: [],\n    postprocess: function (d) {\n      return null;\n    },\n  },\n  {\n    name: 'block',\n    symbols: ['block$ebnf$1', 'statement', 'block$ebnf$2', 'block$ebnf$3'],\n    postprocess: (d) => {\n      const stmt = d[1];\n      const repetitions = d[2].map(([__n, stmt]) => stmt);\n\n      return addArrayLoc(\n        {\n          type: 'block',\n          args: [stmt, ...repetitions],\n        },\n        d\n      );\n    },\n  },\n  { name: 'statement', symbols: ['assign'], postprocess: id },\n  { name: 'statement', symbols: ['table'], postprocess: id },\n  { name: 'statement', symbols: ['columnAssign'], postprocess: id },\n  { name: 'statement', symbols: ['matrixAssign'], postprocess: id },\n  { name: 'statement', symbols: ['functionDef'], postprocess: id },\n  { name: 'statement', symbols: ['expression'], postprocess: id },\n  { name: 'statement', symbols: ['categories'], postprocess: id },\n  {\n    name: 'identifier',\n    symbols: [\n      tokenizer.has('identifier') ? { type: 'identifier' } : identifier,\n    ],\n    postprocess: (d, _l, reject) => {\n      const identString = d[0].value;\n\n      if (isReservedWord(identString)) {\n        return reject;\n      } else {\n        return addLoc({ name: identString }, d[0]);\n      }\n    },\n  },\n  {\n    name: 'currency',\n    symbols: [tokenizer.has('currency') ? { type: 'currency' } : currency],\n    postprocess: ([currency]) => {\n      return addLoc(\n        {\n          type: 'ref',\n          args: [currency.value],\n        },\n        currency\n      );\n    },\n  },\n  {\n    name: 'genericIdentifier',\n    symbols: [\n      tokenizer.has('identifier') ? { type: 'identifier' } : identifier,\n    ],\n    postprocess: (d) => {\n      return addArrayLoc(\n        {\n          type: 'generic-identifier',\n          args: [d[0].value],\n        },\n        d\n      );\n    },\n  },\n  {\n    name: 'ref',\n    symbols: [\n      tokenizer.has('identifier') ? { type: 'identifier' } : identifier,\n    ],\n    postprocess: (d, _l, reject) => {\n      const name = d[0].value;\n      if (reservedWords.has(name)) {\n        return reject;\n      } else {\n        return addLoc({ type: 'ref', args: [name] }, d[0]);\n      }\n    },\n  },\n  { name: 'equalSign$subexpression$1', symbols: [{ literal: '=' }] },\n  { name: 'equalSign$subexpression$1', symbols: [{ literal: 'is' }] },\n  {\n    name: 'equalSign',\n    symbols: ['_', 'equalSign$subexpression$1', '_'],\n    postprocess: (d) => d[1],\n  },\n  {\n    name: 'expression',\n    symbols: [\n      { literal: 'if' },\n      '__',\n      'expression',\n      '__',\n      { literal: 'then' },\n      '__',\n      'expression',\n      '__',\n      { literal: 'else' },\n      '__',\n      'expression',\n    ],\n    postprocess: (d) =>\n      addArrayLoc(\n        {\n          type: 'function-call',\n          args: [\n            addLoc(\n              {\n                type: 'funcref',\n                args: ['if'],\n              },\n              d[0]\n            ),\n            addArrayLoc(\n              {\n                type: 'argument-list',\n                args: [d[2], d[6], d[10]],\n              },\n              d.slice(2)\n            ),\n          ],\n        },\n        d\n      ),\n  },\n];\nlet ParserStart = 'block';\nexport default { Lexer, ParserRules, ParserStart };\n","import nearley from 'nearley';\nimport G from './nearley/deci-language-grammar-generated';\n\nexport {\n  tokenize,\n  tokenRules,\n  identifierRegExpGlobal,\n  STATEMENT_SEP_TOKEN_TYPE,\n} from './tokenizer';\n\nexport type { Token } from './tokenizer';\n\nexport const compiledGrammar = G as nearley.CompiledRules;\n","import { AST } from '..';\nimport { ParserNode } from './types';\n\nconst typesWithArgs = new Set<AST.Node['type']>([\n  'argument-list',\n  'function-call',\n  'assign',\n  'table-column-assign',\n  'categories',\n  'matrix-ref',\n  'matrix-assign',\n  'argument-names',\n  'function-definition',\n  'block',\n  'column',\n  'column-items',\n  'table',\n  'table-column',\n  'table-spread',\n  'generic-list',\n  'range',\n  'sequence',\n]);\n\nexport function sourceMapDecorator(\n  source: string\n): (nodes: ParserNode) => AST.Block {\n  const lines: string[] = source.split('\\n');\n  const locationToLine: Array<[number, number]> = [];\n  const lineToLocation: Array<[number, number]> = [];\n\n  let line = 0;\n  let location = 0;\n  for (const l of lines) {\n    line++;\n    lineToLocation.push([line, location]);\n    location += l.length + 1;\n    locationToLine.push([location - 1, line]);\n  }\n\n  return (block: ParserNode) => decorateNode(block) as AST.Block;\n\n  function decorateNode(node: ParserNode): AST.Node {\n    const line = findBorder(locationToLine, node.start as unknown as number);\n    const column =\n      (node.start as unknown as number) - findBorder(lineToLocation, line) + 1;\n\n    node.start = {\n      char: node.start as unknown as number,\n      line,\n      column,\n    };\n\n    const endChar = node.end as unknown as number;\n    const endLine = findBorder(locationToLine, endChar);\n    const endColumn = endChar - findBorder(lineToLocation, endLine) + 1;\n    node.end = {\n      char: endChar,\n      line: endLine,\n      column: endColumn,\n    };\n\n    if (typesWithArgs.has(node.type as AST.Node['type'])) {\n      node.args = (node.args as AST.Node[]).map((node: unknown) =>\n        decorateNode(node as ParserNode)\n      ) as ParserNode[];\n    } else if (node.type === 'property-access') {\n      node.args[0] = decorateNode(node.args[0] as ParserNode);\n    } else if (node.type === 'directive') {\n      const [type, ...rest] = node.args as ParserNode[];\n      node.args = [type, ...rest.map(decorateNode)] as AST.Node[];\n    }\n\n    return node as unknown as AST.Node;\n  }\n}\n\nfunction findBorder(map: Array<[number, number]>, i: number): number {\n  for (const [k, v] of map) {\n    if (i <= k) {\n      return v;\n    }\n  }\n  return -1;\n}\n","import { Token } from 'moo';\n\nexport interface ISyntaxError {\n  message: string;\n  token?: Token;\n  isEmptyExpressionError?: boolean;\n  detailMessage?: string;\n  source?: string;\n  line?: number;\n  column?: number;\n  posistionedCaret?: string;\n  expected?: string[];\n}\n\nexport class SyntaxError extends Error implements ISyntaxError {\n  readonly detailMessage?: string;\n  readonly token?: Token;\n  readonly source?: string;\n  readonly line?: number;\n  readonly column?: number;\n  readonly posistionedCaret?: string;\n  readonly expected?: string[];\n\n  constructor(args: ISyntaxError) {\n    super(args.message);\n    const {\n      detailMessage,\n      source,\n      line,\n      column,\n      posistionedCaret,\n      expected,\n      token,\n    } = args;\n    this.token = token;\n    this.detailMessage = detailMessage;\n    this.source = source;\n    this.line = line;\n    this.column = column;\n    this.posistionedCaret = posistionedCaret;\n    this.expected = expected;\n  }\n\n  static fromNearleySyntaxError(err: ISyntaxError): SyntaxError {\n    return new SyntaxError(err);\n  }\n}\n","import nearley, { Parser as NearleyParser } from 'nearley';\nimport { getDefined } from '@decipad/utils';\nimport { compiledGrammar, tokenize } from '../grammar';\nimport { ParserNode } from './types';\nimport { sourceMapDecorator } from './source-map-decorator';\nimport { AST, prettyPrintAST } from '..';\nimport { ISyntaxError, SyntaxError } from './SyntaxError';\n\nconst grammar = nearley.Grammar.fromCompiled(compiledGrammar);\n\nfunction lineColFromLexerMessage(\n  message: string\n): [number | undefined, number | undefined] {\n  const match = message.match(/line (\\d+) col (\\d+)/);\n  if (!match) {\n    return [undefined, undefined];\n  }\n  const [, line, col] = match;\n  return [Number(line), Number(col)];\n}\n\ninterface NearleyState {\n  dot: number;\n  rule: {\n    symbols: string[];\n  };\n}\n\ninterface NearleyColumn {\n  states: NearleyState[];\n}\n\ninterface NearleyParserInternals {\n  table: NearleyColumn[];\n  displayStateStack: (states: NearleyState[], lines: string[]) => void;\n  buildFirstStateStack: (\n    state: NearleyState,\n    lines: string[]\n  ) => NearleyState[];\n  getSymbolDisplay: (symbol: string) => string;\n}\n\nexport class Parser extends NearleyParser {\n  // this extends nearley and replaces the error string generation when a\n  // parse error occurs.\n  reportErrorCommon(\n    this: Parser,\n    lexerMessage: string,\n    tokenDisplay: string\n  ): string {\n    const self = this as unknown as NearleyParserInternals;\n    const [message, , source, posistionedCaret] = lexerMessage.split('\\n');\n    const error: ISyntaxError = {\n      message: 'Syntax error',\n      source,\n      posistionedCaret,\n    };\n    const lastColumnIndex = self.table.length - 2;\n    const lastColumn = self.table[lastColumnIndex];\n    const expectantStates = lastColumn.states.filter((state) => {\n      const nextSymbol = state.rule.symbols[state.dot];\n      return nextSymbol && typeof nextSymbol !== 'string';\n    });\n\n    const [line, column] = lineColFromLexerMessage(message);\n    error.line = line;\n    error.column = column;\n\n    if (expectantStates.length === 0) {\n      error.detailMessage = `Unexpected ${tokenDisplay}. I did not expect any more input.\\n`;\n      const lines: string[] = [];\n      self.displayStateStack(lastColumn.states, lines);\n      error.detailMessage += lines.join('\\n');\n    } else {\n      error.detailMessage = `Unexpected ${tokenDisplay}.`;\n      // Display a \"state stack\" for each expectant state\n      // - which shows you how this state came to be, step by step.\n      // If there is more than one derivation, we only display the first one.\n      const stateStacks = expectantStates.map((state) => {\n        return self.buildFirstStateStack(state, []) || [state];\n      }, self);\n      // Display each state that is expecting a terminal symbol next.\n      error.expected = stateStacks.map((stateStack) => {\n        const state = stateStack[0];\n        const nextSymbol = state.rule.symbols[state.dot];\n        return self.getSymbolDisplay(nextSymbol);\n      });\n    }\n    return JSON.stringify(error);\n  }\n}\n\nfunction tryParse(source: string): ParserNode {\n  const parser = new Parser(grammar);\n  parser.feed(source);\n  parser.finish();\n\n  const solutions = (parser.results as ParserNode[]).map(\n    sourceMapDecorator(source)\n  ) as ParserNode[];\n\n  if (solutions.length > 1) {\n    const printedSolutions = solutions.map((s) =>\n      prettyPrintAST(s as AST.Node)\n    );\n    console.error(\n      [`Source: ${source}`, ...printedSolutions].join('\\n\\n---\\n\\n')\n    );\n\n    // If this ever happens, it's a problem with the grammar\n    throw new SyntaxError({ message: 'panic: multiple solutions' });\n  }\n\n  if (solutions.length === 0) {\n    const token = tokenize(source).pop();\n    throw new SyntaxError({ message: 'No solutions', token });\n  }\n\n  return getDefined(solutions[0]);\n}\n\nexport function parse(source: string): ParserNode {\n  try {\n    return tryParse(source);\n  } catch (err) {\n    if (!(err instanceof SyntaxError)) {\n      let syntaxError: ISyntaxError | undefined;\n      try {\n        syntaxError = JSON.parse((err as Error).message);\n      } catch (err2) {\n        console.warn('Error trying to parse', (err as Error).message);\n        console.warn(err2);\n      }\n      if (syntaxError) {\n        throw SyntaxError.fromNearleySyntaxError({\n          ...(err as Error),\n          ...syntaxError,\n        });\n      }\n    }\n    throw err;\n  }\n}\n","import { AST, parseStatementOrThrow } from '..';\nimport { mutateAst, isNode, isIdentifier } from '../utils';\n\n/**\n * Construct a bit of decilang, and interpolate identifiers or other\n * decilang ASTs.\n *\n * @example\n *     const someExpressionAst = decilang`1 + 2`;\n *     decilang`${{ name: 'MyVarName' }} = [1, 2, ${someExpressionAst}]`\n */\nexport const decilang = <RetType extends AST.Statement = AST.Statement>(\n  strings: TemplateStringsArray,\n  ...interpolations: (AST.Node | { name: string })[]\n): RetType => {\n  const idsToInterpolations = new Map<string, AST.Node | { name: string }>();\n\n  const codeWithIds = strings\n    .map((s, i) => {\n      const arg = interpolations[i];\n      if (!arg) return s;\n\n      const id = `id__${Math.floor(Math.random() * 9999999)}`;\n      idsToInterpolations.set(id, arg);\n      return `${s}${id}`;\n    })\n    .join('');\n\n  const result = parseStatementOrThrow(codeWithIds);\n\n  // Find our randomly generated IDs\n  return interpolate(result, idsToInterpolations) as RetType;\n};\n\nconst interpolate = (\n  parsed: AST.Statement,\n  idsToInterpolations: Map<string, AST.Node | { name: string }>\n): AST.Statement => {\n  return mutateAst(parsed, (node) => {\n    if (\n      node.type === 'property-access' &&\n      idsToInterpolations.has(node.args[1])\n    ) {\n      // Special-case property access's column because the name is a string.\n      node.args[1] = (\n        idsToInterpolations.get(node.args[1]) as { name: string }\n      ).name;\n    }\n\n    const toReplace =\n      isIdentifier(node) && idsToInterpolations.get(node.args[0]);\n\n    if (!toReplace) return node;\n\n    // Replace with a provided AST.Node/name\n\n    if (isNode(toReplace)) {\n      return toReplace;\n    }\n\n    if (typeof toReplace === 'object' && 'name' in toReplace) {\n      node.args[0] = toReplace.name;\n      return node;\n    }\n\n    throw new Error('unreachable');\n  }) as AST.Statement;\n};\n","import { isExpression, n, walkAst } from '../utils';\nimport * as AST from './ast-types';\nimport * as Parser from './parser-types';\nimport { tokenizer, BracketCounter } from '../grammar/tokenizer';\nimport { parse as languageParse } from './parser';\nimport { SyntaxError } from './SyntaxError';\n\nexport { decilang } from './decilang-tag';\n\nexport { AST, Parser, n, SyntaxError };\n\nexport function parseBlock(source: string, id?: string): Parser.ParsedBlock {\n  if (source.trim() === '') {\n    return { solution: n('block', n('noop')) };\n  } else {\n    const bracketError = validateBrackets(source);\n    if (bracketError) {\n      return {\n        error: { message: 'Bracket error', bracketError },\n      };\n    }\n\n    try {\n      const solution = languageParse(source.trimEnd()) as AST.Block;\n\n      if (id) {\n        solution.id = id;\n      }\n\n      return { solution };\n    } catch (err) {\n      return {\n        error: fromParseError(err as Error),\n      };\n    }\n  }\n}\n\nexport function parseStatement(source: string): Parser.ParsedStatement {\n  const parsed = parseBlock(source);\n\n  if (parsed.error) return parsed;\n\n  return {\n    solution: parsed.solution.args[0],\n  };\n}\n\nexport function parseExpression(\n  source: string,\n  disallowedNodeTypes?: AST.Node['type'][]\n): Parser.ParsedExpression {\n  const parsed = parseStatement(source);\n\n  if (parsed.error) return parsed;\n\n  if (!isExpression(parsed.solution)) {\n    return {\n      error: { message: 'Expected expression', isEmptyExpressionError: true },\n    };\n  }\n\n  if (disallowedNodeTypes) {\n    try {\n      walkAst(parsed.solution, (node) => {\n        if (disallowedNodeTypes.includes(node.type)) {\n          throw new Error('Invalid node type');\n        }\n      });\n    } catch {\n      return {\n        error: {\n          message: 'Invalid expression in this context',\n          isDisallowedNodeType: true,\n        },\n      };\n    }\n  }\n\n  return {\n    solution: parsed.solution,\n  };\n}\n\nexport function parse(blocks: string[]): Parser.ParsedBlock[] {\n  return blocks.map((block) => parseBlock(block));\n}\n\nfunction fromParseError(err: Error): Parser.ParserError {\n  const resultError: Parser.ParserError = {\n    message: err.message,\n    token: (err as unknown as { token?: moo.Token }).token,\n  };\n  if (err instanceof SyntaxError) {\n    resultError.detailMessage = err.detailMessage;\n    resultError.line = err.line;\n    resultError.column = err.column;\n    resultError.expected = err.expected;\n    resultError.source = err.source;\n    resultError.expected = err.expected;\n  }\n  return resultError;\n}\n\nfunction validateBrackets(source: string) {\n  const counter = new BracketCounter();\n  for (const token of tokenizer.reset(source)) {\n    counter.feed(token);\n  }\n  counter.finalize();\n  return counter.validationError;\n}\n","import DeciNumber from '@decipad/number';\nimport { AST } from '..';\nimport { getIdentifierString, isNode, isStatement } from '../utils';\n\nconst prettyPrint = (node: AST.Node, indent: number): string => {\n  const perLine = isStatement(node) || ['block', 'table'].includes(node.type);\n\n  let printedArgs: string[];\n  let fname: string;\n\n  switch (node.type) {\n    case 'literal': {\n      const [, value] = node.args;\n      return value instanceof DeciNumber\n        ? value.toString()\n        : JSON.stringify(value);\n    }\n    case 'property-access': {\n      const [ref, prop] = node.args;\n      return `(prop ${prettyPrint(ref, indent + 1)}.${prop})`;\n    }\n    case 'function-call': {\n      [fname] = node.args[0].args;\n      printedArgs = node.args[1].args.map((arg) =>\n        prettyPrint(arg, indent + 1)\n      );\n      break;\n    }\n    case 'table': {\n      const [tName, ...colItems] = node.args;\n      fname = `table ${tName.args[0]}`;\n      printedArgs = Array.from(colItems, (item) => {\n        if (item.type === 'table-column') {\n          const [colName, val] = item.args;\n          return `${colName.args[0]} ${prettyPrint(val, indent + 1)}`;\n        } else {\n          return `...${getIdentifierString(item.args[0])}`;\n        }\n      });\n      break;\n    }\n    case 'column': {\n      fname = 'column';\n      printedArgs = Array.from(node.args[0].args, (item) => {\n        return prettyPrint(item, indent + 1);\n      });\n      break;\n    }\n    default: {\n      fname = node.type;\n      printedArgs = (node.args as (AST.Node | unknown)[]).flatMap(\n        function printArg(a): string | string[] {\n          if (isNode(a)) {\n            return prettyPrint(a, indent + 1);\n          } else if (Array.isArray(a)) {\n            return a.flatMap(printArg);\n          } else {\n            return String(a);\n          }\n        }\n      );\n    }\n  }\n\n  if (perLine && printedArgs.length > 0) {\n    const args = printedArgs.map((a) => '  '.repeat(indent + 1) + a);\n\n    return `(${fname}\\n${args.join('\\n')})`;\n  } else if (printedArgs.length) {\n    return `(${fname} ${printedArgs.join(' ')})`;\n  } else {\n    return `(${fname})`;\n  }\n};\n\nexport const prettyPrintAST = (ast: AST.Node) => prettyPrint(ast, 0);\n","import { AnyMapping } from '@decipad/utils';\nimport { AST, isExpression, Type } from '.';\nimport { Context, inferBlock, makeContext } from './infer';\nimport { Realm, run } from './interpreter';\nimport { parseBlock } from './parser';\nimport { OneResult, Result, validateResult } from './result';\n\nexport const parseBlockOrThrow = (source: string): AST.Block => {\n  const parsed = parseBlock(source);\n\n  if (parsed.error) {\n    throw new TypeError(parsed.error.message);\n  }\n\n  return parsed.solution;\n};\n\nexport const parseStatementOrThrow = (source: string): AST.Statement => {\n  const block = parseBlockOrThrow(source);\n  const item = block.args[0];\n\n  return item;\n};\n\nexport const parseExpressionOrThrow = (source: string): AST.Expression => {\n  const block = parseBlockOrThrow(source);\n  const item = block.args[0];\n  if (!isExpression(item)) {\n    throw new TypeError('Expected expression');\n  }\n  return item;\n};\n\ninterface RunAstOptions {\n  externalData?: AnyMapping<Result>;\n  ctx?: Context;\n  throwOnError?: boolean;\n}\n\ninterface RunAstResult {\n  type: Type;\n  value: OneResult;\n}\n\nexport const runAST = async (\n  block: AST.Block,\n  {\n    externalData,\n    ctx = makeContext({ externalData }),\n    throwOnError,\n  }: RunAstOptions = {}\n): Promise<RunAstResult> => {\n  const type = await inferBlock(block, ctx);\n\n  const erroredType = type.errorCause != null ? type : null;\n  if (erroredType && throwOnError) {\n    throw new TypeError(`Type error: ${JSON.stringify(erroredType)}`);\n  }\n\n  const [value] = await run([block], [0], new Realm(ctx));\n\n  validateResult(type, value);\n\n  return { type, value };\n};\n\nexport const runCode = async (source: string, opts: RunAstOptions = {}) => {\n  const block = parseBlockOrThrow(source);\n  return runAST(block, opts);\n};\n","// @ts-nocheck\n// worker poolyfill shenanigans\nglobal.document = {\n  documentElement: {\n    currentStyle: 'fake',\n  },\n  getElementsByTagName() {\n    return [];\n  },\n};\nglobal.window = {\n  navigator: {\n    platform: 'fake',\n  },\n  addEventListener: () => undefined,\n};\nglobal.Element = {\n  prototype: {\n    matches: () => false,\n  },\n};\nglobal.requestAnimationFrame = (cb) => setTimeout(cb, 0);\nglobal.cancelAnimationFrame = (timer) => clearTimeout(timer);\n\nglobal.window = global;\n\nexport {};\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"querystring\");","// these are the values that are good for the development sandbox\n// there are no important secrets here, so you can relax.\n// we need this to be JS because of our build script, which injects default\n// values into the builkd targets.\nconst defaultEnvValues = {\n  REACT_APP_SENTRY_DSN: '',\n  REACT_APP_GOOGLE_SHEETS_API_KEY: 'AIzaSyC1rl_w_G-RMx6hJJZRJ9rSbyD00POLIEM',\n};\n\nexport type SupportedEnvKey = keyof typeof defaultEnvValues;\nexport function defaultEnv(key: SupportedEnvKey): string {\n  return defaultEnvValues[key];\n}\n","import { once } from 'ramda';\nimport { defaultEnv, SupportedEnvKey } from './default';\n\nexport { defaultEnv };\n\nconst valueOrDefault = (key: SupportedEnvKey, value?: string): string => {\n  if (!value) {\n    // empty string or undefined\n    return defaultEnv(key);\n  }\n  return value;\n};\n\nexport const thirdParty = once(() => ({\n  googleSheets: {\n    apiKey: valueOrDefault('REACT_APP_GOOGLE_SHEETS_API_KEY'),\n  },\n}));\n","export class HttpError extends Error {\n  public code = 500;\n\n  constructor(message: string, code: number | string) {\n    super(message);\n    this.code = Number(code);\n  }\n  static fromResponse({\n    message,\n    code,\n  }: {\n    message: string;\n    code: number;\n  }): HttpError {\n    return new HttpError(message, code);\n  }\n}\n","import fetch from 'isomorphic-fetch';\nimport { HttpError } from '../utils/HttpError';\n\ninterface ErrorResponseBody {\n  error: {\n    code: number;\n    message: string;\n    status: string;\n  };\n}\n\ninterface RequestResponse {\n  contentType?: string | null;\n  statusCode?: number;\n  body: string | JSON;\n}\n\nexport async function request(\n  url: URL,\n  json = false\n): Promise<RequestResponse> {\n  const fetchOptions = {\n    method: 'GET',\n    headers: {\n      Referer: global.location.toString(),\n    },\n  };\n  const response = await fetch(url.toString(), fetchOptions);\n\n  if (!response.ok) {\n    await handleResponseError(response);\n  }\n\n  return {\n    contentType: response.headers.get('content-type'),\n    statusCode: response.status,\n    body: await (json ? response.json() : response.text()),\n  };\n}\n\nasync function handleResponseError(response: Response) {\n  const responseBodyString = await response.text();\n  let responseBodyJson: ErrorResponseBody | undefined;\n  try {\n    responseBodyJson = JSON.parse(responseBodyString as string);\n  } catch (err) {\n    // do nothing\n  }\n  const error = responseBodyJson?.error\n    ? HttpError.fromResponse(responseBodyJson?.error)\n    : new Error(responseBodyString);\n  throw error;\n}\n","import { stringify as encodeQuery } from 'querystring';\nimport { thirdParty } from '@decipad/client-config';\nimport { request } from '../../http/request';\nimport { SheetMeta } from '../../types';\n\nexport interface SpreadsheetMetaResponse {\n  body: SheetMeta;\n}\n\nexport const getSheetMeta = async (\n  spreadsheetId: string\n): Promise<SheetMeta> => {\n  const { googleSheets } = thirdParty();\n  const qs = encodeQuery({\n    key: googleSheets.apiKey,\n  });\n\n  const metadataUrl = new URL(\n    `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}?${qs}`\n  );\n\n  const spreadsheet = (await request(\n    metadataUrl,\n    true\n  )) as unknown as SpreadsheetMetaResponse;\n\n  return spreadsheet.body;\n};\n","export interface SheetRequestData {\n  sheetId: string;\n  gid: string;\n}\n\nconst getSheetRequestDataFromApiUrl = (sheetUrl: URL): SheetRequestData => {\n  const match = sheetUrl.pathname.match(\n    /^\\/v4\\/spreadsheets\\/([^/]+)\\/values\\/([^/]+)/\n  );\n\n  if (!match) {\n    throw new Error(`Could not extract request data from ${sheetUrl}`);\n  }\n\n  const [, sheetId, gid] = match;\n  return { sheetId, gid };\n};\n\nconst getSheetRequestDataFromUserUrl = (sheetUrl: URL): SheetRequestData => {\n  const match = sheetUrl.pathname.match(/^\\/spreadsheets\\/d\\/([^/]+)\\/edit/);\n  if (!match) {\n    throw new Error(`Could not extract sheet id from ${sheetUrl}`);\n  }\n  const [, sheetId] = match;\n  if (!sheetId) {\n    throw new Error(`Could not extract sheet id from ${sheetUrl}`);\n  }\n\n  const hashMatch = sheetUrl.hash.match(/gid=([0-9]+)/);\n  const gid = (hashMatch && hashMatch[1]) ?? '';\n\n  return { sheetId, gid };\n};\n\nexport const getSheetRequestDataFromUrl = (sheetUrl: URL): SheetRequestData => {\n  if (sheetUrl.hostname === 'content-sheets.googleapis.com') {\n    return getSheetRequestDataFromApiUrl(sheetUrl);\n  }\n  return getSheetRequestDataFromUserUrl(sheetUrl);\n};\n","import { thirdParty } from '@decipad/client-config';\nimport { stringify as encodeQuery } from 'querystring';\nimport { SheetMeta } from '../../types';\n\nexport const getDataUrlFromSheetMeta = (\n  sheetId: string,\n  gid: number | string,\n  sheetMeta: SheetMeta\n): URL => {\n  const { googleSheets } = thirdParty();\n  const qs = encodeQuery({\n    majorDimension: 'COLUMNS',\n    valueRenderOption: 'UNFORMATTED_VALUE',\n    dateTimeRenderOption: 'FORMATTED_STRING',\n    key: googleSheets.apiKey,\n  });\n\n  const subSheet =\n    sheetMeta.sheets.find(\n      (sheet) =>\n        sheet.properties.sheetId === gid ||\n        sheet.properties.sheetId === Number(gid)\n    ) ?? sheetMeta.sheets[Number(gid)];\n\n  const subSheetName =\n    (subSheet?.properties.title &&\n      encodeURIComponent(subSheet.properties.title)) ??\n    gid;\n\n  return new URL(\n    `https://content-sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${subSheetName}?${qs}`\n  );\n};\n","import { Sheet, SpreadsheetColumn, SpreadsheetValue } from '../types';\n\ninterface NeedsTrimming {\n  trimTopRowCount: number;\n  trimBottomRowCount: number;\n  finalRowCount: number;\n}\n\nconst isEmpty = (cell: SpreadsheetValue): boolean =>\n  typeof cell === 'string' && cell.trim().length === 0;\n\nconst columnIsNotEmpty = (column: SpreadsheetColumn): boolean => {\n  return column.find((cell) => !isEmpty(cell)) != null;\n};\n\nconst columnNeedsTrimming = (column: SpreadsheetColumn): NeedsTrimming => {\n  let alreadyHasData = false;\n  let trimTopRowCount = 0;\n  let trimBottomRowCount = 0;\n  for (const cell of column) {\n    const empty = isEmpty(cell);\n    if (alreadyHasData) {\n      if (empty) {\n        trimBottomRowCount += 1;\n      } else {\n        trimBottomRowCount = 0;\n      }\n    } else if (empty) {\n      trimTopRowCount += 1;\n    } else {\n      trimBottomRowCount = 0;\n    }\n    if (!empty) {\n      alreadyHasData = true;\n    }\n  }\n  return {\n    trimTopRowCount,\n    trimBottomRowCount,\n    finalRowCount: column.length - trimTopRowCount - trimBottomRowCount,\n  };\n};\n\nconst trimColumn = (\n  column: SpreadsheetColumn,\n  trimRowCount: number,\n  trimBottomRowCount: number,\n  finalRowCount: number\n): SpreadsheetColumn => {\n  let trimmed = column.slice(trimRowCount);\n  if (trimBottomRowCount > 0) {\n    trimmed = trimmed.slice(0, -trimBottomRowCount);\n  }\n  const needsFillingAtTheBottom = finalRowCount - trimmed.length;\n  if (needsFillingAtTheBottom) {\n    for (let i = 0; i < needsFillingAtTheBottom; i += 1) {\n      trimmed.push('');\n    }\n  }\n  return trimmed;\n};\n\ninterface TrimmerOptions {\n  finalTrimTopRowCount: number;\n  finalTrimBottomRowCount: number;\n  finalRowCount: number;\n}\n\ntype Trimmer = (column: SpreadsheetColumn) => SpreadsheetColumn;\n\nconst createTrimmer = ({\n  finalTrimTopRowCount,\n  finalTrimBottomRowCount,\n  finalRowCount,\n}: TrimmerOptions): Trimmer => {\n  return (column) =>\n    trimColumn(\n      column,\n      finalTrimTopRowCount,\n      finalTrimBottomRowCount,\n      finalRowCount\n    );\n};\n\nexport const trimSheet = (sheet: Sheet): Sheet => {\n  const columns = sheet.values.filter(columnIsNotEmpty);\n  const trimmingNeeds = columns.map(columnNeedsTrimming);\n  const finalTrimTopRowCount = Math.min(\n    ...trimmingNeeds.map((tn) => tn.trimTopRowCount)\n  );\n  const finalTrimBottomRowCount = Math.min(\n    ...trimmingNeeds.map((tn) => tn.trimBottomRowCount)\n  );\n  const finalRowCount = Math.max(\n    ...trimmingNeeds.map((tn) => tn.finalRowCount)\n  );\n  const trimmer = createTrimmer({\n    finalTrimTopRowCount,\n    finalTrimBottomRowCount,\n    finalRowCount,\n  });\n  return {\n    values: columns.map(trimmer),\n  };\n};\n","export const sheetColumnName = (columnIndex: number): string => {\n  let colName = '';\n  let dividend = Math.floor(Math.abs(columnIndex));\n  let rest;\n\n  while (dividend > 0) {\n    rest = (dividend - 1) % 26;\n    colName = String.fromCharCode(65 + rest) + colName;\n    dividend = parseInt(`${(dividend - rest) / 26}`, 10);\n  }\n  return colName;\n};\n\nexport const sheetColumnnIndex = (colName: string): number => {\n  const digits = colName.toUpperCase().split('');\n  let number = 0;\n\n  for (let i = 0; i < digits.length; i += 1) {\n    number += (digits[i].charCodeAt(0) - 64) * 26 ** (digits.length - i - 1);\n  }\n\n  return number;\n};\n","import { thirdParty } from '@decipad/client-config';\nimport { stringify as encodeQuery } from 'querystring';\nimport { SheetMeta } from '../../types';\nimport { sheetColumnName } from '../../utils/sheetColumnName';\nimport type { Island } from '../../utils/sheetIslands';\n\nconst islandToRange = (sheetName: string, island: Island): string => {\n  return `${sheetName}!${sheetColumnName(island.firstCol + 1)}${\n    island.firstRow + 1\n  }:${sheetColumnName(island.lastCol + 1)}${island.lastRow + 1}`;\n};\n\nexport const getDataRangeUrlFromSheetAndIslands = (\n  sheetId: string | number,\n  gid: number | string | undefined,\n  sheetMeta: SheetMeta,\n  island: Island\n): URL => {\n  const { googleSheets } = thirdParty();\n  const qs = encodeQuery({\n    majorDimension: 'COLUMNS',\n    valueRenderOption: 'UNFORMATTED_VALUE',\n    dateTimeRenderOption: 'FORMATTED_STRING',\n    key: googleSheets.apiKey,\n  });\n\n  const subSheet =\n    sheetMeta.sheets.find(\n      (sheet) =>\n        sheet.properties.sheetId === gid ||\n        sheet.properties.sheetId === Number(gid)\n    ) ?? sheetMeta.sheets[Number(gid)];\n  const subSheetName = subSheet?.properties.title ?? 'Sheet1';\n\n  const range = islandToRange(subSheetName, island);\n\n  return new URL(\n    `https://content-sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${encodeURIComponent(\n      range\n    )}?${qs}`\n  );\n};\n","/* eslint-disable no-param-reassign */\nimport { Result } from '@decipad/computer';\nimport { getDefined } from '@decipad/utils';\nimport { dequal } from 'dequal';\nimport { getDataRangeUrlFromSheetAndIslands } from '../providers/gsheets/getDataRangeUrlFromSheet';\nimport { ImportResult } from '../types';\nimport { matrix } from './matrix';\n\ninterface VisitStackElement {\n  col: number;\n  row: number;\n}\n\ntype VisitStack = Array<VisitStackElement>;\n\nconst neighbourDiffs = [\n  [-1, -1],\n  [0, -1],\n  [1, -1],\n  [-1, 0],\n  [1, 0],\n  [-1, 1],\n  [0, 1],\n  [1, 1],\n] as const;\n\nexport interface Island {\n  sheetName: string;\n  firstCol: number;\n  firstRow: number;\n  lastCol: number;\n  lastRow: number;\n}\n\nconst makeIsland = (sheetName: string, col: number, row: number): Island => {\n  return {\n    sheetName,\n    firstCol: col,\n    lastCol: col,\n    firstRow: row,\n    lastRow: row,\n  };\n};\n\nconst islandExtension = (\n  island: Island,\n  newCol: number,\n  newRow: number\n): Island => ({\n  ...island,\n  firstCol: Math.min(newCol, island.firstCol),\n  lastCol: Math.max(newCol, island.lastCol),\n  firstRow: Math.min(newRow, island.firstRow),\n  lastRow: Math.max(newRow, island.lastRow),\n});\n\nconst islandToResult =\n  (sheet: Result.Result<'table'>) =>\n  (island: Island): Result.Result => ({\n    type: {\n      ...sheet.type,\n      columnNames: sheet.type.columnNames.slice(\n        island.firstCol,\n        island.lastCol + 1\n      ),\n      columnTypes: sheet.type.columnTypes.slice(\n        island.firstCol,\n        island.lastCol + 1\n      ),\n    },\n    value: sheet.value\n      .filter(\n        (_, columnIndex) =>\n          columnIndex >= island.firstCol && columnIndex <= island.lastCol\n      )\n      .map((column) => column.slice(island.firstRow, island.lastRow + 1)),\n  });\n\nconst partition = (\n  sheetName: string,\n  imported: ImportResult\n): ImportResult[] => {\n  if (imported.result.type.kind !== 'table') {\n    return [];\n  }\n  const sheet = imported.result as Result.Result<'table'>;\n  const columnCount = sheet.type.columnTypes.length;\n  const rowCount = Math.max(...sheet.value.map((col) => col.length));\n  const visited = matrix(columnCount, rowCount, false);\n\n  const { value: sheetColumns } = sheet;\n\n  const islands = new Set<Island>();\n\n  const extendIsland = (island: Island, colIndex: number, rowIndex: number) => {\n    const extension = islandExtension(island, colIndex, rowIndex);\n    if (dequal(island, extension)) {\n      return island;\n    }\n    return extension;\n  };\n\n  const withinRange = (colIndex: number, rowIndex: number): boolean => {\n    return (\n      colIndex >= 0 &&\n      colIndex < columnCount &&\n      rowIndex >= 0 &&\n      rowIndex < rowCount\n    );\n  };\n\n  const hasValue = (col: number, row: number): boolean => {\n    const value = sheetColumns[col][row];\n    if (value == null) {\n      return false;\n    }\n    if (typeof value === 'string') {\n      return value.trim().length > 0;\n    }\n    if (typeof value === 'number') {\n      return true;\n    }\n    return false;\n  };\n\n  const pushNeighbourCells = (col: number, row: number, stack: VisitStack) => {\n    for (const diff of neighbourDiffs) {\n      const nextColIndex = col + diff[0];\n      const nextRowIndex = row + diff[1];\n      if (\n        withinRange(nextColIndex, nextRowIndex) &&\n        !visited[nextColIndex][nextRowIndex] &&\n        hasValue(nextColIndex, nextRowIndex)\n      ) {\n        stack.push({\n          col: nextColIndex,\n          row: nextRowIndex,\n        });\n      }\n    }\n  };\n\n  const exploreIsland = (\n    subSheetName: string,\n    _col: number,\n    _row: number\n  ): Island => {\n    let island = makeIsland(subSheetName, _col, _row);\n    const stack: Array<VisitStackElement> = [{ col: _col, row: _row }];\n    do {\n      const { col, row } = getDefined(stack.pop());\n      if (!visited[col][row] && hasValue(col, row)) {\n        visited[col][row] = true;\n        island = extendIsland(island, col, row);\n        pushNeighbourCells(col, row, stack);\n      }\n    } while (stack.length > 0);\n    return island;\n  };\n\n  for (let col = 0; col < columnCount; col += 1) {\n    for (let row = 0; row < rowCount; row += 1) {\n      if (!visited[col][row] && hasValue(col, row)) {\n        const island = exploreIsland(sheetName, col, row);\n        islands.add(island);\n      }\n    }\n  }\n\n  const newResults = [...islands].map((island) => {\n    const result = islandToResult(sheet)(island);\n    const meta = getDefined(imported.meta);\n    const { sheetId } = meta;\n    return {\n      result,\n      meta: {\n        ...meta,\n        sourceUrl: getDataRangeUrlFromSheetAndIslands(\n          getDefined(sheetId),\n          island.sheetName,\n          getDefined(meta.sourceMeta),\n          island\n        ),\n      },\n    };\n  });\n\n  return newResults;\n};\n\nexport const findAllIslands = (\n  sheetName: string,\n  sheet: ImportResult\n): ImportResult[] => partition(sheetName, sheet);\n","export const matrix = <T>(\n  columnCount: number,\n  rowCount: number,\n  startValue: T\n): Array<Array<T>> => {\n  const columns = Array.from({ length: columnCount });\n  for (let columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {\n    columns[columnIndex] = Array.from({ length: rowCount }).fill(startValue);\n  }\n  return columns as Array<Array<T>>;\n};\n","import { Computer, Result } from '@decipad/computer';\nimport { inferTable } from '@decipad/parse';\nimport { getDefined } from '@decipad/utils';\nimport { ImportResult, Sheet } from '../../types';\nimport { ImportOptions } from '../../import';\nimport { getSheetMeta } from './getSheetMeta';\nimport { getSheetRequestDataFromUrl } from './getSheetRequestDataFromUrl';\nimport { getDataUrlFromSheetMeta } from './getDataUrlFromSheetUrl';\nimport { trimSheet } from '../../utils/trimSheet';\nimport { findAllIslands } from '../../utils/sheetIslands';\n\nconst sumLength = <T>(acc: number, col: T[]): number => {\n  return acc + col.length;\n};\n\nconst errorResult = (err: string): ImportResult => {\n  return {\n    result: {\n      type: {\n        kind: 'type-error',\n        errorCause: {\n          errType: 'free-form',\n          message: err,\n        },\n      },\n      value: Result.UnknownValue.getData(),\n    },\n  };\n};\n\nconst handleGsheetsResponse = async (\n  computer: Computer,\n  resp: Response,\n  options: ImportOptions\n): Promise<Result.Result> => {\n  const { identifyIslands = false, maxCellCount } = options;\n  const body = (await resp.json()) as unknown as Sheet;\n  if (maxCellCount) {\n    const cellCount = body.values.reduce(sumLength, 0);\n    if (cellCount > maxCellCount) {\n      return errorResult(`Too many cells to import. maximum is ${maxCellCount}`)\n        .result;\n    }\n  }\n  const trimmedBody = identifyIslands ? body : trimSheet(body);\n  return inferTable(computer, trimmedBody, {\n    ...options,\n    doNotTryExpressionNumbersParse: true,\n  }) as Promise<Result.Result>;\n};\n\nconst loadSheet =\n  (computer: Computer, options: ImportOptions) => async (url: URL) => {\n    return handleGsheetsResponse(computer, await fetch(url), options);\n  };\n\nconst loadAllSubsheets = async (\n  computer: Computer,\n  importURL: URL,\n  options: ImportOptions\n): Promise<ImportResult[]> => {\n  const { sheetId } = getSheetRequestDataFromUrl(importURL);\n  const meta = await getSheetMeta(sheetId);\n  const loader = loadSheet(computer, options);\n  const results: ImportResult[] = [];\n  for (const subsheet of meta.sheets) {\n    const url = getDataUrlFromSheetMeta(\n      meta.spreadsheetId,\n      subsheet.properties.sheetId,\n      meta\n    );\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      const result = await loader(url);\n      const subMeta: ImportResult['meta'] = {\n        title: subsheet.properties.title,\n        importedAt: new Date(),\n        sourceUrl: url,\n        sheetId,\n        gid: subsheet.properties.sheetId,\n        sourceMeta: meta,\n      };\n      results.push({\n        meta: subMeta,\n        result: result as Result.Result,\n      });\n    } catch (err) {\n      results.push(errorResult((err as Error).message));\n    }\n  }\n  return results;\n};\n\nconst importGsheetIslands = async (\n  computer: Computer,\n  importURL: URL,\n  options: ImportOptions\n): Promise<ImportResult[]> => {\n  return (await loadAllSubsheets(computer, importURL, options)).flatMap(\n    (result) => findAllIslands(getDefined(result.meta?.gid).toString(), result)\n  );\n};\n\nconst importOneGsheet = async (\n  computer: Computer,\n  importURL: URL,\n  options: ImportOptions\n) => {\n  const { sheetId, gid } = getSheetRequestDataFromUrl(importURL);\n  const meta = await getSheetMeta(sheetId);\n  const url = getDataUrlFromSheetMeta(sheetId, gid, meta);\n  let resp: Response | undefined;\n  try {\n    resp = await fetch(url);\n  } catch (err) {\n    return [errorResult((err as Error).message)];\n  }\n  if (!resp.ok) {\n    return [errorResult(resp.statusText || (await resp.text()))];\n  }\n  const result = (await handleGsheetsResponse(\n    computer,\n    resp,\n    options\n  )) as Result.Result;\n\n  const importResult = {\n    meta: {\n      title: meta.properties.title,\n      importedAt: new Date(),\n    },\n    result,\n  };\n\n  return [importResult];\n};\n\nexport const importGsheet = async (\n  computer: Computer,\n  importURL: URL,\n  options: ImportOptions\n): Promise<ImportResult[]> => {\n  return (options.identifyIslands ? importGsheetIslands : importOneGsheet)(\n    computer,\n    importURL,\n    options\n  );\n};\n","import { importGsheet } from './importGsheet';\nimport { parseGsheetsSourceUrl } from './parseGsheetsSourceUrl';\n\nexport const gsheets = {\n  name: 'gsheets',\n  matchUrl: (url: URL): boolean => url.hostname === 'docs.google.com',\n  import: importGsheet,\n  parseSourceUrl: parseGsheetsSourceUrl,\n};\n","import { getSheetRequestDataFromUrl } from './getSheetRequestDataFromUrl';\nimport { SourceUrlParseResponse } from '../../types';\n\nconst getUserUrl = (sheetId: string, gid: string): string =>\n  `https://docs.google.com/spreadsheets/d/${encodeURIComponent(\n    sheetId\n  )}/edit#gid=${encodeURIComponent(gid)}`;\n\nexport const parseGsheetsSourceUrl = (url: string): SourceUrlParseResponse => {\n  const { sheetId, gid } = getSheetRequestDataFromUrl(new URL(url));\n  const indexOfExclamationMark = gid.indexOf('!');\n  const subsheetName = gid.substring(0, indexOfExclamationMark) || '0';\n  const isRange = indexOfExclamationMark > 0;\n  const ranges = decodeURIComponent(\n    gid.slice(indexOfExclamationMark + 1) || ''\n  );\n  const range = ranges.split(':');\n  const userUrl = getUserUrl(sheetId, subsheetName);\n  return { isRange, range, subsheetName, userUrl };\n};\n","export const decipad = {\n  name: 'decipad',\n  matchUrl: (url: URL): boolean =>\n    (url.hostname === 'localhost' || url.hostname.endsWith('.decipad.com')) &&\n    url.pathname.startsWith('/n/'),\n  import: () => {\n    throw new Error(\n      'Decipad notebooks are not meant to be imported statically. Use a live connection instead'\n    );\n  },\n};\n","import { ImportElementSource } from '@decipad/editor-types';\n\nconst supportedPathTerminations = new Map<string, ImportElementSource>([\n  ['.csv', 'csv'],\n  ['.arrow', 'arrow'],\n  ['.json', 'json'],\n]);\nconst supportedContentTypes = new Map<string, ImportElementSource>([\n  ['text/csv', 'csv'],\n  ['application/json', 'json'],\n  ['application/vnd.apache.arrow', 'arrow'],\n]);\n\nexport const isRandomImportUrl = async (\n  url: URL\n): Promise<[boolean, undefined | ImportElementSource]> => {\n  const key = Array.from(supportedPathTerminations.keys()).find((path) =>\n    url.pathname.endsWith(path)\n  );\n  if (key) {\n    return [true, supportedPathTerminations.get(key)];\n  }\n\n  try {\n    const { headers } = await fetch(url);\n    const type = headers.get('Content-Type');\n    if (type) {\n      const contentTypeKey = Array.from(supportedContentTypes.keys()).find(\n        (contentType) => type.startsWith(contentType)\n      );\n      if (contentTypeKey) {\n        return [true, supportedContentTypes.get(contentTypeKey)];\n      }\n    }\n  } catch (err) {\n    // do nothing\n  }\n  return [false, undefined];\n};\n","import { Result } from '@decipad/computer';\n\nexport const errorResult = (message: string): Result.Result => {\n  return {\n    type: {\n      kind: 'type-error',\n      errorCause: {\n        errType: 'free-form',\n        message,\n      },\n    },\n    value: Result.UnknownValue.getData(),\n  };\n};\n","import {\n  Interpreter,\n  Result,\n  SerializedType,\n  SerializedTypes,\n} from '@decipad/computer';\nimport { N } from '@decipad/number';\nimport { getDefined } from '@decipad/utils';\nimport { tableFromIPC, Table, Type as ArrowType } from 'apache-arrow';\nimport { errorResult } from './utils/errorResult';\n\ninterface ToStringable {\n  toString: () => string;\n}\n\nexport function toInternalType(_type: ArrowType): SerializedType {\n  let type: string | ArrowType = _type;\n  if (\n    typeof _type === 'object' &&\n    typeof (_type as ToStringable).toString === 'function'\n  ) {\n    type = (_type as ToStringable).toString();\n  }\n  switch (type) {\n    case 'Bool':\n    case ArrowType.Bool:\n      return {\n        kind: 'boolean',\n      };\n    case 'Date':\n    case 'DateMillisecond':\n    case 'Date64<MILLISECOND>':\n    case ArrowType.DateMillisecond:\n      // TODO: get granularity from date\n      return {\n        kind: 'date',\n        date: 'millisecond',\n      };\n    case 'Float':\n    case 'Float16':\n    case 'Float32':\n    case 'Float64':\n    case ArrowType.Float:\n    case ArrowType.Float16:\n    case ArrowType.Float32:\n    case ArrowType.Float64:\n      return { kind: 'number', unit: null };\n    case 'Dictionary<Int32, Utf8>':\n    case 'Utf8':\n    case ArrowType.Utf8:\n      return { kind: 'string' };\n    default:\n      return {\n        kind: 'type-error',\n        errorCause: {\n          errType: 'free-form',\n          message: `Don't know how to convert from arrow type ${type} to internal type`,\n        },\n      };\n  }\n}\n\nconst inferData = (data: Table): SerializedType => {\n  const columnTypes: SerializedType[] = [];\n  const columnNames: string[] = [];\n\n  for (let colIndex = 0; colIndex < data.numCols; colIndex += 1) {\n    const columnMeta = data.schema.fields[colIndex];\n    try {\n      const column = getDefined(data.getChildAt(colIndex));\n      const columnType: SerializedType = toInternalType(column.type);\n      columnTypes.push(columnType);\n      columnNames.push(columnMeta.name);\n    } catch (err) {\n      return {\n        kind: 'type-error',\n        errorCause: {\n          errType: 'free-form',\n          message: `Error inferring type of column ${columnMeta.name}: ${\n            (err as Error).message\n          }`,\n        },\n      };\n    }\n  }\n\n  return {\n    kind: 'table',\n    indexName: columnNames[0],\n    columnTypes,\n    columnNames,\n  };\n};\n\nconst evaluateCell = (cell: unknown): Result.OneResult => {\n  const tof = typeof cell;\n  if (cell == null) {\n    return Result.UnknownValue.getData();\n  }\n  if (tof === 'number') {\n    return N(cell as number);\n  }\n  if (tof === 'boolean' || tof === 'string') {\n    return cell as string | boolean;\n  }\n  if (typeof cell === 'object') {\n    if (cell instanceof Date) {\n      return BigInt(cell.getTime());\n    }\n    if ('toString' in cell && typeof cell.toString === 'function') {\n      return cell.toString();\n    }\n  }\n  return Result.UnknownValue.getData();\n};\n\nconst evaluateData = (\n  _type: SerializedTypes.Table,\n  data: Table\n): Result.Result<'table'>['value'] => {\n  const colValues: Interpreter.ResultColumn[] = [];\n\n  for (let colIndex = 0; colIndex < data.numCols; colIndex += 1) {\n    const column = getDefined(\n      data.getChildAt(colIndex),\n      `expected column at ${colIndex}`\n    );\n    const values: Interpreter.ResultColumn = [];\n    for (let rowIndex = 0; rowIndex < column.length; rowIndex += 1) {\n      values.push(evaluateCell(column.get(rowIndex)));\n    }\n    colValues.push(values);\n  }\n\n  return colValues;\n};\n\nexport const importFromArrow = async (\n  resp: Response\n): Promise<Result.Result> => {\n  const arrowTable = await tableFromIPC(resp);\n  const type = inferData(arrowTable);\n  if (type.kind === 'table') {\n    return {\n      type,\n      value: evaluateData(type, arrowTable),\n    };\n  }\n  if (type.kind === 'type-error') {\n    return {\n      type,\n      value: Result.UnknownValue.getData(),\n    };\n  }\n  return errorResult(`Unexpected result of type ${type.kind}`);\n};\n","import { SpreadsheetColumn, SpreadsheetRow } from '../types';\n\nexport const pivot = (rows: SpreadsheetRow[]): SpreadsheetColumn[] => {\n  const columns: SpreadsheetColumn[] = [];\n  for (const row of rows) {\n    row.forEach((cell, columnIndex) => {\n      const column: SpreadsheetColumn = columns[columnIndex] || [];\n      column.push(cell);\n      columns[columnIndex] = column;\n    });\n  }\n  return columns;\n};\n","import { parse as parseCSV } from 'csv-parse';\nimport { Computer, Result } from '@decipad/computer';\nimport { inferTable } from '@decipad/parse';\nimport { pivot } from './utils/pivot';\nimport { Sheet, SpreadsheetValue } from './types';\nimport type { ImportOptions } from './import';\nimport { trimSheet } from './utils/trimSheet';\n\nconst toColumnOriented = (rowOrientedData: SpreadsheetValue[][]): Sheet => {\n  return {\n    values: pivot(rowOrientedData),\n  };\n};\n\nexport const importFromCsv = async (\n  computer: Computer,\n  resp: Response,\n  options: ImportOptions\n): Promise<Result.Result<'table'>> => {\n  const source = await resp.text();\n  return new Promise((resolve, reject) => {\n    const data: string[][] = [];\n    const parser = parseCSV({\n      cast: true,\n      trim: true,\n      delimiter: [',', ';'],\n      relax_quotes: true,\n      relax_column_count: true,\n      skip_empty_lines: true,\n    });\n    let isDone = false;\n    parser.on('readable', () => {\n      let row;\n      while ((row = parser.read())) {\n        if (!isDone) {\n          data.push(row);\n        }\n      }\n    });\n    parser.once('end', async () => {\n      isDone = true;\n      try {\n        const sheet = trimSheet(toColumnOriented(data));\n        resolve(\n          await inferTable(computer, sheet, {\n            ...options,\n            doNotTryExpressionNumbersParse: true,\n          })\n        );\n      } catch (err) {\n        reject(err);\n      }\n    });\n    parser.once('error', reject);\n    parser.end(source);\n  });\n};\n","import { Result } from '@decipad/computer';\nimport { ColIndex, TableCellType } from '@decipad/editor-types';\nimport { N } from '@decipad/number';\nimport { columnNameFromIndex, parseBoolean, parseDate } from '@decipad/parse';\nimport type { ImportOptions } from './import';\nimport { errorResult } from './utils/errorResult';\nimport { sameType } from './utils/sameType';\n\nconst importTableFromArray = (\n  arr: Array<unknown>,\n  options: ImportOptions\n): Result.Result => {\n  if (arr.length === 0) {\n    return errorResult('Don`t know how to import empty array');\n  }\n  return importTableFromObject(\n    Object.fromEntries(\n      arr.map((elem, index) => [columnNameFromIndex(index), elem])\n    ),\n    options\n  );\n};\n\nconst importFromArray = (\n  arr: Array<unknown>,\n  options: ImportOptions\n): Result.Result => {\n  if (arr.length === 0) {\n    return {\n      type: {\n        kind: 'anything',\n      },\n      value: Result.UnknownValue.getData(),\n    };\n  }\n  if (arr.some((elem) => Array.isArray(elem))) {\n    return importTableFromArray(arr, options);\n  }\n  const results = arr.map((cell) => importFromUnknownJson(cell, options));\n  if (!sameType(results.map(({ type }) => type))) {\n    return errorResult('not all elements of array are of same type');\n  }\n  return {\n    type: {\n      kind: 'column',\n      indexedBy: null,\n      cellType: results[0].type,\n      columnSize: 'unknown',\n    },\n    value: results.map((r) => r.value) as Result.Result<'column'>['value'],\n  };\n};\n\nconst importTableFromObject = (\n  obj: Record<string, unknown>,\n  options: ImportOptions\n): Result.Result => {\n  const entries = Object.entries(obj);\n  if (entries.length < 0) {\n    return errorResult('Don`t know how to import an empty object');\n  }\n  const results = entries\n    .map(([, value], index) => [index, value])\n    .map(([index, value]) =>\n      importFromUnknownJson(\n        value,\n        options,\n        options.columnTypeCoercions?.[index as ColIndex]\n      )\n    );\n\n  const value = results.map((res) => {\n    if (res.value == null) {\n      return Result.UnknownValue.getData();\n    }\n    if (res.type.kind === 'column') {\n      return res.value as Result.Result['value'];\n    }\n    if (res.type.kind === 'type-error') {\n      return res.value as Result.Result['value'];\n    }\n    return [res.value] as Result.Result['value'];\n  }) as Result.Result<'table'>['value'];\n\n  const columnNames = Object.keys(obj);\n\n  const r: Result.Result<'table'> = {\n    type: {\n      kind: 'table',\n      columnNames,\n      columnTypes: results.map((res) => {\n        if (res.type.kind === 'column') {\n          return res.type.cellType;\n        }\n        return res.type;\n      }),\n      indexName: columnNames[0],\n    },\n    value,\n  };\n\n  return r as Result.Result;\n};\n\ninterface ToStringable {\n  toString: () => string;\n}\n\nexport const importFromUnknownJson = (\n  json: unknown,\n  options: ImportOptions,\n  cohersion?: TableCellType\n): Result.Result => {\n  if (Array.isArray(json)) {\n    return importFromArray(json, options);\n  }\n  const tof = typeof json;\n  if (cohersion?.kind === 'string') {\n    return {\n      type: {\n        ...cohersion,\n      },\n      value: (json as ToStringable).toString(),\n    };\n  }\n\n  if ((tof === 'number' || tof === 'bigint') && cohersion?.kind === 'date') {\n    return {\n      type: {\n        ...cohersion,\n      },\n      value: BigInt(json as number),\n    };\n  }\n\n  if (\n    tof === 'number' ||\n    tof === 'bigint' ||\n    (tof === 'string' && cohersion?.kind === 'number')\n  ) {\n    return {\n      type: {\n        kind: 'number',\n        unit: null,\n      },\n      value: N(json as number | bigint | string),\n    };\n  }\n  if (\n    tof === 'boolean' ||\n    (tof === 'string' && cohersion?.kind === 'boolean')\n  ) {\n    return {\n      type: {\n        kind: 'boolean',\n      },\n      value:\n        tof === 'boolean' ? (json as boolean) : parseBoolean(json as string),\n    };\n  }\n  if (tof === 'string') {\n    const value = (json as string).trim();\n    if (value) {\n      if (cohersion?.kind === 'date') {\n        const date = parseDate(value, cohersion.date);\n        if (date) {\n          return {\n            type: { ...cohersion },\n            value: BigInt(date.date.getTime()),\n          };\n        }\n      }\n      return {\n        type: {\n          kind: 'string',\n        },\n        value: json as string,\n      };\n    }\n    return {\n      type: {\n        kind: 'anything',\n      },\n      value: Result.UnknownValue.getData(),\n    };\n  }\n  if (tof === 'object' && json != null) {\n    return importTableFromObject(json as Record<string, unknown>, options);\n  }\n  return {\n    type: {\n      kind: 'anything',\n    },\n    value: Result.UnknownValue.getData(),\n  };\n};\n","import { SerializedType } from '@decipad/computer';\nimport { dequal } from 'dequal';\n\nexport const sameType = (types: SerializedType[]): boolean => {\n  if (types.length === 0) {\n    return true;\n  }\n  const firstType = types[0];\n  for (const type of types.slice(1)) {\n    if (!dequal(type, firstType)) {\n      return false;\n    }\n  }\n  return true;\n};\n","import { Computer, Result } from '@decipad/computer';\nimport type { ImportOptions } from './import';\nimport { importFromArrow } from './importFromArrow';\nimport { importFromCsv } from './importFromCsv';\nimport { importFromUnknownJson } from './importFromUnknownJson';\nimport { ImportResult } from './types';\n\nconst importFromUnknownResponse = async (\n  computer: Computer,\n  resp: Response,\n  options: ImportOptions,\n  url?: URL\n): Promise<ImportResult[]> => {\n  if (!resp.ok) {\n    throw new Error(\n      `failed to fetch from ${url} with response ${resp.status}: ${resp.statusText}`\n    );\n  }\n  const contentType = resp.headers.get('content-type');\n  let result: Result.Result | undefined;\n  if (contentType?.startsWith('application/json')) {\n    result = importFromUnknownJson(await resp.json(), options);\n  } else if (contentType?.startsWith('text/csv')) {\n    result = (await importFromCsv(computer, resp, options)) as Result.Result;\n  } else if (contentType?.startsWith('application/vnd.apache.arrow')) {\n    result = await importFromArrow(resp);\n  } else {\n    result = {\n      type: {\n        kind: 'string',\n      },\n      value: await resp.text(),\n    };\n  }\n\n  return [\n    {\n      meta: {\n        sourceUrl: url,\n      },\n      result,\n    },\n  ];\n};\n\nconst importFromUnknownUrl = async (\n  computer: Computer,\n  url: URL,\n  options: ImportOptions = {}\n): Promise<ImportResult[]> => {\n  try {\n    return importFromUnknownResponse(computer, await fetch(url), options, url);\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(`Error making request to ${url}`, err);\n    throw err;\n  }\n};\n\nexport const importFromUnknown = (\n  computer: Computer,\n  source: URL | Response,\n  options: ImportOptions\n): Promise<ImportResult[]> => {\n  if (source instanceof URL) {\n    return importFromUnknownUrl(computer, source, options);\n  }\n  return importFromUnknownResponse(computer, source as Response, options);\n};\n","import { Computer } from '@decipad/computer';\nimport {\n  ColIndex,\n  ImportElementSource,\n  TableCellType,\n} from '@decipad/editor-types';\nimport { importFromUnknown } from './importFromUnknown';\nimport { decipad, gsheets } from './providers';\nimport { ImportResult } from './types';\n\nexport interface ImportOptions {\n  identifyIslands?: boolean;\n  useFirstRowAsHeader?: boolean;\n  columnTypeCoercions?: Record<ColIndex, TableCellType>;\n  doNotTryExpressionNumbersParse?: boolean;\n  maxCellCount?: number;\n}\n\nconst internalTryImport = (\n  computer: Computer,\n  url: URL,\n  provider?: ImportElementSource,\n  options: ImportOptions = {}\n): Promise<ImportResult[]> => {\n  if (provider) {\n    switch (provider) {\n      case 'gsheets':\n        return gsheets.import(computer, url, options);\n      case 'decipad':\n        return decipad.import();\n    }\n  }\n  return importFromUnknown(computer, url, options);\n};\n\nexport const tryImport = async (\n  computer: Computer,\n  url: URL,\n  provider?: ImportElementSource,\n  options: ImportOptions = {}\n): Promise<ImportResult[]> => {\n  const { identifyIslands, ...restOptions } = options;\n  let result = await internalTryImport(computer, url, provider, options);\n  if (result.length === 1 && identifyIslands) {\n    result = await internalTryImport(computer, url, provider, restOptions);\n  }\n  return result;\n};\n","import { ImportResult } from '@decipad/import';\nimport { RPCResponse } from './types';\n\nexport const createResponse = (result: ImportResult): ImportResult => {\n  return result; // TODO: un-serialize JSON-unfriendly structs (like Fraction and bigints)\n};\n\nexport const createRPCResponse = (result: ImportResult): RPCResponse => {\n  return result; // TODO: serialize JSON-unfriendly structs (like Fraction and bigints)\n};\n","/* eslint-disable no-restricted-globals */\nimport './utils/workerPolyfills';\nimport { ImportResult, tryImport } from '@decipad/import';\nimport { Computer } from '@decipad/computer';\nimport { getNotebook, getURLComponents } from '@decipad/editor-utils';\nimport { RPC } from '@mixer/postmessage-rpc';\nimport { nanoid } from 'nanoid';\nimport { dequal } from 'dequal';\nimport { createRPCResponse } from './createResponse';\nimport type {\n  Observe,\n  SubscribeParams,\n  Subscription,\n  SubscriptionId,\n} from './types';\n\nconst rpc = new RPC({\n  target: {\n    postMessage: (data) => {\n      self.postMessage(data);\n    },\n  },\n  receiver: {\n    readMessages: (cb) => {\n      const listener = (ev: MessageEvent) => {\n        cb(ev);\n      };\n      self.addEventListener('message', listener);\n      return () => self.removeEventListener('message', listener);\n    },\n  },\n  serviceId: 'live-connect',\n});\n\ninterface UnsubscribeParams {\n  subscriptionId: SubscriptionId;\n}\n\nconst subscriptions = new Map<SubscriptionId, Subscription>();\n\nconst tryImportHere = async (\n  computer: Computer,\n  subscriptionId: SubscriptionId\n) => {\n  const sub = subscriptions.get(subscriptionId);\n  if (sub) {\n    try {\n      const results = await tryImport(\n        computer,\n        new URL(sub.params.url),\n        sub.params.source,\n        {\n          useFirstRowAsHeader: sub.params.useFirstRowAsHeader,\n          columnTypeCoercions: sub.params.columnTypeCoercions,\n          maxCellCount: sub.params.maxCellCount,\n        }\n      );\n      for (const result of results) {\n        sub.notify(result);\n      }\n    } catch (err) {\n      console.error(\n        `subscription ${subscriptionId}: caught error while trying to import from ${sub.params.url}`,\n        err\n      );\n      onError(subscriptionId, sub.params)(err as Error);\n    } finally {\n      schedule(computer, subscriptionId);\n    }\n  }\n};\n\nconst schedule = (computer: Computer, subscriptionId: SubscriptionId) => {\n  const sub = subscriptions.get(subscriptionId);\n  if (sub) {\n    setTimeout(\n      () => tryImportHere(computer, subscriptionId),\n      (sub.params.pollIntervalSeconds || 30) * 1000\n    );\n  }\n};\n\nconst notify = (subscriptionId: string) => {\n  return async (result: ImportResult) => {\n    let lastResult: ImportResult | undefined;\n    if (!dequal(lastResult, result)) {\n      lastResult = result;\n      const newResponse = createRPCResponse(result);\n      await rpc.call('notify', { subscriptionId, newResponse });\n    }\n  };\n};\n\nconst unsubscribe = (subscriptionId: string) => {\n  const sub = subscriptions.get(subscriptionId);\n  if (sub) {\n    if (sub.timer) {\n      clearTimeout(sub.timer);\n    }\n    if (sub.subscription) {\n      sub.subscription.unsubscribe();\n    }\n    subscriptions.delete(subscriptionId);\n  }\n};\n\nconst hasCircularDependency = (subscriptionRequest: Subscription): boolean => {\n  // detect find out if we're already subscribed\n  for (const subscription of subscriptions.values()) {\n    if (\n      subscription.params.source === subscriptionRequest.params.source &&\n      subscription.params.url === subscriptionRequest.params.url\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst observe =\n  (parentSubscriptionId: string): Observe =>\n  async (subscriptionRequest: Subscription, throwOnError = false) => {\n    try {\n      if (hasCircularDependency(subscriptionRequest)) {\n        throw new Error(\n          `Circular dependency detected for ${subscriptionRequest.params.url}`\n        );\n      }\n      const subscriptionId = nanoid();\n      await subscribeInternal(subscriptionId, subscriptionRequest);\n      let closed = false;\n      return {\n        get closed() {\n          return closed;\n        },\n        unsubscribe: () => {\n          closed = true;\n          unsubscribe(subscriptionId);\n        },\n      };\n    } catch (err) {\n      if (throwOnError) {\n        throw err;\n      }\n      rpc.call('notify', {\n        subscriptionId: parentSubscriptionId,\n        error: (err as Error).message,\n      });\n    }\n    return undefined;\n  };\n\nconst onError =\n  (subscriptionId: string, params: SubscribeParams) =>\n  (err: Error): void => {\n    console.error(\n      `Worker: error caught on worker ${params.url}: ${(err as Error).message}`,\n      err\n    );\n    rpc.call('notify', {\n      subscriptionId,\n      error: err.message,\n    });\n  };\n\nconst deferringError =\n  (subscriptionId: string, params: SubscribeParams) => (message: string) => {\n    setTimeout(() => {\n      onError(subscriptionId, params)(new Error(message));\n    }, 0);\n  };\n\nconst subscribeInternal = async (\n  subscriptionId: string,\n  subscription: Subscription\n) => {\n  const deferError = deferringError(subscriptionId, subscription.params);\n  subscriptions.set(subscriptionId, subscription);\n  const { params } = subscription;\n  if (params.source === 'decipad') {\n    const { startNotebook } = await import('./notebook');\n    const { docId } = getURLComponents(subscription.params.url);\n    const { hasAccess, exists } = await getNotebook(docId);\n    const error = !exists\n      ? 'Notebook does not exist'\n      : !hasAccess\n      ? \"You don't have access to this notebook\"\n      : undefined;\n    if (error) {\n      deferError(error);\n      return;\n    }\n    await startNotebook(\n      subscription,\n      observe(subscriptionId),\n      onError(subscriptionId, params)\n    );\n  } else {\n    const computer = new Computer();\n    schedule(computer, subscriptionId);\n    setTimeout(() => {\n      tryImportHere(computer, subscriptionId);\n    }, 0);\n  }\n};\n\nconst subscribe = async (params: SubscribeParams) => {\n  const subscriptionId = nanoid();\n  const subscription: Subscription = { params, notify: notify(subscriptionId) };\n  await subscribeInternal(subscriptionId, subscription);\n\n  return subscriptionId;\n};\n\nrpc.expose<SubscribeParams>('subscribe', subscribe);\n\nrpc.expose<UnsubscribeParams>('unsubscribe', async ({ subscriptionId }) => {\n  unsubscribe(subscriptionId);\n});\n\nexport {};\n","import { fetch } from '@decipad/fetch';\n\ninterface Notebook {\n  isPublic?: boolean;\n}\n\ninterface NotebookProps {\n  hasAccess: boolean;\n  exists: boolean;\n  isPublic?: boolean;\n}\n\nexport const getNotebook = async (\n  notebookId: string\n): Promise<NotebookProps> => {\n  const resp = await fetch(`/api/pads/${encodeURIComponent(notebookId)}`);\n  if (resp.status === 403) {\n    return {\n      hasAccess: false,\n      exists: true,\n      isPublic: false,\n    };\n  }\n  if (resp.status === 404) {\n    return {\n      hasAccess: false,\n      exists: false,\n      isPublic: false,\n    };\n  }\n  const notebook = (await resp.json()) as Notebook;\n  if (!notebook) {\n    return { exists: false, hasAccess: false, isPublic: false };\n  }\n  return { exists: true, hasAccess: true, isPublic: !!notebook.isPublic };\n};\n","export type FractionLike = {\n  n: bigint | number | string;\n  d: bigint | number | string;\n  s: bigint | number | string;\n};\n\nexport type AcceptableFractionLike = {\n  n: bigint;\n  d: bigint;\n  s: bigint;\n};\n\nexport const fractionLikeProps = ['n', 'd', 's'] as const;\n\nconst isFractionLikeProp = (\n  f: Record<string, unknown>,\n  prop: string\n): boolean => {\n  if (!(prop in f)) {\n    return false;\n  }\n  const tof = typeof f[prop];\n  return tof === 'number' || tof === 'bigint' || tof === 'string';\n};\n\nexport const isFractionLike = (f: unknown): f is FractionLike => {\n  return (\n    typeof f === 'object' &&\n    f != null &&\n    fractionLikeProps.every((prop) =>\n      isFractionLikeProp(f as Record<string, unknown>, prop)\n    )\n  );\n};\n","import type Fraction from '.';\n\nexport const min = (...fs: Fraction[]): Fraction => {\n  if (fs.length < 1) {\n    throw new Error('dont know the minimum of an empty set of fractions');\n  }\n  const [a, ...rest] = fs;\n  return rest.reduce((a, b) => {\n    if (a.compare(b) < 0) {\n      return a;\n    }\n    return b;\n  }, a);\n};\n","import type Fraction from '.';\n\nexport const max = (...fs: Fraction[]): Fraction => {\n  if (fs.length < 1) {\n    throw new Error('dont know the maximum of an empty set of fractions');\n  }\n  const [a, ...rest] = fs;\n  return rest.reduce((a, b) => {\n    if (a.compare(b) > 0) {\n      return a;\n    }\n    return b;\n  }, a);\n};\n","import Fraction from 'fraction.js/bigfraction';\nimport { FractionLike, isFractionLike } from './isFractionLike';\n\n(BigInt.prototype as unknown as { toJSON: () => string }).toJSON =\n  function toJSON() {\n    return this.toString();\n  };\n\n/* eslint-disable */\n(Fraction as any).prototype[Symbol.for('nodejs.util.inspect.custom')] =\n  function stringifyFractionForNodeConsole(_depth: any, options: any) {\n    return `Fraction { ${options.stylize(this.toString(), 'number')} }`;\n  };\n\nconst isNumber = (n: unknown): n is number | bigint => {\n  const tof = typeof n;\n  return tof === 'number' || tof === 'bigint';\n};\n\nexport const abs = <N extends number | bigint>(n: N): N => {\n  if (typeof n === 'number') {\n    return Math.abs(n) as N;\n  }\n  if (n < 0n) {\n    return -n as N;\n  }\n  return n;\n};\n\nconst from = (\n  n: Fraction | FractionLike | number | string | bigint,\n  d?: bigint | number\n): Fraction => {\n  if (d != null) {\n    return from(n).div(from(d));\n  }\n  if (n instanceof Fraction) {\n    return n;\n  }\n  if (typeof n === 'string') {\n    return new Fraction(n);\n  }\n  if (\n    isFractionLike(n) &&\n    isNumber(n.s) &&\n    isNumber(n.n) &&\n    (n.d === undefined || isNumber(n.d))\n  ) {\n    return new Fraction(BigInt(n.s) * BigInt(n.n), n.d);\n  }\n  return new Fraction(n as number | bigint | string);\n};\n\nexport default Fraction;\n\nconst toFraction = from;\n\nexport { from, toFraction };\n\nexport const ZERO = from(0);\nexport const ONE = from(1);\n\nexport const F = (n: number | bigint | FractionLike | string): Fraction =>\n  from(n);\n\nexport * from './utils';\nexport * from './isFractionLike';\nexport * from './min';\nexport * from './max';\nexport * from './comparisons';\n","// eslint-disable-next-line no-restricted-imports\nimport Fraction, { isFractionLike, F, pow } from '@decipad/fraction';\nimport {\n  FiniteNumber,\n  InfiniteNumber,\n  UndefinedNumber,\n  UndefinableOrInfiniteOrFractionLike,\n  DeciNumberInputWithNumerator,\n  DeciNumberInput,\n} from './types';\n\nexport type { DeciNumberInputWithNumerator };\n\nexport const isUndefined = (n: unknown): n is UndefinedNumber => {\n  return n instanceof DeciNumber && n.n == null && n.d == null && n.s == null;\n};\n\nexport const isFinite = (n: unknown): n is FiniteNumber => {\n  return n instanceof DeciNumber && !isUndefined(n) && !isInfinite(n);\n};\n\nexport const isInfinite = (n: unknown): n is InfiniteNumber =>\n  n instanceof DeciNumber && !!(n as DeciNumber).infinite;\n\nconst isSameInfinite = (a: InfiniteNumber, b: InfiniteNumber): boolean => {\n  return a.s === b.s;\n};\n\nconst isZero = (n: DeciNumber): boolean => isFinite(n) && n.n === 0n;\n\nconst binOp = <B>(\n  a: DeciNumber,\n  b: DeciNumber | B,\n  op: (this: Fraction, that: B) => Fraction\n): DeciNumber => {\n  if (isUndefined(a) || isInfinite(a)) {\n    return a;\n  }\n  if (b instanceof DeciNumber && (isUndefined(b) || isInfinite(b))) {\n    return b;\n  }\n  const result = op.call(a as unknown as Fraction, b as B);\n  return fromNumber(result);\n};\n\nexport const isDeciNumberInput = (n: unknown): n is DeciNumberInput => {\n  return (\n    typeof n === 'bigint' ||\n    (typeof n === 'object' &&\n      n != null &&\n      (n instanceof DeciNumber ||\n        ('n' in n &&\n          (typeof n.n === 'number' ||\n            typeof n.n === 'bigint' ||\n            typeof n.n === 'string')) ||\n        ('infinite' in n && typeof n.infinite === 'boolean')))\n  );\n};\n\nexport const fromNumber = (\n  n: unknown,\n  d?: number | bigint | string\n): DeciNumber => {\n  if (n == null) {\n    return new DeciNumber({});\n  }\n  if (n instanceof DeciNumber) {\n    if (d == null) {\n      return n;\n    }\n    return n.div(fromNumber(d));\n  }\n\n  const tofN = typeof n;\n  if (tofN === 'number' || tofN === 'bigint' || tofN === 'string') {\n    if (d == null) {\n      return new DeciNumber(n);\n    } else {\n      return fromNumber(n).div(fromNumber(d));\n    }\n  }\n  if (isFractionLike(n) || isDeciNumberInput(n)) {\n    return new DeciNumber(n);\n  }\n\n  throw new Error(`Could not convert ${n} of type ${typeof n} to number`);\n};\n\nexport const N = fromNumber;\n\nexport class DeciNumber {\n  public readonly n?: bigint;\n  public readonly d?: bigint;\n  public readonly s?: bigint;\n  public infinite = false;\n\n  constructor(\n    f?: UndefinableOrInfiniteOrFractionLike | string | bigint | number\n  ) {\n    if (f == null) {\n      return;\n    }\n    if (\n      typeof f === 'string' ||\n      typeof f === 'bigint' ||\n      typeof f === 'number'\n    ) {\n      if (typeof f === 'number') {\n        if (Number.isNaN(f)) {\n          return;\n        }\n        if (!Number.isFinite(f)) {\n          this.s = BigInt(Math.sign(f));\n          this.infinite = true;\n          return;\n        }\n      }\n      const n = F(f);\n      this.n = n.n;\n      this.d = n.d;\n      this.s = n.s;\n      return;\n    }\n    if (f.d == null && f.n == null && !f.infinite) {\n      return;\n    }\n    if (typeof f.n === 'number' && !Number.isFinite(f.n)) {\n      if (Number.isNaN(f.n)) {\n        return;\n      }\n      if (Number.isFinite(f.d)) {\n        this.infinite = true;\n        this.s = f.s != null ? BigInt(f.s) : 1n;\n      }\n      return;\n    }\n    if (typeof f.d === 'number' && !Number.isFinite(f.d)) {\n      this.n = 0n;\n      this.d = 1n;\n      this.s = BigInt(Math.sign(Number(f.n)) * Math.sign(Number(f.d)));\n      return;\n    }\n\n    if (!f.d) {\n      if (f.n) {\n        this.infinite = true;\n        this.s = BigInt(Math.sign(Number(f.n)) * Math.sign(Number(f.d)));\n        return;\n      } else if (!f.infinite) {\n        return;\n      }\n    }\n\n    if (isFractionLike(f)) {\n      const fraction = F(f);\n      this.n = fraction.n;\n      this.d = fraction.d;\n      this.s = fraction.s;\n    } else {\n      this.s = BigInt(Number(f.s ?? 1));\n      this.infinite = !!f.infinite;\n    }\n  }\n\n  public abs(): DeciNumber {\n    if (isUndefined(this) || isInfinite(this)) {\n      return this;\n    }\n    return fromNumber(Fraction.prototype.abs.call(this));\n  }\n\n  neg(): DeciNumber {\n    if (isUndefined(this)) {\n      return this;\n    }\n    if (isInfinite(this)) {\n      return new DeciNumber({\n        infinite: true,\n        s: -this.s,\n      });\n    }\n    return fromNumber(Fraction.prototype.neg.call(this));\n  }\n\n  add(n: DeciNumber): DeciNumber {\n    return binOp(this, n, Fraction.prototype.add);\n  }\n\n  sub(n: DeciNumber): DeciNumber {\n    return binOp(this, n, Fraction.prototype.sub);\n  }\n\n  mul(n: DeciNumber): DeciNumber {\n    return binOp(this, n, Fraction.prototype.mul);\n  }\n\n  div(d: DeciNumber): DeciNumber {\n    if (isFinite(d) && isZero(d)) {\n      if (isFinite(this) && isZero(this)) {\n        // 0 / 0 = undefined\n        return new DeciNumber({\n          n: undefined,\n          d: undefined,\n          s: this.s ?? 0n * d.s,\n          infinite: false,\n        });\n      }\n      // n / 0 = infinity\n      return new DeciNumber({\n        n: undefined,\n        d: undefined,\n        s: this.s ?? 0n * d.s,\n        infinite: true,\n      });\n    }\n    if (isInfinite(this) && isFinite(d)) {\n      return new DeciNumber({\n        n: undefined,\n        d: undefined,\n        s: this.s ?? 0n * d.s,\n        infinite: true,\n      });\n    }\n    if (isInfinite(d)) {\n      if (isFinite(this)) {\n        return ZERO;\n      } else {\n        return new DeciNumber({});\n      }\n    }\n    return binOp(this, d, Fraction.prototype.div);\n  }\n\n  private fractionPow(n: Fraction): Fraction {\n    return pow(this as unknown as Fraction, n);\n  }\n\n  pow(n: DeciNumber): DeciNumber {\n    return binOp(this, n, DeciNumber.prototype.fractionPow);\n  }\n\n  gcd(n: DeciNumber): DeciNumber {\n    return binOp(this, n, Fraction.prototype.gcd);\n  }\n\n  lcm(n: DeciNumber): DeciNumber {\n    return binOp(this, n, Fraction.prototype.lcm);\n  }\n\n  mod(n: DeciNumber | number): DeciNumber {\n    return binOp(this, n, Fraction.prototype.mod);\n  }\n\n  ceil(n?: number): DeciNumber {\n    return binOp(this, n, Fraction.prototype.ceil);\n  }\n\n  floor(n?: number): DeciNumber {\n    return binOp(this, n, Fraction.prototype.floor);\n  }\n\n  round(n?: number): DeciNumber {\n    return binOp(this, n, Fraction.prototype.round);\n  }\n\n  inverse(): DeciNumber {\n    return binOp(this, undefined, Fraction.prototype.inverse);\n  }\n\n  simplify(eps?: number): DeciNumber {\n    return binOp(this, eps, Fraction.prototype.simplify);\n  }\n\n  compare(that: DeciNumber): number {\n    const a = isFinite(this)\n      ? this\n      : ZERO.mul(\n          typeof this.s === 'number' || typeof this.s === 'bigint'\n            ? N(this.s)\n            : N(1)\n        );\n    const b = isFinite(that)\n      ? (that as Fraction)\n      : (ZERO as unknown as Fraction);\n\n    return Fraction.prototype.compare.call(a, b);\n  }\n\n  equals(that: DeciNumber): boolean {\n    if (isUndefined(this) || isUndefined(that)) {\n      return isUndefined(this) && isUndefined(that);\n    }\n    if (isInfinite(this) || isInfinite(that)) {\n      return (\n        (isInfinite(this) && isInfinite(that) && isSameInfinite(this, that)) ||\n        false\n      );\n    }\n    return Fraction.prototype.equals.call(this, that as unknown as Fraction);\n  }\n\n  divisible(that: DeciNumber): boolean {\n    return (\n      isFinite(this) &&\n      isFinite(that) &&\n      Fraction.prototype.divisible.call(this, that)\n    );\n  }\n\n  valueOf(): number {\n    if (isUndefined(this)) {\n      return NaN;\n    }\n    if (isInfinite(this)) {\n      if (this.s < 0) {\n        return -Infinity;\n      }\n      return Infinity;\n    }\n    return Fraction.prototype.valueOf.call(this);\n  }\n\n  toString(decimalPlaces?: number): string {\n    if (isUndefined(this)) {\n      return '?';\n    }\n    if (isInfinite(this)) {\n      return `${this.s < 0 ? '-' : ''}`;\n    }\n    return Fraction.prototype.toString.call(this, decimalPlaces);\n  }\n\n  toLatex(excludeWhole?: boolean): string {\n    if (isUndefined(this) || isInfinite(this)) {\n      return this.toString();\n    }\n    return Fraction.prototype.toLatex.call(this, excludeWhole);\n  }\n\n  toFraction(excludeWhole?: boolean): string {\n    if (isUndefined(this) || isInfinite(this)) {\n      return this.toString();\n    }\n    return Fraction.prototype.toFraction.call(this, excludeWhole);\n  }\n\n  toContinued(): number[] {\n    if (isUndefined(this)) {\n      return [];\n    }\n    if (isInfinite(this)) {\n      return [Number(this.s) * Infinity, 1];\n    }\n    return Fraction.prototype.toContinued.call(this);\n  }\n\n  clone(): DeciNumber {\n    return fromNumber(this);\n  }\n\n  isZero(): boolean {\n    return this.equals(ZERO);\n  }\n\n  static undefined() {\n    return UNDEFINED;\n  }\n\n  static infinite(s: -1 | 1 = 1) {\n    return N({ infinite: true, s });\n  }\n}\n\nexport const UNDEFINED = N(undefined);\nexport const ZERO = N(0);\nexport const ONE = N(1);\nexport const TWO = N(2);\n","import Fraction, { from } from '.';\n\nexport const isZero = (f: Fraction): boolean => {\n  return f.compare(0) === 0;\n};\n\nexport const pow = (a: Fraction, b: Fraction): Fraction => {\n  const result = Fraction.prototype.pow.call(a, b);\n  if (result == null || isZero(result)) {\n    const resultNumber = a.valueOf() ** b.valueOf();\n    if (Number.isNaN(resultNumber)) {\n      throw new TypeError(\n        `**: result of raising to ${b.toString()} is not rational`\n      );\n    }\n    return from(resultNumber);\n  }\n  return result;\n};\n","// eslint-disable-next-line no-restricted-imports\nimport { min as minFraction } from '@decipad/fraction';\nimport DeciNumber, { isFinite, isInfinite, isUndefined, N } from '.';\nimport { FiniteNumber } from './types';\n\nconst isNegativeInfinite = (n: DeciNumber) => isInfinite(n) && n.s < 0n;\n\nexport const min = (...ns: DeciNumber[]): DeciNumber => {\n  for (const n of ns) {\n    if (isUndefined(n)) {\n      return DeciNumber.undefined();\n    }\n    if (isNegativeInfinite(n)) {\n      return DeciNumber.infinite(-1);\n    }\n  }\n  return N(minFraction(...(ns.filter(isFinite) as unknown as FiniteNumber[])));\n};\n","// eslint-disable-next-line no-restricted-imports\nimport { max as maxFraction } from '@decipad/fraction';\nimport DeciNumber, { isFinite, isInfinite, isUndefined, N } from '.';\nimport { FiniteNumber } from './types';\n\nconst isPositiveInfinite = (n: DeciNumber) => isInfinite(n) && n.s < 0n;\n\nexport const max = (...ns: DeciNumber[]): DeciNumber => {\n  for (const n of ns) {\n    if (isUndefined(n)) {\n      return DeciNumber.undefined();\n    }\n    if (isPositiveInfinite(n)) {\n      return DeciNumber.infinite();\n    }\n  }\n  return N(maxFraction(...(ns.filter(isFinite) as unknown as FiniteNumber[])));\n};\n","import { DeciNumber } from './DeciNumber';\n\nexport default DeciNumber;\nexport * from './DeciNumber';\nexport * from './min';\nexport * from './max';\nexport * from './comparisons';\nexport type { DeciNumberInput } from './types';\n","import { CoercibleType } from './types';\n\nexport const coerceToBoolean = (text: string): string => {\n  switch (text.toLowerCase().trim()) {\n    case 'true':\n    case 'yes':\n      return 'true';\n    default:\n      return 'false';\n  }\n};\n\nexport const parseBoolean = (text: string): boolean => {\n  switch (text.toLowerCase()) {\n    case 'true':\n    case 'yes':\n      return true;\n  }\n  return false;\n};\n\nexport const inferBoolean = (text: string): CoercibleType | undefined => {\n  switch (text.toLowerCase()) {\n    case 'true':\n    case 'false':\n      return { type: { kind: 'boolean' }, coerced: coerceToBoolean(text) };\n  }\n  return undefined;\n};\n","import { Time } from '@decipad/computer';\nimport { parse } from 'date-fns';\nimport { DateFormat } from './types';\n\nconst granularityRank = new Map(\n  Object.entries({\n    year: 1,\n    month: 2,\n    day: 3,\n    hour: 4,\n    minute: 5,\n    second: 6,\n    millisecond: 6,\n  })\n) as Map<Time.Specificity, number>;\n\nexport const highestTimeSpecificity = (\n  ...gs: Time.Specificity[]\n): Time.Specificity | undefined => {\n  let highestG: Time.Specificity | undefined;\n  let highestGRank = -1;\n  for (const g of gs) {\n    const thisRank = granularityRank.get(g);\n    if (thisRank && thisRank > highestGRank) {\n      highestGRank = thisRank;\n      highestG = g;\n    }\n  }\n  return highestG;\n};\n\nconst isValidDate = (d: Date | undefined): d is Date => {\n  return d != null && !Number.isNaN(d.valueOf());\n};\n\nconst combineFormats = (a: string[], b: string[]): string[] => {\n  const formats: string[] = [];\n  for (const aElem of a) {\n    for (const bElem of b) {\n      formats.push(`${aElem} ${bElem}`);\n    }\n  }\n  return formats;\n};\n\n// Format strings reference:\n// https://date-fns.org/v2.25.0/docs/format\nconst dayFormats = [\n  'dd-MM-yyyy',\n  'yyyy-MM-dd',\n  'dd/MM/yyyy',\n  'yyyy/MM/dd',\n  'P',\n  'PP',\n  'PPP',\n];\nconst minuteFormats = ['HH:mm', 'HHmm', 'h:m aaa', 'hh:mm aaa', 'hhmm aaa'];\nconst secondFormats = ['s', 'ss'];\nconst fractionSecondsFormats = ['S', 'SS', 'SSS', 'SSSS'];\nexport const dateFormats: Record<Time.Specificity, DateFormat[]> = {\n  year: ['yy', 'yyyy'],\n  month: [\n    'yyyy-MM',\n    'MM-yyyy',\n    'yyyy/MM',\n    'MM/yyyy',\n    'MMM yyyy',\n    'MMMM yyyy',\n    'MMM/yyyy',\n    'MMMM/yyyy',\n    'MMM-yyyy',\n    'MMMM-yyyy',\n  ],\n  day: dayFormats,\n  hour: combineFormats(dayFormats, ['HH']),\n  minute: combineFormats(dayFormats, minuteFormats),\n  second: combineFormats(\n    combineFormats(dayFormats, minuteFormats),\n    secondFormats\n  ),\n  millisecond: combineFormats(\n    combineFormats(combineFormats(dayFormats, minuteFormats), secondFormats),\n    fractionSecondsFormats\n  ),\n};\n\nconst dateFormatsForSpecificity = (\n  specificity: Time.Specificity\n): Record<Time.Specificity, string[]> => {\n  return Object.fromEntries(\n    Object.entries(dateFormats).filter(([s]) => specificity === s)\n  ) as Record<Time.Specificity, DateFormat[]>;\n};\n\ninterface ParseDateResult {\n  format: string;\n  specificity: Time.Specificity;\n  date: Date;\n}\n\nexport const parseDate = (\n  value: string,\n  specificity?: Time.Specificity,\n  allowedFormats?: string[]\n): ParseDateResult | undefined => {\n  const formats =\n    allowedFormats && specificity\n      ? {\n          [specificity]: allowedFormats,\n        }\n      : specificity\n      ? dateFormatsForSpecificity(specificity)\n      : dateFormats;\n  for (const spec of Object.keys(formats) as Array<Time.Specificity>) {\n    const formatStrings = formats[spec];\n    for (const format of formatStrings) {\n      const date = parse(value, format, new Date());\n      if (isValidDate(date)) {\n        return {\n          format,\n          specificity: spec,\n          date,\n        };\n      }\n    }\n  }\n  return undefined;\n};\n","import { format as formatDate, isValid } from 'date-fns';\nimport { Time } from '@decipad/computer';\nimport { parseDate } from './parseDate';\nimport { CoercibleType, DateGranularity } from './types';\n\nexport const coerceToDate = (\n  d: Date,\n  specificity: Time.Specificity\n): string => {\n  if (!isValid(d)) {\n    throw new Error('invalid date');\n  }\n  switch (specificity) {\n    case 'year':\n      return `date(${formatDate(d, 'yyyy')})`;\n    case 'month':\n      return `date(${formatDate(d, 'yyyy-MM')})`;\n    case 'day':\n      return `date(${formatDate(d, 'yyyy-MM-dd')})`;\n    case 'hour':\n      return `date(${formatDate(d, 'yyyy-MM-dd HH')})`;\n    case 'minute':\n      return `date(${formatDate(d, 'yyyy-MM-dd HH:mm')})`;\n    default:\n      return `date(${formatDate(d, 'yyyy-MM-dd HH:mm:ss')})`;\n  }\n};\n\nexport const inferDate = (\n  text: string,\n  granularity?: DateGranularity,\n  allowedFormats?: string[]\n): CoercibleType | undefined => {\n  const parsed = parseDate(text, granularity, allowedFormats);\n  if (parsed) {\n    return {\n      type: {\n        kind: 'date',\n        date: parsed.specificity,\n      },\n      coerced: coerceToDate(parsed.date, parsed.specificity),\n    };\n  }\n  return undefined;\n};\n","import { Computer, parseExpressionOrThrow } from '@decipad/computer';\nimport { CoercibleType } from './types';\n\nexport const inferExpression = async (\n  computer: Computer,\n  text: string\n): Promise<CoercibleType | undefined> => {\n  try {\n    const parsed = parseExpressionOrThrow(text);\n    const type = await computer.expressionType(parsed);\n    if (parsed.type !== 'noop') {\n      return {\n        type,\n        coerced: text,\n      };\n    }\n  } catch {\n    // Parse error\n  }\n  return undefined;\n};\n","import { CoercibleType } from './types';\n\nconst coerceToString = (text: string): string => {\n  return JSON.stringify(text);\n};\n\nexport const inferText = (text: string): CoercibleType => {\n  return {\n    type: {\n      kind: 'string',\n    },\n    coerced: coerceToString(text),\n  };\n};\n","import { Computer, parseExpressionOrThrow } from '@decipad/computer';\nimport { containsNumber } from '@decipad/utils';\nimport { CoercibleType } from './types';\n\ninterface InferNumberOptions {\n  doNotTryExpressionNumbersParse?: boolean;\n}\n\nconst inferPlainNumber = (text: string): CoercibleType | undefined => {\n  const n = Number(text);\n  if (Number.isNaN(n)) {\n    return undefined;\n  }\n  return {\n    type: { kind: 'number', unit: null },\n    coerced: text,\n  };\n};\n\nexport const inferNumber = async (\n  computer: Computer,\n  text: string,\n  options: InferNumberOptions = {}\n): Promise<CoercibleType | undefined> => {\n  if (options.doNotTryExpressionNumbersParse) {\n    return inferPlainNumber(text);\n  }\n  if (containsNumber(text)) {\n    try {\n      const exp = parseExpressionOrThrow(text);\n      const type = await computer.expressionType(exp);\n      if ((await type).kind === 'number') {\n        return {\n          type,\n          coerced: text,\n        };\n      }\n    } catch (err) {\n      // do nothing\n    }\n  }\n\n  return undefined;\n};\n","import type { Computer, SerializedType } from '@decipad/computer';\nimport { containsNumber } from '@decipad/utils';\nimport { CoercibleType } from './types';\nimport { inferBoolean } from './inferBoolean';\nimport { inferDate } from './inferDate';\nimport { inferExpression } from './inferExpression';\nimport { inferText } from './inferText';\nimport { inferNumber } from './inferNumber';\n\nconst inferParseError = (\n  text: string,\n  kind?: SerializedType['kind']\n): CoercibleType => ({\n  type: {\n    kind: 'type-error',\n    errorCause: {\n      errType: 'free-form',\n      message: kind\n        ? `Cannot parse ${kind} out of \"${text}\"`\n        : `Cannot parse \"${text}\"`,\n    },\n  },\n  coerced: text,\n});\n\ninterface InferTypeOptions {\n  type?: SerializedType;\n  doNotTryExpressionNumbersParse?: boolean;\n}\n\nconst tryInferChain = async (\n  computer: Computer,\n  text: string,\n  options: InferTypeOptions\n): Promise<CoercibleType> => {\n  let inferResult = inferDate(text, 'month') ??\n    inferDate(text, 'day') ??\n    inferBoolean(text) ??\n    (await inferNumber(computer, text, options)) ??\n    inferDate(text) ??\n    (options.doNotTryExpressionNumbersParse\n      ? undefined\n      : await inferExpression(computer, text)) ?? {\n      type: { kind: 'string' },\n      coerced: text,\n    };\n\n  if (inferResult.type.kind === 'number' && !containsNumber(text)) {\n    inferResult = {\n      type: { kind: 'string' },\n      coerced: text,\n    };\n  }\n  return inferResult;\n};\n\nexport const inferType = async (\n  computer: Computer,\n  _text: string,\n  options: InferTypeOptions = {}\n): Promise<CoercibleType> => {\n  const text = _text.trim();\n\n  const { type } = options;\n\n  switch (type?.kind) {\n    case 'boolean':\n      return inferBoolean(text) ?? inferParseError(text, type.kind);\n    case 'date':\n      return inferDate(text) ?? inferParseError(text, type.kind);\n    case 'number':\n      return (\n        (await inferNumber(computer, text, options)) ??\n        inferParseError(text, type.kind)\n      );\n    case 'string':\n      return inferText(text) ?? inferParseError(text, type.kind);\n    case 'anything':\n    case 'nothing':\n    case undefined: {\n      if (!text) {\n        return { type: { kind: 'anything' }, coerced: text };\n      }\n      return tryInferChain(computer, text, options);\n    }\n    default:\n      return { type: type ?? inferParseError(text) } as CoercibleType;\n  }\n};\n","import { Computer } from '@decipad/computer';\nimport { dequal } from 'dequal';\nimport mMemoize from 'micro-memoize';\n\nconst memoizeParams = {\n  isEqual: (a: unknown, b: unknown) => {\n    if (a instanceof Computer && b instanceof Computer) {\n      return a === b;\n    }\n    return dequal(a, b);\n  },\n  maxSize: 10000,\n};\n\nexport const memoize: typeof mMemoize = (fn, params) =>\n  mMemoize(fn, { ...memoizeParams, ...params });\n","import {\n  areUnitsConvertible,\n  Computer,\n  SerializedTypes,\n} from '@decipad/computer';\nimport { CellValueType } from '@decipad/editor-types';\nimport { containsNumber } from '@decipad/utils';\nimport { inferType } from '.';\nimport { highestTimeSpecificity } from './parseDate';\nimport { SpreadsheetColumn } from './types';\nimport { memoize } from './utils/memoize';\n\ninterface InferColumnOptions {\n  userType?: CellValueType;\n  doNotTryExpressionNumbersParse?: boolean;\n}\n\nconst INFER_MAX_ROWS = 100;\n\nexport const inferColumn = memoize(\n  async (\n    computer: Computer,\n    column: SpreadsheetColumn,\n    options: InferColumnOptions = {}\n  ): Promise<CellValueType> => {\n    let lastType: CellValueType | undefined = options.userType;\n\n    if (lastType && lastType?.kind !== 'anything') {\n      return lastType;\n    }\n\n    const coalesce = (_newType: CellValueType) => {\n      const newType =\n        _newType.kind === 'type-error'\n          ? ({ kind: 'string' } as SerializedTypes.String)\n          : _newType;\n      if (newType.kind === 'anything' || newType.kind === 'nothing') {\n        return;\n      }\n      if (\n        !lastType ||\n        lastType.kind === 'anything' ||\n        lastType.kind === 'nothing'\n      ) {\n        lastType = newType;\n      } else if (newType.kind !== lastType.kind) {\n        // inconsistent column type: default to string\n        lastType = { kind: 'string' };\n      } else if (newType.kind === 'date') {\n        const lastDateType = lastType as SerializedTypes.Date;\n        if (newType.date !== lastDateType.date) {\n          const newGranularity = highestTimeSpecificity(\n            lastDateType.date,\n            newType.date\n          );\n          if (newGranularity) {\n            lastType = {\n              kind: 'date',\n              date: newGranularity,\n            };\n          }\n        }\n      } else if (newType.kind === 'number') {\n        if (lastType.kind !== 'number') {\n          lastType = {\n            kind: 'string',\n          };\n        } else if (!lastType.unit && newType.unit) {\n          lastType = newType;\n        } else if (\n          newType.unit &&\n          lastType.unit &&\n          !areUnitsConvertible(newType.unit, lastType.unit)\n        ) {\n          lastType = { kind: 'string' };\n        }\n      }\n    };\n\n    for (const value of column.slice(0, INFER_MAX_ROWS)) {\n      switch (typeof value) {\n        case 'boolean':\n          coalesce({ kind: 'boolean' });\n          break;\n        case 'number':\n          if (typeof value === 'string' && !containsNumber(value)) {\n            coalesce({ kind: 'string' });\n          } else {\n            coalesce({ kind: 'number', unit: null });\n          }\n          break;\n        case 'string': {\n          // eslint-disable-next-line no-await-in-loop\n          const inferredType = await inferType(computer, value, options);\n          coalesce(inferredType.type);\n          break;\n        }\n        case 'undefined':\n        case 'object': // null\n          if (value == null) {\n            coalesce({ kind: 'nothing' });\n          }\n          break;\n        default:\n          throw new Error(`Unexpected type of value: ${typeof value}`);\n      }\n    }\n\n    return lastType ?? { kind: 'string' };\n  },\n  { maxSize: 1000 }\n);\n","const base = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\nconst baseSize = base.length;\n\nexport function columnNameFromIndex(index: number): string {\n  const oneDigitIndex = index % base.length;\n  const name = base[oneDigitIndex];\n  if (index >= baseSize) {\n    const carry = Math.floor(index / baseSize) - 1;\n    return columnNameFromIndex(carry) + name;\n  }\n  return name;\n}\n","import DeciNumber, { N, ZERO } from '@decipad/number';\n\nconst toNumber = (n: number | bigint | string): bigint | number | undefined => {\n  if (typeof n === 'number' || typeof n === 'bigint') {\n    return n;\n  }\n  const res = Number(n.replaceAll(/[^.0-9]/g, ''));\n  if (Number.isNaN(res)) {\n    // eslint-disable-next-line no-console\n    console.warn(`\"${res}\" was not parsable to a number`);\n    return undefined;\n  }\n  return res;\n};\n\nconst countDecimals = (\n  _n: number | bigint | string\n): [number, string | undefined] => {\n  const n = toNumber(_n);\n  if (n == null) {\n    return [0, undefined];\n  }\n  if (Math.floor(Number(n.valueOf())) === Number(n.valueOf()))\n    return [0, undefined];\n  const str = n.toString(10);\n  if (str.indexOf('e') >= 0) {\n    const parts = str.split('e');\n    const [moreDecimals, fullNumber] = countDecimals(Number(parts[0]));\n    return [-Number(parts[1]) + moreDecimals, fullNumber];\n  }\n  const parts = str.split('.');\n  return [parts[1]?.length || 0, parts.join('')];\n};\n\nexport const fastNumber = (n: number | string): DeciNumber => {\n  if (typeof n === 'string' && n.length < 1) {\n    return ZERO;\n  }\n  const [decimalCount, fullNumber] = countDecimals(n);\n  try {\n    if (typeof fullNumber === 'string' && fullNumber.length < 1) {\n      return ZERO;\n    }\n    return decimalCount === 0\n      ? N(toNumber(n))\n      : N(toNumber(fullNumber ?? ''), BigInt(10 ** decimalCount));\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'Error trying to convert to number',\n      n,\n      [decimalCount, fullNumber],\n      err\n    );\n    throw err;\n  }\n};\n","import type { Computer, Result, SerializedType } from '@decipad/computer';\nimport { varNamify } from '@decipad/utils';\nimport { columnNameFromIndex } from './columnNameFromIndex';\nimport { inferColumn } from './inferColumn';\nimport { parseDate } from './parseDate';\nimport { Sheet, SpreadsheetColumn, InferTableOptions } from './types';\nimport { fastNumber } from './fastNumber';\n\ninterface WithColumnNamesResult {\n  columnNames: string[];\n  columnValues: Sheet['values'];\n}\n\nconst withColumnNames = (\n  data: Sheet,\n  options: InferTableOptions\n): WithColumnNamesResult => {\n  if (options.useFirstRowAsHeader) {\n    return {\n      columnNames: data.values.map((column) =>\n        varNamify((column[0] ?? '_').toString())\n      ),\n      columnValues: data.values.map((column) => column.slice(1)),\n    };\n  }\n  return {\n    columnNames: data.values.map((_, i) => columnNameFromIndex(i)),\n    columnValues: data.values,\n  };\n};\n\nfunction toValue(\n  columnTypes: SerializedType[],\n  columnValues: SpreadsheetColumn[]\n): Result.OneResult[][] {\n  return columnValues.map((col, colIndex) => {\n    const type = columnTypes[colIndex];\n    return col.map((elem) => {\n      switch (type?.kind) {\n        case 'number':\n          return fastNumber(elem as number | string);\n        case 'date':\n          return BigInt(parseDate(elem as string)?.date.getTime() ?? 0);\n        case 'string':\n          return (elem as string) ?? '';\n        default:\n          return elem.toString();\n      }\n    });\n  });\n}\n\nexport const inferTable = async (\n  computer: Computer,\n  data: Sheet,\n  options: InferTableOptions\n): Promise<Result.Result<'table'>> => {\n  const { columnNames, columnValues } = withColumnNames(data, options);\n  const columnTypes = await Promise.all(\n    columnValues.map(\n      async (col, colIndex): Promise<SerializedType> =>\n        (options.columnTypeCoercions?.[colIndex] as SerializedType) ??\n        inferColumn(computer, col, {\n          doNotTryExpressionNumbersParse:\n            options.doNotTryExpressionNumbersParse,\n          userType: options.columnTypeCoercions?.[colIndex],\n        })\n    )\n  );\n  return {\n    type: {\n      kind: 'table',\n      columnTypes,\n      columnNames,\n      indexName: columnNames[0],\n    },\n    value: toValue(columnTypes, columnValues),\n  };\n};\n","// Need this retval ambiguity for the typings to adapt to every kind of AST.Node\n\nimport type { AST } from '@decipad/computer';\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const astNode = <\n  T extends AST.Node['type'],\n  RetNode extends Extract<AST.Node, { type: T }>\n>(\n  type: T,\n  ...args: RetNode['args']\n) => ({ type, args } as RetNode);\n\nexport const astColumn = (...items: AST.Expression[]): AST.Column =>\n  astNode('column', astNode('column-items', ...items));\n","import { AST } from '@decipad/computer';\nimport { CellValueType } from '@decipad/editor-types';\nimport { astNode } from './astNode';\n\nexport const dateToAST = (cellType: CellValueType, asDate: Date) => {\n  const parts: AST.Date['args'] = [];\n\n  (() => {\n    parts.push('year', BigInt(asDate.getUTCFullYear()));\n    if (cellType.kind === 'date' && cellType.date === 'year') return;\n\n    parts.push('month', BigInt(asDate.getUTCMonth() + 1));\n    if (cellType.kind === 'date' && cellType.date === 'month') return;\n\n    parts.push('day', BigInt(asDate.getUTCDate()));\n    if (cellType.kind === 'date' && cellType.date === 'day') return;\n\n    parts.push('hour', BigInt(asDate.getUTCHours()));\n    parts.push('minute', BigInt(asDate.getUTCMinutes()));\n  })();\n\n  return astNode('date', ...parts);\n};\n","import { CellValueType, TableCellType } from '@decipad/editor-types';\nimport DeciNumber, { N, ZERO } from '@decipad/number';\nimport {\n  AST,\n  Computer,\n  areUnitsConvertible,\n  convertBetweenUnits,\n  convertToMultiplierUnit,\n  Result,\n  Unit,\n  SerializedType,\n  parseStatement,\n  isExpression,\n} from '@decipad/computer';\nimport { formatUnit, formatError } from '@decipad/format';\nimport { containsNumber } from '@decipad/utils';\nimport { astNode } from './utils/astNode';\nimport { dateToAST } from './utils/dateToAST';\nimport { unitToAST } from './utils/unitToAST';\nimport { inferType } from './inferType';\nimport { memoize } from './utils/memoize';\n\ntype ParseCellResult = Promise<AST.Expression | Error | null>;\n\nconst defaultLocale = 'en-US'; // TODO: make this dynamic\n\nconst parsing = async (\n  computer: Computer,\n  type: SerializedType,\n  text: string,\n  afterParse: (result: Result.Result) => ParseCellResult\n): Promise<ParseCellResult> => {\n  const inferred = await inferType(computer, text, { type });\n  if (inferred.type.kind === 'type-error') {\n    return new Error(formatError(defaultLocale, inferred.type.errorCause));\n  }\n  if (!inferred.coerced) {\n    return null;\n  }\n  const parseResult = parseStatement(inferred.coerced);\n  if (parseResult.error) {\n    return new Error(parseResult.error.message);\n  }\n  if (!parseResult.solution || !isExpression(parseResult.solution)) {\n    return new Error('is not a valid expression');\n  }\n\n  /** This comes from the need to get a percentage number.\n   * If we have `10` as a percentage,previously we had `1000%`.\n   * However,we would prefer to have 10%\n   * Hence the division\n   */\n  if (\n    parseResult.solution.type === 'literal' &&\n    type.kind === 'number' &&\n    type.numberFormat === 'percentage' &&\n    parseResult.solution.args[0] === 'number' &&\n    parseResult.solution.args[2] !== 'percentage'\n  ) {\n    parseResult.solution.args[2] = 'percentage';\n    parseResult.solution.args[1] = parseResult.solution.args[1].div(N('100'));\n  }\n\n  let result = await computer.expressionResult(parseResult.solution);\n  if (result.type.kind === 'type-error') {\n    return new Error(formatError(defaultLocale, result.type.errorCause));\n  }\n  if (type.kind && type.kind !== 'anything' && type.kind !== result.type.kind) {\n    return new Error(`Could not parse \"${text}\" into a ${type.kind}`);\n  }\n  if (result.type.kind === 'number' && !containsNumber(text)) {\n    result = {\n      type: { kind: 'string' },\n      value: text,\n    };\n  }\n\n  try {\n    return afterParse(result);\n  } catch (err) {\n    return err as Error;\n  }\n};\n\nconst fixCellUnit = (unit: Unit[]): Unit[] => {\n  return unit.map((u): Unit => {\n    return {\n      ...u,\n      multiplier: N(u.multiplier),\n      exp: N(u.exp),\n    };\n  });\n};\n\nexport function assertCellType<Kind extends CellValueType['kind']>(\n  type: CellValueType,\n  kind: Kind\n): asserts type is Extract<TableCellType, { kind: Kind }> {\n  if (type.kind && type.kind !== kind) {\n    throw new Error(`Expected input of type ${kind}`);\n  }\n}\n\nexport const parseCell = memoize(\n  async (\n    computer: Computer,\n    cellType: CellValueType,\n    text: string\n  ): Promise<AST.Expression | Error | null> => {\n    if (\n      cellType.kind === 'table-formula' ||\n      cellType.kind === 'series' ||\n      cellType.kind === 'dropdown' ||\n      !text.trim()\n    ) {\n      return null;\n    }\n    try {\n      return await parsing(\n        computer,\n        cellType,\n        text,\n        async (result: Result.Result) => {\n          const { type } = result;\n          switch (type.kind) {\n            case 'number': {\n              assertCellType(cellType, 'number');\n              if (!cellType.unit && type.unit) {\n                return new Error('unexpected unit in number');\n              }\n              const cellUnit = cellType.unit && fixCellUnit(cellType.unit);\n              if (type.unit && cellUnit) {\n                if (!areUnitsConvertible(type.unit, cellUnit)) {\n                  return new Error(\n                    `cannot convert ${formatUnit(\n                      'en-US',\n                      type.unit\n                    )} to ${formatUnit('en-US', cellUnit)} `\n                  );\n                }\n                // eslint-disable-next-line no-param-reassign\n                result.value = convertToMultiplierUnit(\n                  convertBetweenUnits(\n                    result.value as DeciNumber,\n                    type.unit,\n                    cellUnit\n                  ),\n                  cellUnit\n                );\n              }\n\n              if (type.numberFormat) {\n                return astNode(\n                  'literal',\n                  'number' as const,\n                  N(result.value as DeciNumber),\n                  type.numberFormat\n                );\n              }\n\n              const literal = astNode(\n                'literal',\n                'number' as const,\n                N(result.value as DeciNumber)\n              );\n              const unit = unitToAST(cellUnit);\n\n              if (unit == null) {\n                return literal;\n              }\n\n              return astNode(\n                'function-call',\n                astNode('funcref', 'implicit*'),\n                astNode('argument-list', literal, unit)\n              ) as AST.Expression;\n            }\n            case 'date':\n              return dateToAST(cellType, new Date(Number(result.value)));\n\n            case 'boolean':\n              return astNode(\n                'literal',\n                'boolean',\n                text === 'true' || text === 'yes'\n              );\n\n            case 'string':\n              return astNode('literal', 'string', text);\n          }\n          return new Error(\n            `Could not parse a ${cellType.kind} out of \"${text}\"`\n          );\n        }\n      );\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('error parsing cell:', err);\n      throw err;\n    }\n  }\n);\n\nexport const getExpression = (exp: Error | AST.Expression): AST.Expression => {\n  if (exp instanceof Error) {\n    throw exp;\n  }\n  return exp;\n};\n\nexport const getNullReplacementValue = (\n  cellType: CellValueType\n): AST.Expression => {\n  if (cellType.kind === 'date') {\n    return dateToAST(cellType, new Date('2020-01-01'));\n  }\n  if (cellType.kind === 'number') {\n    return astNode('literal', 'number', ZERO);\n  }\n  if (cellType.kind === 'boolean') {\n    return astNode('literal', 'boolean', false);\n  }\n  if (cellType.kind === 'dropdown' && cellType.type === 'number') {\n    return astNode('literal', 'number', ZERO);\n  }\n  return astNode('literal', 'string', '');\n};\n","import { simpleFormatUnit } from '@decipad/format';\nimport { AST, parseBlock } from '@decipad/computer';\nimport { TableCellType } from '@decipad/editor-types';\n\nexport const unitToAST = (\n  unit: Extract<TableCellType, { kind: 'number' }>['unit']\n): AST.Expression | null => {\n  if (unit == null) {\n    return null;\n  }\n\n  // NOTE: seems more error prone to generate an AST from the Units object than to stringify the\n  // units back to the language and parse the AST.\n  const formattedUnit = simpleFormatUnit(unit);\n  const ast = parseBlock(formattedUnit).solution;\n  return ast && ast.args.length > 0 ? (ast.args[0] as AST.Expression) : null;\n};\n","import { Result, Time } from '@decipad/computer';\nimport { SeriesType } from '@decipad/editor-types';\nimport { parseDate } from './parseDate';\n\nexport interface ParseSeriesStartResult {\n  error?: string;\n  type: SeriesType;\n  granularity?: Time.Specificity; // we'll use a union type when we add more series types\n  value?: Result.OneResult;\n}\n\nexport const parseSeriesStart = (\n  type: SeriesType,\n  content: string\n): ParseSeriesStartResult => {\n  switch (type) {\n    case 'date': {\n      const parsedDate = parseDate(content);\n      if (!parsedDate) {\n        return {\n          type,\n          error: 'Could not parse date',\n        };\n      }\n      // no parsing resulted\n      // let's return the last error\n      return {\n        type,\n        granularity: parsedDate.specificity,\n        value: BigInt(parsedDate.date.getTime()),\n      };\n    }\n    default:\n      throw new Error(`unknown series type ${type}`);\n  }\n};\n","import { SeriesType } from '@decipad/editor-types';\nimport { Time } from '@decipad/computer';\nimport { add as addDate, Duration, format as formatDate } from 'date-fns';\nimport { parseDate } from './parseDate';\n\nconst dateGranularityToDateFnsDuration: Record<Time.Specificity, Duration> = {\n  year: { years: 1 },\n  month: { months: 1 },\n  day: { days: 1 },\n  hour: { hours: 1 },\n  minute: { minutes: 1 },\n  second: { seconds: 1 },\n  millisecond: { seconds: 0.001 },\n};\n\nexport const dateIterator = (\n  granularity: Time.Specificity,\n  initialValue: string\n): Iterator<string> => {\n  const parseResult = parseDate(initialValue, granularity);\n  if (!parseResult) {\n    throw new Error(`Could not parse date ${initialValue}`);\n  }\n  const { format } = parseResult;\n  let v: Date = parseResult.date;\n  const g = dateGranularityToDateFnsDuration[granularity];\n  return {\n    next() {\n      v = addDate(v, g);\n      return {\n        value: formatDate(v, format),\n      };\n    },\n  };\n};\n\nexport const seriesIterator = (\n  type: SeriesType,\n  granularity: Time.Specificity,\n  initialValue: string\n): Iterator<string> => {\n  if (granularity == null) {\n    throw new Error('Date series requires granularity');\n  }\n  switch (type) {\n    case 'date':\n      return dateIterator(granularity, initialValue);\n  }\n};\n","export type AnyMapping<T> =\n  | Map<string, T>\n  | { [key: string]: T }\n  | Array<[key: string, val: T]>;\n\nexport const anyMappingToMap = <T>(mapping: AnyMapping<T>): Map<string, T> => {\n  if (mapping instanceof Map || Array.isArray(mapping)) {\n    return new Map(mapping);\n  }\n  return new Map(Object.entries(mapping));\n};\n","export const containsNumber = (text: string): boolean => !!text.match(/[0-9]+/);\n","export function getDefined<T>(\n  o: T | null | undefined | void,\n  message = 'is not defined'\n): T {\n  if (o == null) {\n    throw new TypeError(message);\n  }\n  return o;\n}\n","/** Return the only item in the array. Crashes if it has zero items, or more than 1 */\nexport function getOnly<T>(array: T[], message?: string): T {\n  if (array.length !== 1) {\n    throw new TypeError(\n      message ??\n        `panic: getOnly() expected an array with a single item, got ${array.length}`\n    );\n  }\n  return array[0];\n}\n","export const identity = <T>(value: T): T => value;\n","export const lenientZip = <K, V>(\n  keys: K[],\n  values: V[]\n): [K | undefined, V | undefined][] => {\n  const out = [];\n\n  for (let i = 0; i < keys.length; i += 1) {\n    const pair: [K, V] = [keys[i], values[i]];\n    out.push(pair);\n  }\n\n  return out;\n};\n","/**\n * Memoize a function using a Map\n *\n * The first parameter is used as the key of the Map\n */\nexport function memoizePrimitive<Key, Args extends unknown[], Ret>(\n  func: (k: Key, ...a: Args) => Ret\n): typeof func {\n  const cache = new Map<Key, Ret>();\n\n  return (key, ...args) => {\n    if (cache.has(key)) {\n      return cache.get(key) as Ret;\n    }\n    const value = func(key, ...args);\n\n    cache.set(key, value);\n\n    return value;\n  };\n}\n","export function thro(error: Error | string): never {\n  if (typeof error === 'string') {\n    throw new Error(error);\n  }\n  throw error;\n}\n","export function unique<T>(from: Iterable<T>): Array<T> {\n  return Array.from(new Set(from));\n}\n","export const unzip = <K, V>(arg: Iterable<[K, V]>): [K[], V[]] => {\n  const keys: K[] = [];\n  const values: V[] = [];\n\n  for (const [k, v] of arg) {\n    keys.push(k);\n    values.push(v);\n  }\n  return [keys, values];\n};\n","import { camelCase } from 'lodash';\n\nconst capitalize = (str: string): string =>\n  (str[0]?.toUpperCase() ?? '') + str.slice(1);\n\nexport const varNamify = (text: string): string =>\n  capitalize(camelCase(text.replaceAll(' ', '_')));\n","import { lenientZip } from './lenient-zip';\n\nexport const zip = <K, V>(keys: K[], values: V[]): [K, V][] => {\n  if (keys.length !== values.length) {\n    throw new Error('panic: cannot zip arrays of different lengths');\n  }\n\n  return lenientZip(keys, values) as [K, V][];\n};\n","import { once } from 'ramda';\n\nexport function toJSON(this: bigint): string {\n  return this.toString();\n}\n\nexport const supportBigIntToJSON = once(() => {\n  (BigInt.prototype as unknown as { toJSON: () => string }).toJSON = toJSON;\n});\n","module.exports = require(\"buffer\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"path\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"process\");","module.exports = require(\"punycode\");","module.exports = require(\"stream\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [5151,2513,7350,9314], () => (__webpack_require__(96206)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"2513\":\"c96caaff\",\"3321\":\"a7706e63\",\"5151\":\"0d79bbbb\",\"6896\":\"82550df3\",\"7082\":\"8c9fd82c\",\"7350\":\"41baa7e8\",\"7872\":\"0cd9dd2a\",\"9306\":\"eace2a0a\",\"9314\":\"f0f0b16d\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","__webpack_require__.nc = undefined;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"loaded\", otherwise not loaded yet\nvar installedChunks = {\n\t5169: 1\n};\n\n__webpack_require__.O.require = (chunkId) => (installedChunks[chunkId]);\n\nvar installChunk = (chunk) => {\n\tvar moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\tfor(var i = 0; i < chunkIds.length; i++)\n\t\tinstalledChunks[chunkIds[i]] = 1;\n\t__webpack_require__.O();\n};\n\n// require() chunk loading for javascript\n__webpack_require__.f.require = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\tinstallChunk(require(\"../../\" + __webpack_require__.u(chunkId)));\n\t\t} else installedChunks[chunkId] = 1;\n\t}\n};\n\n// no external install chunk\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\t__webpack_require__.e(5151);\n\t__webpack_require__.e(2513);\n\t__webpack_require__.e(7350);\n\t__webpack_require__.e(9314);\n\treturn next();\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["replaceExprRefsWithPrettyRefs","program","autoAssigned","map","produce","block","type","stats","args","isExpression","decilang","name","getExprRef","id","getIdentifierString","trim","plainExpressionsToAssignments","renamed","generatedNames","tableColumnsBySmartRef","genVarName","makeVarNameLookup","Set","mutateAst","thing","isIdentifier","varName","isExprRef","asTableDotColumn","get","newName","wasGenerated","add","replaceAllBlockIdReferences","Map","flatMap","columnAssign","table","column","asPropertyAccess","mapExprRefsToColumnAccess","idsToPretty","prettyToIds","exprRef","symbol","getDefinedSymbol","set","mapOfSetsAdd","gatherAllVarNames","i","memoizePrimitive","asBlockRef","assertIsExprRef","prettyName","size","prefix","replace","proposal","mapKey","addedValue","blockId","startsWith","Error","getSymbolOrColumn","stat","captureExceptionFn","captureException","error","test","console","computeStatement","async","realm","cachedResult","getFromCache","value","getDefined","result","statement","getStatement","inferContext","statementId","valueType","usedNames","inferWhileRetrievingNames","errorCause","functionness","interpreterRealm","evaluateStatement","validateResult","getData","variableName","undefined","stack","serializeResult","visibleVariables","index","findIndex","length","global","local","localSymbol","globalVars","localVars","sym","columnNames","col","getVisibleVariables","resultFromError","message","RuntimeError","t","ctx","inferStatement","programDependencies","computer","allVarNames","varNames","blockIds","getBlockIdResult$","find","p","getDefinedSymbols","forEach","push","programDependencyGraph","usedInBlockId","at","ns","filter","has","inBlockId","a","currentName","allMatchingVarName","obj","blockInfo","blocksInUse","blocksInUseForBlockIds","concat","listenerHelper","subject","select","rootSubscribe","callback","sub","subscribe","unsubscribe","rootGet","getValue","useWithSelector","pick","useSyncExternalStoreWithSelector","item","dequal","observe","pipe","distinctUntilChanged","cur","next","observeWithSelector","use","identity","astToParseable","ast","depth","ident","exp","ret","kind","utcDate","granularity","getDateFromAstForm","dateStr","stringifyDate","dateGranularity","fname","funArgs","left","right","getDependents","dependentsOf","initialSymbols","secondPass","dependents","dependencySymbols","getSymbolsDefinedInBlocks","iterProgram","stmt","findSymbolsUsed","some","s","previousRefSymbols","tableNames","getTablesInBlockIds","checkSymbols","blockIdsToCheck","tables","getChangedMapKeys","oldMap","newMap","allKeys","Array","from","keys","key","oldVal","newVal","mapify","blocks","b","getChangedBlocks","oldBlocks","newBlocks","findSymbolErrors","reassigned","maybeUsedBeforeDef","seenDefinitions","usedSym","usedBeforeDef","setIntersection","findSymbolsAffectedByChange","changedBlockIds","codeWhichChanged","getAllSymbolsDefined","ComputationRealm","makeInferContext","Realm","this","setExternalData","externalData","evictCache","rest","loc","errorLocs","evictStatement","oldExternalData","newExternalData","dirtyLocs","getExistingBlockIds","dirtySymbols","dependentsOfBlocksAndSymbols","dep","getStatementsToEvict","delete","locCache","functions","functionDefinitions","getIndexLabels","labels","addLabels","cellType","data","String","date","d","globalVariables","entries","Table","columns","columnTypes","isColumnLike","addToCache","deduplicateColumnResults","acc","existsPos","existingCol","tableName","columnName","splice","defaultComputerResults","blockResults","indexLabels","dependencies","initialNode","namespaces","unique","node","localNames","getLocalNames","localTableName","findRefs","slice","allPossiblePropertyAccesses","funcName","argList","body","argNames","externalBodyDeps","includes","where","assignee","blocksToStatements","blocksOrStmts","getTableColNames","colDef","nodeOrBlock","names","badBlock","goodBlock","blockEntity","isAssignment","arg0","blockToNode","entity","temporaryMark","permanentMark","drawEdges","allNodes","edges","Boolean","notSelf","identifiedErrorFromNode","errorKind","topologicalSort","errored","sorted","goodBlocks","nodes","identifiersToNode","reduce","existing","visit","n","errorNode","edge","depNamespaces","namespaceAdd","nsName","toAdd","colName","findAllTables","Computer","constructor","requestDebounceMs","BehaviorSubject","Subject","results","_","getVarBlockId","Object","values","br","indexedBy","programBlock","latestProgram","definesTableColumn","join","definesVariable","getSymbolDefinedInBlock","isInUse","getParseableTypeInBlock","getNamesDefined","getFunctionDefinition","getDeepLengths","isArray","dimensions","linearizeType","deserializeType","pop","deepLengths","zip","dimensionLength","indexName","filterForBlockId","latestExternalData","extData","columnIndex","Queue","concurrency","autostart","imperativeParseErrors","errors","wireRequestsToResults","pushCompute","req","computeRequests","fn","combineLatestWith","throttleTime","leading","trailing","computeReq","prevReq","computeRequest","inputs","latestDroppedCompute","computing","Observable","outputSub","inputSub","computeInput","inp","closed","doneComputing","newInp","then","fnResult","err","complete","x","switchMap","shareReplay","mainIdentifier","split","parsed","firstNode","automaticallyGeneratedNames","getGoodBlocks","toIgnore","ignoreNames","seenSymbols","nodeTypes","ownTableName","ownVariableName","getNsNameFromId","serializeType","tName","colItems","colType","isLocal","findNames","computationRealm","variableExists","expressionResultFromText$","parseExpressionOrThrow","concatMap","expressionResult","enqueueComputation","priority","Promise","resolve","reject","computationQueue","unshift","expression","inferExpression","errType","ingestComputeRequest","newParse","previousBlocks","prev","updateChangedProgramBlocks","sortedParse","anyMappingToMap","programWithPrettyNames","makeNamesFromIds","autoGeneratedVarNames","computeResults","previousStatement","previousStatementValue","resultsToCache","resultToCache","computeProgram","updates","fromEntries","reset","pushExternalDataUpdate","newValue","pushExternalDataDelete","getAvailableIdentifier","start","attemptNumberless","existingVars","num","firstProposal","nextProposal","text","parseExpression","solution","unit","getLatestProgram","updateImperativeParseError","updater","nextValue","imperativelySetParseError","imperativelyUnsetParseError","hasImperativelySetParseError","setLocale","locale","formatNumber","numberFormat","numberError","formatUnit","formatError","RegExp","tokenRules","statements","findIncrementalDefinitions","getColumnNameFromTableColumnAssign","colAss","symbols","walkAst","getReferredSymbol","setA","setB","itemA","identifiedErrorToMessage","getURLComponents","source","url","URL","docIdMatch","pathname","match","hash","docId","decodeURIComponent","indexOf","fetch","_url","init","base","window","location","origin","process","DECI_APP_URL_BASE","href","numberToSubOrSuperscript","multipliersToPrefixes","scriptFromNumber","byExp","u1","u2","Number","N","produceExp","makePositive","u","singular","abs","isInteger","f","prettyENumbers","exponent","show10","coefficient","stringifyUnit","prettify","ignoreExp","toLowerCase","fullUnit","getUnitByName","pretty","prettyForSymbol","superBaseQuantity","baseQuantity","isSymbol","unitIsSymbol","multiPrefix","multiplier","valueOf","multiplierString","toString","toExponential","originalValue","baseSuperQuantity","equals","ONE","strExp","Math","sign","prettyExp","quality","formatUnitArgs","units","previousLength","unitsLength","parts","compare","pluralizeUnit","fixSpaces","partsOfUnit","formatUnitAsParts","_locale","TWO","simplified","simplifyUnits","sortedUnits","sort","unitParts","partsOf","isUserDefined","isUserDefinedUnit","simpleFormatUnitPart","multiplierStr","expStr","simpleFormatUnit","str","formatTypeToBasicString","spec","missingVariable","formulaName","expected","got","expectedButGot","butGot","expectedArgCount","opType","category","forbiddenThing","expectedSpecificity","gotSpecificity","gotArgTypes","argType","functionName","fromUnit","toUnit","dimensionId","dir","end","stepSignal","by","large","small","formatEdgeCaseNumber","places","repeating","integer","fraction","repeat","simpleDecimal","prettyTime","time","options","colonNotation","formatSubTime","separateTime","verbose","long","short","suffix","valueString","wholeDigits","minLength","max","pluralize","milliseconds","days","trunc","hours","minutes","seconds","microseconds","nanoseconds","millisecondsAndBelow","millisecondsDecimalDigits","timeDecimalDigits","roundedMiliseconds","round","ceil","millisecondsString","toFixed","parseFloat","secondsFixed","decimalDigits","flooredInterimValue","floor","floorDecimals","secondsDecimalDigits","secondsString","keepDecimalsOnWholeTime","prettifyTimeMs","v","ms","parseUnit","formatTime","formatAnyUnit","inMsTF","simplify","normalizeUnitName","areUnitsConvertible","convertBetweenUnits","fromTimeUnitToTimeBase","unitStr","asStringPrecise","isPrecise","getPrettyPartsOfTime","div","isTimeUnit","isCurrencyUnit","hasCurrency","arg","getPrettyCurrency","unitDef","CurrencyUnits","DEFAULT_NUMBER_OPTIONS","maximumFractionDigits","minimumFractionDigits","notation","compactDisplay","DEFAULT_CURRENCY_OPTIONS","style","currencyDisplay","LONG_NUMBER_OPTIONS","OTHER_LONG_NUMBER_OPTIONS","beautifyExponents","unclean","e","partsToString","N_LARGE_NUMBER_MIN","isLargeNumber","N_10K","isLessThan10k","getIsPrecise","largeNumbersGetAbbreviated","integerStr","fractionStr","formatToParts","mapParts","useSafeN","safeNumberForPrecision","DEFAULT_PRECISION","ZERO","isEdgeCaseNumber","placeholder","Intl","NumberFormat","part","MAX_SAFE_INTEGER","MAX_PRECISION","formatCurrency","currency","currencyIndex","currencyUnit","currencyFromIdx","getCurrency","numberFormatOptions","toLocaleUpperCase","N_10","N_ONE_CENT","formatUnitless","isNotMultipleOf10","mod","enginneringNotation","formattingOptions","formatUserDefinedUnit","valOf","formatAnyCurrency","unitsWithoutCurrency","otherUnitsMult","ac","current","mul","partsOfUnits","partsOfCurrency","cu","number","imprecise","formatted","asString","deciNumber","normalizeUnits","convertToMultiplierUnit","Unknown","Symbol","super","inferError","lowLevelGet","getColumnLike","primitive","Type","string","boolean","range","rangeContents","rangeOf","specificity","timeQuantity","timeUnit","numberType","timeUnitFromUnit","known","row","cells","cellNames","rowIndexName","rowT","rowCellTypes","rowCellNames","withErrorCause","_columnSize","atParentIndex","colT","columnSize","functionPlaceholder","argCount","fType","functionArgCount","nothing","nothingType","nothingness","anything","anyType","anythingness","impossible","inNode","impossibleType","InferError","immerable","static","expectedUnit","gotTable","gotColumn","duplicatedName","featureName","onlyOneIsPercentage","me","other","propagatePercentage","m","addIrregularRule","toBaseQuantity","fromBaseQuantity","aliases","PI","degreeToRadian","deg","invert","oneInch","oneFoot","oneYard","oneMile","oneFurlong","oneNauticalmile","oneNauticalleague","oneAngstrom","oneBohr","oneAttometre","oneFermi","oneSmoot","oneAstronomicalunit","oneLightsecond","oneLightyear","inch","foot","yard","furlong","mile","nauticalmile","nauticalleague","angstrom","bohr","attometre","fermi","smoot","astronomicalunit","lightsecond","lightminute","lighthour","lightday","lightyear","chain","fathom","link","marathon","parsec","point","twip","rope","rod","league","hand","pica","oneAcre","squarekilometre","squaremile","squareyard","squarefoot","squareinch","acre","barony","barn","are","ha","calorie","wh","byte","N16","N26","N_1E4","N_1_000_000","N1E9","N_28_349_523_125","N_10_160_469_088","pound","ounce","tonne","oz","ton","N_760","N_1E3","N_14_696","N_101_325","N_1E5","pascal","bar","mmhg","psi","N_1000","knot","doesNotScaleOnConversion","celsius","kelvin","fahrenheit","oneMinute","oneHour","oneDay","oneWeek","oneYear","oneDecade","oneCentury","oneMillennium","minute","hour","day","week","year","decade","century","millennium","toLocaleLowerCase","oneGallon","liters","cup","tablespoon","pint","teaspoon","pinch","dash","barrel","gallon","bushel","bucket","acrefoot","cubicinch","cubicfoot","cubicyard","cubicmile","allUnitPackages","LengthUnits","AreaUnits","VolumeUnits","PressureUnits","EnergyUnits","ForceUnits","MassUnits","TemperatureUnits","TimeUnits","InformationUnits","SubstanceUnits","ElectricCurrentUnits","ElectricChargeUnits","VoltageUnits","ElectricalCapacitanceUnits","ElectricalResistanceUnits","ElectricalConductanceUnits","PowerUnits","FrequencyUnits","SpeedUnits","LuminousIntensityUnits","LuminousFlowUnits","SolidAngleUnits","AngleUnits","duplicates","makePrettyRecord","prty","alias","abbr","aux","doNotPluralize","allUnits","unitPackage","baseQuantitiesThatDoNotUseUnitPrefixes","allSymbols","unitsByName","byName","isKnownSymbol","areUnitsCompatible","unitAName","unitBName","unitA","unitB","N_36","N_101325","expansions","force","expandedUnits","convertToExpanded","newton","pressure","atmospheres","area","volume","frequency","energy","joules","power","watts","speed","kph","voltage","volts","farads","ohms","siemens","baseQuantityToBaseUnit","mass","temperature","second","month","substance","information","angle","EUR","USD","GBP","SEK","XXX","NOK","JPY","CNY","PHP","INR","RUB","TRY","KRW","THB","PLN","ILS","AED","SAR","AUD","CAD","CHF","HKD","NZD","SGD","ZAR","BRL","TWD","DKK","IDR","HUF","CZK","CLP","COP","MYR","RON","BTC","ETH","UAH","baseUnitForBaseQuantity","nonScalarExpansionFromBaseQuantity","knownUnit","baseUnit","expandUnitWith","expansion","first","expandedUnit","newUnit","pow","convertKnownUnitToBase","uom","baseConversionFactor","expandUnit","nonScalarExpansion","scale","convertToBaseUnit","expandTo","newUnits","expansionFactor","expandUnitArgs","_units","converter","beforeCount","newConverter","allExpandedUnits","allConverters","expandUnits","unitArgs","normalizeUnitNames","scalarInversion","convert","isZero","nonScalarInversion","contractUnits","monthInSeconds","dayInSeconds","impreciseConversions","getImpreciseConversionFactor","to","getBaseQuantity","areQuantityUnitsCompatible","tolerateImprecision","baseA","baseB","areQuantityUnitsReversible","sortedA","baseQuantityUnits","sortedB","every","neg","unitsA","unitsB","sourceUnits","targetUnits","baseQuantitySourceUnits","baseQuantityTargetUnits","pendingMatchUnits","baseQuantitySourceUnit","pendingMatchUnit","toExpandedBaseQuantity","fromExpandedBaseQuantity","cannotConvertBetweenUnits","impreciselyConvertBetweenUnits","expandedN","outputUnits","revertedN","revertedNReversed","inverse","fromU","toU","fromBase","toBase","conv","getIndexNames","getReductionPlan","wantedCardinalities","highCardinality","isColumn","getCardinality","argIndices","commonIndex","exclude","seen","enumerate","findCommonIndexBetweenArguments","indices","namedIndex","findAnyIndex","getDimensionId","groupTypesByDimension","allDimensions","array","automapTypes","argTypes","mapFn","expectedCardinalities","arrayOfOnes","invalidCardinality","findInvalidCardinality","c","linearTypedArgs","scalarArgs","types","deLinearizeType","w","automapValues","argValues","reducedArgTypes","hackilyReduceArgTypes","createLazyOperation","doReduce","argTypesLowerDims","argTypesFromMapTypes","automapTypesForReducer","reduced","automapValuesForReducer","argValue","argCol","Value","dimSwapTypes","dominantIndexName","mapType","matrix","scalarTip","dimIndex","unknownCategory","chooseFirst","dimSwapValues","linear","indexOfDominantDimension","SwappedHypercube","getLabelIndex","getPositive","indexToLabelIndex","autoconvertArguments","typeLowestDims","reducedToLowest","expander","NumberValue","fromValue","autoconvertArgument","abbreviatedPrefixes","q","r","y","z","","da","h","k","M","G","T","P","E","Z","Y","R","Q","multiplierPrefixToFraction","quecto","ronto","yocto","zepto","atto","femto","pico","nano","micro","milli","centi","deci","deca","hecto","kilo","mega","giga","tera","peta","exa","zetta","yotta","ronna","quetta","multiplierPrefixes","unitString","trimResult","unitName","fullPrefix","substring","trimPrefix","smallPrefix","unitUsesPrefixes","matchesExponent","maybeACurrency","timeUnits","pluralUnit","areUnitQualitiesCompatible","quality1","quality2","matchUnitArrays","units1","units2","expandedUnit1","expandedUnits1","expandedUnit2","expandedUnits2","pendingMatch","matchingUnit","matchUnitArraysForColumn","_units1","_units2","lenientZip","propagateTypeUnits","onlyOneHasAUnit","bothNumbers","oneIsUnitless","removeSingleUnitless","setUnit","matchingUnitIndex","candidate","symbolUnit","byUnitName","mult","setExponent","newExponent","combineUnits","myUnitsObj","theirUnitsObj","myUnits","theirUnits","thisUnit","existingUnitIndex","inversed","checker","isScalar","sameScalarnessAs","meScalar","theyScalar","sharePercentage","isTable","isTableOrRow","withMinimumColumnCount","minColumns","withAtParentIndex","expectedTableAndAssociatedColumn","sameColumnessAs","sameAs","isRange","getRangeOf","sameRangenessAs","sameTablenessAs","myT","otherT","isTimeQuantity","isDate","sameDatenessAs","multiplyUnit","withUnits","divideUnit","divideBy","multiplyBy","invTheirUnits","inverseExponent","combinedUnits","ensurers","cmp","isPrimitive","expectedPrimitive","initialType","lastNonErrorType","resultingType","notErrored","newType","multipliersFor","traverseType","givenType","narrowTypes","t1","t2","mutSymbols","errorPath","s1","s2UnknownType","s2","narrowedContents","narrowedCell","equalOrUndefined","pathToError","narrowFunctionCall","expectedArgs","returnType","genericSymbols","tokens","moo","lt","gt","comma","colon","arrow","word","WS","lineBreaks","parseTypeInner","token","ensure","maybeSymbol","tok","parseWord","thro","parseLiteralNumber","tokenize","typeSource","curToken","consumed","assertAllConsumed","serializedType","propagateSymbol","fromT","toT","indexOnTop","items","HypercubeAtIndex","implementColumnLike","innerHC","Cls","rowCount","atIndex","hc","dim","currentCoordinates","recurse","dims","currentDepth","firstDim","restDims","materialize","Hypercube","op","getHypercubeArg","dimensionIds","uniqDimensions","operationArgs","argDimIds","keysForThisArg","argDim","whichKey","myDim","lazyOperation","dimsOrType","retDimensions","dimId","EmptyColumn","unswappedHC","dominantDimensionIndex","valueHere","ConcatenatedColumn","column1","column2","concatenatedDim","firstKey","restKeys","concatenatedIndex","enableMapSet","UnknownValue","Scalar","Date","DateValue","fromDateAndSpecificity","getTime","DeciNumber","BooleanValue","StringValue","varValue","moment","cleanDate","getEnd","addTime","getEndDate","Range","Column","_values","contents","innerDimensions","MappedColumn","sourceColumn","mappedIndex","FilteredColumn","cursor","count","bool","getSourceIndex","outwardIndex","trueCount","sourceIndex","wantedIndex","filteredIndex","tableRowCount","mapping","unzip","getColumn","mapColumns","fromNamedColumns","filterColumns","filterUnzipped","Row","getCell","fromJS","TypeError","fromValues","MAX_ITERATIONS","compareToNumber","isDeciNumberInput","lengthComparison","aItem","bItem","thisItem","log","diff","ColumnSlice","begin","outIndex","sortMap","unsortedIndexes","aIndex","bIndex","applyMap","slices","lastValue","nextSliceBeginsAt","currentValue","contiguousSlices","reverse","reverseMap","applyFilterMap","fromColumnAndMap","quantity","composedUnit","compositeMultiplier","timeUnitToJSDateUnit","added","toLuxonUTC","plus","BigInt","toMillis","timeUnitFromUnits","getTimeUnit","DateTime","toUTC","specificities","quarter","millisecond","jsUnitToIndex","timeUnitToIndex","getSpecificity","cmpSpecificities","leftIdx","rightIdx","getHighestSpecificity","sortSpecificities","arrayToDate","dateToArray","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","segments","nameAndNumber","dateArgs","segName","segValue","segNumber","isMonth","utcArgs","UTC","pad","padStart","out","dateNodeToTimeUnit","nodeArgs","lowestSegment","segment","pairwise","path","isNode","newNode","getOfType","desiredType","expressionTypesSet","statementTypesSet","assignmentTypesSet","identifierTypesSet","assertIdentifier","getInstanceof","cls","pair","filterFn","outKeys","outValues","o","reversingFactor","U","opts","multiplyMultipliers","rounded","precise","isNaN","isFinite","Stack","initialGlobalScope","namespaceJoiner","namespaceSplitter","namespaceRetriever","globalScope","getVisibleScopes","varGroup","temporaryScopes","functionScope","getAssignmentScope","isInGlobalScope","isNameGlobal","scope","val","globals","getNamespace","namespace","idMap","createNamespace","setNamespaced","asSplitNs","subMap","setMulti","variables","hasNamespaced","getNamespaced","foundWithId","deleteNamespaced","wrapper","preCallTemporaryScope","preCallFunctionScope","makeContext","typesToTable","tableToTypes","getTableColumnAsAGoddamnColumn","tableMapping","pushTableContext","previousPrevious","previous","previousTable","inTableBraces","withPush","logRetrievedName","group","validateLength","wanted","inferTableColumn","columnAst","otherColumns","refersToOtherColumnsByName","otherColumnName","otherColumn","inferTableColumnPerCell","coerceTableColumnTypeIndices","linkToAST","expr","isReferringToOtherColumnByName","shouldEvaluate","usesRecursion","isRecursiveReference","evaluateTableColumn","tableColumns","evaluateTableColumnIteratively","tableLength","coerceTableColumnIndices","getTypeAt","evaluate","iter","savedPrevious","previousValue","mapWithPrevious","otherColName","otherCol","getNumberSequenceError","sequenceStepZero","invalidSequenceStep","getNumberSequenceErrorN","toSimpleTimeUnit","getDateSequenceError","boundsSpecificity","stepUnit","steps","startYear","startMonth","endYear","endMonth","differenceInDays","tryGetNumber","getDateSequenceIncrement","byExpr","startUnit","endUnit","toSort","tua","tub","isPreviousRef","ref","getIndexName","inferVariable","context","expectedDim","variable","refName","expectedTable","evaluateVariable","refLike","readSimpleMatchers","matcher","dimensionName","dimNameRef","needleExp","matchTargets","matchers","getOnly","dimName","dimension","compareScalars","matches","pSeries","dimItem","inferMatchers","inferMultidimAssignment","outColumnSize","previousMatrix","returnedCellType","evaluateMatrixAssign","assign","varRef","needle","newColumn","assigneeExp","matchCount","getAssignee","targetIndex","valueInCol","evaluateMultidimAssignment","isCurrentlyCallingFunctions","inferFunctionCall","fName","fArgs","givenArguments","logRetrievedFunctionName","functionDefinition","callBuiltinFunctor","formulaCannotCallItself","func","withPushCall","fBody","argDef","returned","inferFunction","inferMatchDef","def","condition","conditionType","predicateSymbols","inferTieredDef","resultType","wrap","cohercingTo","noPreviousStatement","getConstantByName","fromStack","litType","startN","endN","byN","startType","endType","boundTypes","startSpec","increment","countOrError","inferSequence","columnItems","optionalIndex","unexpectedEmptyColumn","firstCellNode","restCellNodes","firstCellType","restCellTypes","erroredCell","cell","restCell","columnContainsInconsistentType","propName","getFromTableOrRow","originTable","varExp","matchersExp","inferMatrixRef","expandDirectiveToType","matchDef","matchDefType","inferMatch","initial","tieredDefs","all","inferTiered","inferStatementInternal","nName","nValue","forbiddenInsideFunction","retiredFeature","tableItem","inferTable","tableNameAst","colNameAst","duplicateTableColumn","newColumnAtParentIndex","inferColumnAssign","newMatrix","inferMatrixAssign","nameExp","contentsExp","theSet","setCell","inferCategories","inferFunctionDefinition","previoususedNames","inlineUnitAliases","oneUnit","aliasFor","enforceMultiplier","as","getType","unitExpr","expressionType","representsPercentage","unitExpressionType","targetUnit","isUserUnit","root","unitsExpression","expressionValue","noMultiplier","targetUnitsEvalResult","targetUnitsData","returnTypeDivider","multiplyUnitMultipliersIfNeedsEnforcing","targetUnitsMultiplier","multiplyUnitMultipliers","conversionRate","converted","cannotConvertToUnit","of","needOneAndOnlyOneUnit","directives","over","overExp","evaluateMatchDef","maybeConvertBetweenUnits","collectTieredDef","predicateOrTier","predicate","getPredicate","evaluateTier","tierValueExp","tierSize","tierResultType","tierValueType","tierSizeValue","tierValue","iterateTier","globalTierSizeType","tier","tierIndex","remaining","previousCutoff","tierSizeExp","tierSizeType","tierCutOff","min","tierResult","evaluateTiered","tierDefs","initialNumber","predicates","tiers","tierDef","predicateOrTierSizeExp","predicateOrTierValueExp","collectDefs","shift","restValue","minType","minimumValue","maxType","maximumValue","validate","getTrue","cond","failureMessage","reportError","getArray","rangeType","kinds","getOfKind","resultToValue","Result","tableValue","tableType","columnType","columnValue","dateValue","rangeValue","fromBounds","rowValue","rowType","fromNamedCells","maybeGetTypeAt","identifier","funcArgs","customFunc","argName","funcBody","prettyPrintAST","callBuiltin","startD","endD","cmpFn","step","iterations","columnFromDateSequence","startV","endV","byV","columnFromSequence","dateMs","addColumn","evaluateTable","tableOrRow","object","property","tableColAst","expAst","evaluateColumnAssign","ValueTransforms","evaluateMatrixRef","evaluateCategories","expandDirectiveToValue","matchDefValue","evaluateMatch","tableItemsToTable","tableToTableItems","tableItems","fromMapping","parseFunctor","signature","sig","tokenStream","parseFunctionSignature","overloadBuiltin","overloads","operatorKind","byArgTypes","argTypesKey","fnValues","argTypeNames","getOverloadedTypeFromValue","getOverload","functor","getOverloadedTypeFromType","overload","badOverloadedBuiltinCall","functionSignature","addDateAndTimeQuantity","amount","newDate","dateAndTimeQuantityFunctor","dateSpecificity","lowestUnit","getMostSpecific","mismatchedSpecificity","dateOverloads","v1","v2","negatedQuantity","d1","difference","d2","dateTime1","dateTime2","years","months","subtractDates","d1Specificity","d2Specificity","simpleExpressionEvaluate","res","complexExpressionExponent","binopFunctor","removeUnit","roundFunctor","decimalPrecision","roundWrap","decimalPrecisionValue","firstArgumentReducedFunctor","coherceToFraction","secondArgIsPercentage","mathOperators","noAutoconvert","decimalPlaces","roundup","rounddown","argCardinalities","isReducer","cellValue","average","fractions","avg","mean","averageif","_numbers","_bools","numbers","bools","sum","booleans","avgif","meanif","median","sortedValues","f1","f2","rightCenterPos","rightCenter","leftCenter","sqrt","nonRationalResult","ln","factorial","lookupTable","frac","fact","n1","n2","for","per","modulo","absoluteNumberInput","bValue","arg1","smooth","cmpFunctor","comparisonOperators","isEqual","equalityOperators","listOperators","len","cat","resultColumnSize","last","countif","aData","elem","stepgrowth","grow","growthRate","period","transpose","horizontal","vertical","functorNoAutomap","fnValuesNoAutomap","approximatesubsetsum","upperBound","_table","l","rows","approximateSubsetSumIndices","reducerOperators","total","nums","sumif","tableOperators","lookup","isBoolColumn","whenTable","tableOrColumn","getNeedleIndexAtTable","needleVal","rowIndex","concatenate","tab1","tab2","cols1","cols2","c1","c2","sortby","_column","filterMap","grab","tableGroupingOperators","splitby","hidden","miscOperators","if","otherwise","contains","aStart","aEnd","bNumber","aVal","bVal","rangeV","dateD","startDate","endDate","contractOperators","assert","preconditionNotMet","radian","once","angleOpFunctor","arcFunctor","operators","not","and","or","sin","autoConvertArgs","asin","cos","acos","tan","atan","getOperatorByName","normalizeOpName","opName","givenValues","typeHasError","missingFormula","argCounts","lowerDimFunctor","getFunctor","onlyArg","stages","argsBeforeConvert","stage","autoConvert","typeA","typeB","shouldAutoconvert","resultBeforeConvertingBack","builtin","lowerDimFn","argsLowerDims","typesLowerDims","argData","onlyArgType","callBuiltinAfterAutoconvert","contractor","autoconvertResult","jest","builtinConstants","pi","","openersToTypes","leftParen","leftSquareBracket","leftCurlyBracket","closersToTypes","rightParen","rightSquareBracket","rightCurlyBracket","BracketCounter","isValid","validationError","feed","opener","closer","openStack","previouslyOpened","previouslyOpenedType","open","close","noBrackets","finalize","keywords","kw","regexHack","flags","identifierRegExp","main","ws","notEquals","lessThanOrEquals","greaterThanOrEquals","twoStars","threeDots","threeDotsEllipsis","twoDots","dot","bang","percent","permille","permyriad","minus","times","caret","slash","lessThan","greaterThan","equalSign","andSign","orSign","beginDate","numberWithScientificNotation","splitUp","validJsonString","JSON","parse","digits","punc","monthName","basicTokenizer","tokenizer","peeked","openCounter","create","getNextToken","prevTok","nextTok","doSeparateStatement","peek","code","info","initialReservedWords","reservedWords","_getStart","tokOrNode","offset","_getEnd","addLoc","stringify","getLocationFromArray","locArray","shortCircuitStart","shortCircuitEnd","newStart","newEnd","foundToken","addArrayLoc","makeNumber","parentNode","returnMonth","joinDateParts","dateParts","nextDateInner","timezone","makeDateFragmentReader","_l","implicitMultHandler","funcRef","unaryMinusHandler","basicBinop","_spc","_spc2","simpleOperator","Lexer","ParserRules","postprocess","literal","accum","significand","listItem","_ws","coldefs","_sep","coldef","tieredDef","matchdefs","matchdef","_through","_comma","_ws2","statementSep","repetitions","__n","identString","compiledGrammar","ParserStart","typesWithArgs","findBorder","SyntaxError","detailMessage","line","posistionedCaret","grammar","nearley","Parser","NearleyParser","reportErrorCommon","lexerMessage","tokenDisplay","self","lastColumnIndex","lastColumn","expectantStates","states","state","nextSymbol","rule","lineColFromLexerMessage","lines","displayStateStack","stateStacks","buildFirstStateStack","stateStack","getSymbolDisplay","tryParse","parser","finish","solutions","locationToLine","lineToLocation","decorateNode","char","endChar","endLine","endColumn","sourceMapDecorator","printedSolutions","strings","interpolations","idsToInterpolations","codeWithIds","random","parseStatementOrThrow","interpolate","toReplace","parseBlock","bracketError","counter","validateBrackets","syntaxError","err2","warn","fromNearleySyntaxError","languageParse","trimEnd","fromParseError","parseStatement","disallowedNodeTypes","isEmptyExpressionError","isDisallowedNodeType","resultError","prettyPrint","indent","perLine","printedArgs","prop","printArg","parseBlockOrThrow","document","documentElement","currentStyle","getElementsByTagName","navigator","platform","addEventListener","Element","prototype","requestAnimationFrame","cb","setTimeout","cancelAnimationFrame","timer","clearTimeout","require","defaultEnvValues","REACT_APP_SENTRY_DSN","REACT_APP_GOOGLE_SHEETS_API_KEY","valueOrDefault","defaultEnv","thirdParty","googleSheets","apiKey","HttpError","handleResponseError","response","responseBodyString","responseBodyJson","fromResponse","getSheetMeta","qs","encodeQuery","metadataUrl","spreadsheetId","json","fetchOptions","method","headers","Referer","ok","contentType","statusCode","status","request","getSheetRequestDataFromUrl","sheetUrl","hostname","sheetId","gid","getSheetRequestDataFromApiUrl","hashMatch","getSheetRequestDataFromUserUrl","getDataUrlFromSheetMeta","sheetMeta","majorDimension","valueRenderOption","dateTimeRenderOption","subSheet","sheets","sheet","properties","subSheetName","title","encodeURIComponent","isEmpty","columnIsNotEmpty","columnNeedsTrimming","alreadyHasData","trimTopRowCount","trimBottomRowCount","empty","finalRowCount","trimSheet","trimmingNeeds","trimmer","finalTrimTopRowCount","finalTrimBottomRowCount","trimRowCount","trimmed","needsFillingAtTheBottom","trimColumn","createTrimmer","tn","sheetColumnName","dividend","fromCharCode","parseInt","getDataRangeUrlFromSheetAndIslands","island","sheetName","firstCol","firstRow","lastCol","lastRow","islandToRange","neighbourDiffs","partition","imported","columnCount","visited","startValue","fill","sheetColumns","islands","extendIsland","colIndex","extension","newCol","newRow","islandExtension","hasValue","pushNeighbourCells","nextColIndex","nextRowIndex","exploreIsland","_col","_row","makeIsland","newResults","islandToResult","meta","sourceUrl","sourceMeta","sumLength","errorResult","handleGsheetsResponse","resp","identifyIslands","maxCellCount","trimmedBody","doNotTryExpressionNumbersParse","loadAllSubsheets","importURL","loader","loadSheet","subsheet","subMeta","importedAt","importGsheetIslands","importOneGsheet","statusText","gsheets","matchUrl","import","parseSourceUrl","indexOfExclamationMark","subsheetName","userUrl","getUserUrl","decipad","endsWith","toInternalType","_type","ArrowType","evaluateCell","tof","evaluateData","colValues","numCols","getChildAt","importFromArrow","arrowTable","tableFromIPC","columnMeta","schema","fields","inferData","pivot","importFromCsv","parseCSV","cast","delimiter","relax_quotes","relax_column_count","skip_empty_lines","isDone","on","read","importFromArray","arr","importTableFromObject","columnNameFromIndex","importTableFromArray","importFromUnknownJson","firstType","sameType","columnTypeCoercions","cohersion","parseBoolean","parseDate","importFromUnknownResponse","importFromUnknown","importFromUnknownUrl","internalTryImport","provider","rpc","RPC","target","postMessage","receiver","readMessages","listener","ev","removeEventListener","serviceId","subscriptions","tryImportHere","subscriptionId","restOptions","tryImport","params","useFirstRowAsHeader","notify","onError","schedule","pollIntervalSeconds","lastResult","newResponse","call","subscription","hasCircularDependency","subscriptionRequest","subscribeInternal","deferError","deferringError","startNotebook","hasAccess","exists","notebookId","isPublic","notebook","getNotebook","parentSubscriptionId","throwOnError","nanoid","expose","fractionLikeProps","isFractionLike","isFractionLikeProp","fs","toJSON","Fraction","_depth","stylize","isNumber","F","isUndefined","isInfinite","infinite","binOp","fromNumber","tofN","fractionPow","resultNumber","gcd","lcm","eps","that","divisible","NaN","Infinity","toLatex","excludeWhole","toFraction","toContinued","clone","UNDEFINED","isNegativeInfinite","minFraction","isPositiveInfinite","maxFraction","coerceToBoolean","inferBoolean","coerced","granularityRank","highestTimeSpecificity","highestG","highestGRank","gs","g","thisRank","combineFormats","formats","aElem","bElem","dayFormats","minuteFormats","secondFormats","dateFormats","allowedFormats","dateFormatsForSpecificity","formatStrings","format","coerceToDate","formatDate","inferDate","coerceToString","inferText","inferPlainNumber","inferNumber","containsNumber","inferParseError","tryInferChain","inferResult","inferType","_text","memoizeParams","maxSize","memoize","mMemoize","inferColumn","lastType","userType","coalesce","_newType","lastDateType","newGranularity","baseSize","toNumber","replaceAll","countDecimals","_n","moreDecimals","fullNumber","toValue","columnValues","decimalCount","fastNumber","varNamify","withColumnNames","astNode","dateToAST","asDate","defaultLocale","parseCell","afterParse","inferred","parseResult","parsing","assertCellType","cellUnit","fixCellUnit","formattedUnit","unitToAST","getNullReplacementValue","parseSeriesStart","content","parsedDate","dateGranularityToDateFnsDuration","seriesIterator","initialValue","addDate","dateIterator","cache","toUpperCase","capitalize","camelCase","supportBigIntToJSON","module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","loaded","__webpack_modules__","__webpack_exports__","O","deferred","chunkIds","notFulfilled","fulfilled","j","getter","__esModule","leafPrototypes","getProto","getPrototypeOf","mode","getOwnPropertyNames","definition","defineProperty","enumerable","chunkId","promises","miniCssF","hasOwnProperty","toStringTag","nmd","paths","children","nc","installedChunks","chunk","moreModules","modules","ids","runtime","installChunk"],"sourceRoot":""}