{"version":3,"file":"static/js/6896.82550df3.chunk.js","mappings":"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","sources":["../../editor-language-elements/src/utils/statementToIdentifiedBlock.ts","../../editor-language-elements/src/utils/parseElementAsSourceCode.ts","../../editor-language-elements/src/utils/weakMapMemoizeInteractiveElementOutput.ts","../../editor-language-elements/src/elements/CodeLine.ts","../../editor-language-elements/src/utils/parseElementAsVariableAssignment.ts","../../editor-language-elements/src/elements/CodeLineV2.ts","../../editor-language-elements/src/elements/Eval.ts","../../editor-language-elements/src/elements/TextElements.ts","../../editor-utils/src/astNode.ts","../../editor-language-elements/src/utils/headerToColumn.ts","../../editor-language-elements/src/utils/formulaSourceToColumnAssign.ts","../../editor-language-elements/src/utils/seriesColumn.ts","../../editor-language-elements/src/utils/getTableAstNodeFromTableElement.ts","../../editor-language-elements/src/utils/toColumnAssign.ts","../../editor-language-elements/src/elements/Table.ts","../../editor-language-elements/src/elements/Column.ts","../../editor-language-elements/src/elements/StructuredInputs.ts","../../editor-language-elements/src/elements/VariableDef.ts","../../editor-language-elements/src/elements/LiveConnection.ts","../../editor-language-elements/src/elementToLanguageBlock.ts","../../editor-language-elements/src/editorToProgram.ts","../../editor-types/src/element-kinds.ts","../../editor-utils/src/assertElementType.ts","../../editor-utils/src/getCodeLineSource.ts","../../editor-utils/src/isElementOfType.ts","../../editor-utils/src/magicNumberId.ts"],"sourcesContent":["import { AST } from '@decipad/computer';\nimport { IdentifiedBlock } from 'libs/computer/src/types';\n\nexport function statementToIdentifiedBlock(\n  id: string,\n  stat: AST.Statement,\n  definesVariable?: string,\n  definesTableColumn?: string\n): IdentifiedBlock {\n  const defs =\n    definesTableColumn && definesVariable\n      ? {\n          definesTableColumn: [definesVariable, definesTableColumn] as [\n            string,\n            string\n          ],\n        }\n      : definesVariable\n      ? { definesVariable }\n      : {};\n\n  return {\n    type: 'identified-block',\n    id,\n    block: {\n      id,\n      type: 'block',\n      args: [stat],\n    },\n    ...defs,\n  };\n}\n","import { parseExpression, parseStatement, Program } from '@decipad/computer';\nimport { statementToIdentifiedBlock } from './statementToIdentifiedBlock';\n\n/**\n * The main function that passes user code through to computer\n *\n * Ensures only one statement is parsed\n */\nexport function parseElementAsSourceCode(\n  blockId: string,\n  source: string,\n  sourceKind: 'statement' | 'expression' = 'statement'\n): Program {\n  const { solution, error } =\n    sourceKind === 'statement'\n      ? parseStatement(source)\n      : parseExpression(source);\n\n  if (error) {\n    return [\n      {\n        type: 'identified-error',\n        errorKind: 'parse-error',\n        id: blockId,\n        source,\n        error,\n      },\n    ];\n  }\n  return [statementToIdentifiedBlock(blockId, solution)];\n}\n","import { Computer } from '@decipad/computer';\nimport { MyEditor, MyElement } from '@decipad/editor-types';\n\ntype TransformerFn<T extends MyElement, RetT> = (\n  editor: MyEditor,\n  computer: Computer,\n  arg: T\n) => Promise<RetT>;\n\nexport const weakMapMemoizeInteractiveElementOutput = <\n  T extends MyElement,\n  RetT\n>(\n  fn: TransformerFn<T, RetT>\n): TransformerFn<T, RetT> => {\n  const cache = new WeakMap<T, RetT | null>();\n\n  return async (editor: MyEditor, computer: Computer, arg: T) => {\n    const cached = cache.get(arg) ?? (await fn(editor, computer, arg));\n    cache.set(arg, cached);\n    return cached;\n  };\n};\n","import { ELEMENT_CODE_LINE, MyEditor, MyElement } from '@decipad/editor-types';\nimport { Computer } from '@decipad/computer';\nimport { getCodeLineSource } from '@decipad/editor-utils';\nimport { InteractiveLanguageElement } from '../types';\nimport { parseElementAsSourceCode } from '../utils/parseElementAsSourceCode';\nimport { weakMapMemoizeInteractiveElementOutput } from '../utils/weakMapMemoizeInteractiveElementOutput';\n\nexport const getUnparsedBlockFromCodeLine = async (\n  _editor: MyEditor,\n  _computer: Computer,\n  block: MyElement\n) => {\n  if (block.type === ELEMENT_CODE_LINE) {\n    return parseElementAsSourceCode(block.id, getCodeLineSource(block));\n  }\n  return [];\n};\n\nexport const CodeLine: InteractiveLanguageElement = {\n  type: ELEMENT_CODE_LINE,\n  getParsedBlockFromElement: weakMapMemoizeInteractiveElementOutput(\n    getUnparsedBlockFromCodeLine\n  ),\n};\n","import { AST, parseExpression, Program } from '@decipad/computer';\nimport { statementToIdentifiedBlock } from './statementToIdentifiedBlock';\n\n/**\n * Parse a variable assignment. Source code or AST.\n */\nexport function parseElementAsVariableAssignment(\n  blockId: string,\n  varName: string,\n  source: string | AST.Expression,\n  disallowedNodeTypes?: AST.Node['type'][]\n): Program {\n  const { solution: expression, error } =\n    typeof source === 'string'\n      ? source.trim() === ''\n        ? parseExpression('0')\n        : parseExpression(source, disallowedNodeTypes)\n      : { solution: source, error: undefined };\n\n  if (error) {\n    return [\n      {\n        type: 'identified-error',\n        errorKind: 'parse-error',\n        id: blockId,\n        source: typeof source === 'string' ? source : '',\n        error,\n        definesVariable: varName,\n      },\n    ];\n  }\n\n  const statement: AST.Statement | AST.Expression = varName\n    ? {\n        type: 'assign',\n        args: [{ type: 'def', args: [varName] }, expression],\n      }\n    : expression;\n\n  return [statementToIdentifiedBlock(blockId, statement, varName)];\n}\n","import { AST, Computer, Program, SerializedType } from '@decipad/computer';\nimport {\n  CodeLineV2Element,\n  ELEMENT_CODE_LINE_V2,\n  MyEditor,\n  MyElement,\n} from '@decipad/editor-types';\nimport { assertElementType, getCodeLineSource } from '@decipad/editor-utils';\nimport { N } from '@decipad/number';\nimport { parseCell } from '@decipad/parse';\nimport { getNodeString } from '@udecode/plate';\nimport { InteractiveLanguageElement } from '../types';\nimport { parseElementAsVariableAssignment } from '../utils/parseElementAsVariableAssignment';\nimport { weakMapMemoizeInteractiveElementOutput } from '../utils/weakMapMemoizeInteractiveElementOutput';\n\nconst disallowNodeTypes: AST.Node['type'][] = [\n  'range',\n  'sequence',\n  'match',\n  'tiered',\n];\n\nconst tryParseAsNumber = weakMapMemoizeInteractiveElementOutput(\n  async (_editor, computer, e: CodeLineV2Element): Promise<Program> => {\n    const [vname, sourcetext] = e.children;\n    const source = getNodeString(sourcetext);\n\n    if (source?.trim()) {\n      // First try parsing it as a plain number\n      const typeHint: SerializedType =\n        e.unit === '%'\n          ? {\n              kind: 'number',\n              unit: null,\n              numberFormat: 'percentage',\n            }\n          : {\n              kind: 'number',\n              unit:\n                typeof e.unit === 'string'\n                  ? await computer.getUnitFromText(e.unit ?? '')\n                  : e.unit ?? null,\n            };\n\n      const parsedInput = await parseCell(computer, typeHint, source);\n\n      if (!(parsedInput instanceof Error || parsedInput == null)) {\n        return parseElementAsVariableAssignment(\n          e.id,\n          getNodeString(vname),\n          getCodeLineSource(sourcetext),\n          disallowNodeTypes\n        );\n      }\n    }\n\n    return [];\n  }\n);\n\nexport const parseStructuredCodeLine = weakMapMemoizeInteractiveElementOutput(\n  async (\n    editor: MyEditor,\n    computer: Computer,\n    block: MyElement\n  ): Promise<{\n    interpretedAs: 'code' | 'literal' | 'empty';\n    programChunk: Program;\n  }> => {\n    assertElementType(block, ELEMENT_CODE_LINE_V2);\n\n    const [vname, sourcetext] = block.children;\n\n    if (getCodeLineSource(block.children[1])?.trim()) {\n      const asNumber = await tryParseAsNumber(\n        editor,\n        computer,\n        block as CodeLineV2Element\n      );\n\n      if (asNumber.length) {\n        return {\n          interpretedAs: 'literal',\n          programChunk: asNumber,\n        };\n      }\n\n      return {\n        interpretedAs: 'code',\n        programChunk: parseElementAsVariableAssignment(\n          block.id,\n          getNodeString(vname),\n          getCodeLineSource(sourcetext),\n          disallowNodeTypes\n        ),\n      };\n    }\n    // empty line\n    return {\n      interpretedAs: 'empty',\n      programChunk: parseElementAsVariableAssignment(\n        block.id,\n        getNodeString(vname),\n        { type: 'literal', args: ['number', N(0)] }\n      ),\n    };\n  }\n);\n\nexport const CodeLineV2: InteractiveLanguageElement = {\n  type: ELEMENT_CODE_LINE_V2,\n  getParsedBlockFromElement: async (editor, computer, e) => {\n    assertElementType(e, ELEMENT_CODE_LINE_V2);\n\n    const { programChunk } = await parseStructuredCodeLine(editor, computer, e);\n\n    return programChunk;\n  },\n};\n","import { ELEMENT_EVAL, MyEditor, MyElement } from '@decipad/editor-types';\nimport { Computer } from '@decipad/computer';\nimport { InteractiveLanguageElement } from '../types';\nimport { parseElementAsSourceCode } from '../utils/parseElementAsSourceCode';\nimport { weakMapMemoizeInteractiveElementOutput } from '../utils/weakMapMemoizeInteractiveElementOutput';\n\nexport const getUnparsedBlockFromEval = async (\n  _editor: MyEditor,\n  _computer: Computer,\n  block: MyElement\n) => {\n  if (block.type !== ELEMENT_EVAL) return [];\n\n  return parseElementAsSourceCode(block.id, block.result);\n};\n\nexport const Eval: InteractiveLanguageElement = {\n  type: ELEMENT_EVAL,\n  getParsedBlockFromElement: weakMapMemoizeInteractiveElementOutput(\n    getUnparsedBlockFromEval\n  ),\n};\n","import {\n  ELEMENT_CALLOUT,\n  ELEMENT_PARAGRAPH,\n  MARK_MAGICNUMBER,\n  ELEMENT_LI,\n  ELEMENT_OL,\n  ELEMENT_LIC,\n  ELEMENT_UL,\n} from '@decipad/editor-types';\nimport { magicNumberId } from '@decipad/editor-utils';\nimport { getNodeString } from '@udecode/plate';\nimport { weakMapMemoizeInteractiveElementOutput } from '../utils/weakMapMemoizeInteractiveElementOutput';\nimport { InteractiveLanguageElement } from '../types';\nimport { parseElementAsSourceCode } from '../utils/parseElementAsSourceCode';\n\nexport const Paragraph: InteractiveLanguageElement = {\n  type: [\n    ELEMENT_PARAGRAPH,\n    ELEMENT_CALLOUT,\n    ELEMENT_LI,\n    ELEMENT_OL,\n    ELEMENT_LIC,\n    ELEMENT_UL,\n  ],\n  isStructural: true,\n  getParsedBlockFromElement: weakMapMemoizeInteractiveElementOutput(\n    async (_editor, _computer, element) => {\n      return element.children.flatMap((child, index) => {\n        if (MARK_MAGICNUMBER in child) {\n          return parseElementAsSourceCode(\n            magicNumberId(element, index),\n            getNodeString(child),\n            'expression'\n          );\n        }\n        return [];\n      });\n    }\n  ),\n};\n","// Need this retval ambiguity for the typings to adapt to every kind of AST.Node\n\nimport type { AST } from '@decipad/computer';\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const astNode = <\n  T extends AST.Node['type'],\n  RetNode extends Extract<AST.Node, { type: T }>\n>(\n  type: T,\n  ...args: RetNode['args']\n) => ({ type, args } as RetNode);\n\nexport const astColumn = (...items: AST.Expression[]): AST.Column =>\n  astNode('column', astNode('column-items', ...items));\n","import { AST, Computer, IdentifiedError } from '@decipad/computer';\nimport {\n  ELEMENT_TABLE_COLUMN_FORMULA,\n  TableElement,\n  TableHeaderElement,\n  TableRowElement,\n} from '@decipad/editor-types';\nimport {\n  astColumn,\n  getCodeLineSource,\n  isElementOfType,\n} from '@decipad/editor-utils';\nimport {\n  inferColumn,\n  parseCell,\n  getNullReplacementValue,\n} from '@decipad/parse';\nimport { getNodeString } from '@udecode/plate';\nimport { formulaSourceToColumnAssign } from './formulaSourceToColumnAssign';\nimport { seriesColumn } from './seriesColumn';\n\ninterface HeaderToColumnProps {\n  computer: Computer;\n  tableName: string;\n  table: TableElement;\n  th: TableHeaderElement;\n  columnIndex: number;\n  dataRows: TableRowElement[];\n}\n\nexport interface ColumnParseReturn {\n  errors: IdentifiedError[];\n  expression?: AST.Expression;\n  columnName: string;\n  elementId?: string;\n}\n\nconst simpleError = (id: string, message: string): IdentifiedError => ({\n  type: 'identified-error',\n  errorKind: 'parse-error',\n  id,\n  error: { message },\n  source: '',\n});\n\nconst tableFormulaColumnToColumn = ({\n  table,\n  th,\n}: HeaderToColumnProps): ColumnParseReturn => {\n  const columnName = getNodeString(th);\n  const formula = table.children[0].children.find(\n    (child) =>\n      child.type === ELEMENT_TABLE_COLUMN_FORMULA && child.columnId === th.id\n  );\n\n  if (isElementOfType(formula, ELEMENT_TABLE_COLUMN_FORMULA)) {\n    return formulaSourceToColumnAssign(\n      columnName,\n      th.id,\n      getCodeLineSource(formula)\n    );\n  }\n  return {\n    columnName,\n    errors: [simpleError(th.id, 'Could not find a formula for this column')],\n  };\n};\n\nconst seriesColumnToColumn = async ({\n  columnIndex,\n  computer,\n  th,\n  dataRows,\n}: HeaderToColumnProps): Promise<ColumnParseReturn> => {\n  if (th.cellType.kind !== 'series') {\n    throw new Error('Expected series');\n  }\n  const firstDataRow = dataRows[0];\n  if (!firstDataRow) {\n    throw new Error('Expected first data row');\n  }\n  const content = getNodeString(firstDataRow.children[columnIndex]);\n  const expression = await seriesColumn(\n    computer,\n    th.cellType.seriesType,\n    content,\n    dataRows.length\n  );\n  return {\n    elementId: th.id,\n    expression,\n    columnName: getNodeString(th),\n    errors: [],\n  };\n};\n\nconst dropdownColumnToColumn = async ({\n  th,\n  columnIndex,\n  dataRows,\n}: HeaderToColumnProps): Promise<ColumnParseReturn> => {\n  const errors: IdentifiedError[] = [];\n  const cellTexts: string[] = [];\n  const cellIds: string[] = [];\n  for (const tr of dataRows) {\n    const td = tr.children[columnIndex];\n    if (td) {\n      cellTexts.push(getNodeString(td));\n      cellIds.push(td.id);\n    }\n  }\n\n  if (th.cellType.kind !== 'dropdown') {\n    throw new Error('Dropdown column should have dropdown type');\n  }\n\n  const items = cellTexts.map((text): AST.Expression => {\n    if (text) {\n      return {\n        type: 'ref',\n        args: [text],\n      };\n    }\n    return getNullReplacementValue(th.cellType);\n  });\n\n  const expression = astColumn(...items);\n  return {\n    expression,\n    errors,\n    columnName: getNodeString(th),\n    elementId: th.id,\n  };\n};\n\nconst dataColumnToColumn = async ({\n  computer,\n  th,\n  columnIndex,\n  dataRows,\n}: HeaderToColumnProps): Promise<ColumnParseReturn> => {\n  const errors: IdentifiedError[] = [];\n  const cellTexts: string[] = [];\n  const cellIds: string[] = [];\n  for (const tr of dataRows) {\n    const td = tr.children[columnIndex];\n    if (td) {\n      cellTexts.push(getNodeString(td));\n      cellIds.push(td.id);\n    }\n  }\n\n  const columnType =\n    !th.cellType || th.cellType.kind === 'anything'\n      ? await inferColumn(computer, cellTexts, { userType: th.cellType })\n      : th.cellType;\n\n  const items = await Promise.all(\n    cellTexts.map(async (text, index) => {\n      let parsed = await parseCell(computer, columnType, text);\n      if (!parsed) {\n        errors.push(simpleError(cellIds[index], `Invalid ${columnType.kind}`));\n      }\n      if (parsed instanceof Error) {\n        errors.push(simpleError(cellIds[index], parsed.message));\n        parsed = null;\n      }\n      if (!parsed) {\n        parsed = getNullReplacementValue(columnType);\n      }\n      return parsed;\n    })\n  );\n  const expression = astColumn(...items);\n  return {\n    expression,\n    errors,\n    columnName: getNodeString(th),\n    elementId: th.id,\n  };\n};\n\nexport const headerToColumn = async (\n  props: HeaderToColumnProps\n): Promise<ColumnParseReturn> => {\n  const { th, dataRows } = props;\n  const { cellType } = th;\n  return cellType.kind === 'table-formula'\n    ? tableFormulaColumnToColumn(props)\n    : cellType.kind === 'series' && dataRows.length > 0\n    ? seriesColumnToColumn(props)\n    : cellType.kind === 'dropdown'\n    ? dropdownColumnToColumn(props)\n    : dataColumnToColumn(props);\n};\n","import { parseExpression } from '@decipad/computer';\nimport type { ColumnParseReturn } from './headerToColumn';\n\nexport function formulaSourceToColumnAssign(\n  columnName: string,\n  columnFormulaBlockId: string,\n  source: string\n): ColumnParseReturn {\n  const { solution, error } = parseExpression(source);\n\n  return {\n    errors: error\n      ? [\n          {\n            type: 'identified-error',\n            errorKind: 'parse-error',\n            id: columnFormulaBlockId,\n            error,\n            source,\n          },\n        ]\n      : [],\n    expression: solution,\n    columnName,\n    elementId: columnFormulaBlockId,\n  };\n}\n","import { SeriesType } from '@decipad/editor-types';\nimport { AST, Computer, isExpression } from '@decipad/computer';\nimport { astColumn, astNode } from '@decipad/editor-utils';\nimport { getDefined } from '@decipad/utils';\nimport { parseCell, parseSeriesStart, seriesIterator } from '@decipad/parse';\n\nexport async function seriesColumn(\n  computer: Computer,\n  type: SeriesType,\n  source: string,\n  rowCount: number\n): Promise<AST.Expression> {\n  try {\n    const { granularity } = parseSeriesStart(type, source);\n    const it = seriesIterator(type, getDefined(granularity), source);\n    let v = source.trim();\n    const items = (\n      await Promise.all(\n        Array.from({ length: rowCount }, async () => {\n          const previous = v;\n          v = it.next().value;\n          return getDefined(\n            await parseCell(\n              computer,\n              {\n                kind: 'date',\n                date: getDefined(granularity),\n              },\n              previous\n            )\n          );\n        })\n      )\n    ).filter(isExpression);\n    return astColumn(...items);\n  } catch (e) {\n    const items = Array.from({ length: rowCount }, () =>\n      astNode('date', 'year', 2020n)\n    );\n    return astColumn(...items);\n  }\n}\n","import { MyEditor, TableElement } from '@decipad/editor-types';\nimport { AST, Computer, IdentifiedError } from '@decipad/computer';\nimport { getNodeString } from '@udecode/plate';\nimport { astNode } from '@decipad/editor-utils';\nimport { headerToColumn } from './headerToColumn';\nimport { toColumnAssign } from './toColumnAssign';\n\nexport interface ColumnAssign {\n  blockId: string;\n  column?: AST.TableColumnAssign;\n  errors: IdentifiedError[];\n}\n\nexport interface GetTableAstNodeFromTableElementResult {\n  id: string;\n  name: string;\n  expression: AST.Table;\n  columnAssigns: ColumnAssign[];\n}\n\nexport const getTableAstNodeFromTableElement = async (\n  _editor: MyEditor,\n  computer: Computer,\n  table: TableElement\n): Promise<GetTableAstNodeFromTableElementResult> => {\n  const [caption, headerRow, ...dataRows] = table.children;\n  const tableName = getNodeString(caption.children[0]);\n\n  const columnAssigns = await Promise.all(\n    headerRow.children.map(async (th, columnIndex) => {\n      const col = await headerToColumn({\n        computer,\n        th,\n        columnIndex,\n        tableName,\n        table,\n        dataRows,\n      });\n\n      return toColumnAssign(table.id, tableName, col);\n    })\n  );\n\n  return {\n    id: table.id,\n    name: tableName,\n    expression: astNode('table', astNode('tabledef', tableName)),\n    columnAssigns,\n  };\n};\n","import { astNode } from '@decipad/editor-utils';\nimport type { ColumnAssign } from './getTableAstNodeFromTableElement';\nimport type { ColumnParseReturn } from './headerToColumn';\n\nexport const toColumnAssign = (\n  tableBlockId: string,\n  tableName: string,\n  column: ColumnParseReturn\n): ColumnAssign => {\n  return {\n    blockId: column.elementId ?? tableBlockId,\n    column:\n      column.expression &&\n      astNode(\n        'table-column-assign',\n        astNode('tablepartialdef', tableName),\n        astNode('coldef', column.columnName),\n        column.expression\n      ),\n    errors: column.errors,\n  };\n};\n","import { MyElement, ELEMENT_TABLE, MyEditor } from '@decipad/editor-types';\nimport { Computer, Program, getDefinedSymbol } from '@decipad/computer';\nimport { assertElementType } from '@decipad/editor-utils';\nimport { getColumnNameFromTableColumnAssign } from 'libs/computer/src/utils';\nimport { InteractiveLanguageElement } from '../types';\nimport { weakMapMemoizeInteractiveElementOutput } from '../utils/weakMapMemoizeInteractiveElementOutput';\nimport { getTableAstNodeFromTableElement } from '../utils/getTableAstNodeFromTableElement';\nimport { statementToIdentifiedBlock } from '../utils/statementToIdentifiedBlock';\n\nexport const Table: InteractiveLanguageElement = {\n  type: ELEMENT_TABLE,\n  getParsedBlockFromElement: weakMapMemoizeInteractiveElementOutput(\n    async (\n      editor: MyEditor,\n      computer: Computer,\n      element: MyElement\n    ): Promise<Program> => {\n      assertElementType(element, ELEMENT_TABLE);\n      const { id, expression, columnAssigns } =\n        await getTableAstNodeFromTableElement(editor, computer, element);\n\n      const tableItself = statementToIdentifiedBlock(id, expression);\n      const tableName =\n        getDefinedSymbol(tableItself.block.args[0]) || undefined;\n\n      const columnAssignments = columnAssigns.flatMap((columnAssign) => [\n        ...(columnAssign.column\n          ? [\n              statementToIdentifiedBlock(\n                columnAssign.blockId,\n                columnAssign.column,\n                tableName,\n                getColumnNameFromTableColumnAssign(columnAssign.column)\n              ),\n            ]\n          : []),\n        ...columnAssign.errors,\n      ]);\n\n      return [tableItself, ...columnAssignments];\n    }\n  ),\n};\n","import { ELEMENT_COLUMNS } from '@decipad/editor-types';\nimport { InteractiveLanguageElement } from '../types';\n\nexport const Column: InteractiveLanguageElement = {\n  type: ELEMENT_COLUMNS,\n  isStructural: true,\n};\n","import { Program, SerializedType } from '@decipad/computer';\nimport { ELEMENT_STRUCTURED_IN } from '@decipad/editor-types';\nimport { assertElementType } from '@decipad/editor-utils';\nimport { parseCell } from '@decipad/parse';\nimport { InteractiveLanguageElement } from '../types';\nimport { parseElementAsVariableAssignment } from '../utils/parseElementAsVariableAssignment';\nimport { weakMapMemoizeInteractiveElementOutput } from '../utils/weakMapMemoizeInteractiveElementOutput';\n\n/**\n * Parsing the structured input elements into the language, these elements are\n * slightly special because they ONLY accept numbers, and allow the user to select units.\n * 1) We either take units as strings, or unit objects, and parse them like this.\n * 2) Declare them with their name\n *\n * Edge case: Percentages, these are NOT units, but we display them as such.\n * So we have to check if we want a %, and build the SerializedType from this.\n */\nexport const StructuredInput: InteractiveLanguageElement = {\n  type: ELEMENT_STRUCTURED_IN,\n  getParsedBlockFromElement: weakMapMemoizeInteractiveElementOutput(\n    async (_editor, computer, e): Promise<Program> => {\n      assertElementType(e, ELEMENT_STRUCTURED_IN);\n\n      const typeHint: SerializedType =\n        e.unit === '%'\n          ? {\n              kind: 'number',\n              unit: null,\n              numberFormat: 'percentage',\n            }\n          : {\n              kind: 'number',\n              unit:\n                typeof e.unit === 'string'\n                  ? await computer.getUnitFromText(e.unit ?? '')\n                  : e.unit ?? null,\n            };\n      const parsedInput = await parseCell(\n        computer,\n        typeHint,\n        e.children[1].children[0].text\n      );\n\n      return parseElementAsVariableAssignment(\n        e.id,\n        e.children[0].children[0].text,\n        parsedInput instanceof Error || parsedInput === null ? '' : parsedInput\n      );\n    }\n  ),\n};\n","import {\n  MyElement,\n  ELEMENT_VARIABLE_DEF,\n  MyEditor,\n} from '@decipad/editor-types';\nimport { AST, Computer, getExprRef } from '@decipad/computer';\nimport { getNodeString } from '@udecode/plate';\nimport { assertElementType } from '@decipad/editor-utils';\nimport { inferType } from '@decipad/parse';\nimport { getDefined } from '@decipad/utils';\nimport { weakMapMemoizeInteractiveElementOutput } from '../utils/weakMapMemoizeInteractiveElementOutput';\nimport { InteractiveLanguageElement } from '../types';\nimport { parseElementAsVariableAssignment } from '../utils/parseElementAsVariableAssignment';\n\nexport const VariableDef: InteractiveLanguageElement = {\n  type: ELEMENT_VARIABLE_DEF,\n  getParsedBlockFromElement: weakMapMemoizeInteractiveElementOutput(\n    async (_editor: MyEditor, computer: Computer, element: MyElement) => {\n      assertElementType(element, ELEMENT_VARIABLE_DEF);\n\n      if (element.children.length < 2) {\n        return [];\n      }\n\n      const { id, children } = element;\n      const variableName = getNodeString(children[0]);\n      let expression: string | AST.Expression = getNodeString(children[1]);\n\n      if (\n        element.variant === 'expression' ||\n        element.variant === 'date' ||\n        element.variant === 'toggle' ||\n        element.variant === 'dropdown'\n      ) {\n        const { type, coerced } = await inferType(computer, expression, {\n          type: element.coerceToType,\n        });\n        if (type.kind === 'anything' || type.kind === 'nothing') {\n          expression = {\n            type: 'noop',\n            args: [],\n          };\n        } else {\n          expression = coerced || '';\n        }\n        if (element.variant === 'dropdown') {\n          const dropdownVariable = parseElementAsVariableAssignment(\n            id,\n            variableName,\n            expression\n          );\n          // TODO: Refactor this part into function.\n          const dropdownOptions = (\n            await Promise.all(\n              element.children[1].options.map(async (option) => {\n                let dropdownExpression: string | AST.Expression;\n                const dropdownType = await inferType(computer, option.value, {\n                  type: element.coerceToType,\n                });\n                if (\n                  dropdownType.type.kind === 'anything' ||\n                  dropdownType.type.kind === 'nothing'\n                ) {\n                  dropdownExpression = {\n                    type: 'noop',\n                    args: [],\n                  };\n                } else {\n                  dropdownExpression = getDefined(dropdownType.coerced);\n                }\n                return parseElementAsVariableAssignment(\n                  option.id,\n                  getExprRef(option.id),\n                  dropdownExpression\n                );\n              })\n            )\n          ).flat();\n          return [...dropdownVariable, ...dropdownOptions];\n        }\n      }\n\n      return parseElementAsVariableAssignment(id, variableName, expression);\n    }\n  ),\n};\n","import { AST, Computer } from '@decipad/computer';\nimport {\n  MyElement,\n  MyEditor,\n  ELEMENT_LIVE_CONNECTION,\n} from '@decipad/editor-types';\nimport { assertElementType } from '@decipad/editor-utils';\nimport { getNodeString } from '@udecode/plate';\nimport { InteractiveLanguageElement } from '../types';\nimport { parseElementAsVariableAssignment } from '../utils/parseElementAsVariableAssignment';\nimport { weakMapMemoizeInteractiveElementOutput } from '../utils/weakMapMemoizeInteractiveElementOutput';\n\nexport const LiveConnection: InteractiveLanguageElement = {\n  type: ELEMENT_LIVE_CONNECTION,\n  getParsedBlockFromElement: weakMapMemoizeInteractiveElementOutput(\n    async (_editor: MyEditor, _computer: Computer, element: MyElement) => {\n      assertElementType(element, ELEMENT_LIVE_CONNECTION);\n      const name = getNodeString(element.children[0]);\n      const { id } = element;\n      const expression: AST.Expression = {\n        type: 'externalref',\n        args: [id],\n      };\n      return parseElementAsVariableAssignment(element.id, name, expression);\n    }\n  ),\n};\n","import { MyEditor, MyElement } from '@decipad/editor-types';\nimport type { Computer, Program } from '@decipad/computer';\nimport { isElement } from '@udecode/plate';\n\nimport * as interactiveLanguageElements from './elements';\nimport type { InteractiveLanguageElement } from './types';\n\nconst interactiveElementsByType = (() => {\n  const map: Array<[string, InteractiveLanguageElement]> = [];\n  for (const el of Object.values(\n    interactiveLanguageElements\n  ) as InteractiveLanguageElement[]) {\n    for (const t of [el.type].flat()) {\n      map.push([t, el]);\n    }\n  }\n  return new Map<string, InteractiveLanguageElement>(map);\n})();\n\n/**\n * Given an element, what are the language expressions, blocks or assignments that it represents?\n *\n * The result of this function, called once an element changes, is fed into the computer.\n */\nexport const elementToLanguageBlocks = async (\n  editor: MyEditor,\n  computer: Computer,\n  element: MyElement\n): Promise<Program | null> => {\n  const interactiveElement = interactiveElementsByType.get(element.type);\n  if (!interactiveElement) {\n    return null;\n  }\n\n  const blocks: Program = [];\n  if (interactiveElement.isStructural) {\n    for (const child of element.children) {\n      if (isElement(child)) {\n        blocks.push(\n          // eslint-disable-next-line no-await-in-loop\n          ...((await elementToLanguageBlocks(editor, computer, child)) ?? [])\n        );\n      }\n    }\n  }\n\n  // blocks that return code:\n  if (interactiveElement.getParsedBlockFromElement) {\n    try {\n      blocks.push(\n        ...(await interactiveElement.getParsedBlockFromElement(\n          editor,\n          computer,\n          element\n        ))\n      );\n    } catch (err) {\n      console.error('Error getting parsed block from element', err);\n      console.error('Error happened on element', element);\n    }\n  }\n\n  return blocks;\n};\n","import { MyEditor } from '@decipad/editor-types';\nimport type { Computer, ComputeRequest, Program } from '@decipad/computer';\nimport { elementToLanguageBlocks } from './elementToLanguageBlock';\n\nexport const editorToProgram = async (\n  editor: MyEditor,\n  computer: Computer\n): Promise<ComputeRequest> => {\n  const program: Program = [];\n\n  for (const element of editor.children) {\n    if (!('type' in element) || !('id' in element)) {\n      continue;\n    }\n\n    // eslint-disable-next-line no-await-in-loop\n    const blockResult = await elementToLanguageBlocks(\n      editor,\n      computer,\n      element\n    );\n    if (!blockResult) {\n      continue;\n    }\n\n    program.push(...blockResult);\n  }\n\n  return { program };\n};\n","export {\n  ELEMENT_BLOCKQUOTE,\n  // Code\n  ELEMENT_CODE_BLOCK as DEPRECATED_ELEMENT_CODE_BLOCK,\n  ELEMENT_CODE_LINE,\n  ELEMENT_H1,\n  ELEMENT_H2,\n  ELEMENT_H3,\n  ELEMENT_IMAGE,\n  ELEMENT_LI,\n  ELEMENT_LIC,\n  // Inline\n  ELEMENT_LINK,\n  ELEMENT_MEDIA_EMBED,\n  ELEMENT_OL,\n  // Text blocks\n  ELEMENT_PARAGRAPH,\n  // Lists\n  ELEMENT_UL,\n} from '@udecode/plate';\n\n// Layout\nexport const ELEMENT_CALLOUT = 'callout';\nexport const ELEMENT_COLUMNS = 'columns';\nexport const ELEMENT_HR = 'divider';\n\n// inputs\nexport const ELEMENT_FETCH = 'fetch-data';\nexport const ELEMENT_IMPORT = 'import';\nexport const ELEMENT_PLOT = 'plot';\nexport const ELEMENT_VARIABLE_DEF = 'def';\nexport const ELEMENT_CODE_LINE_V2 = 'code_line_v2';\nexport const ELEMENT_STRUCTURED_VARNAME = 'structured_varname';\nexport const ELEMENT_CODE_LINE_V2_CODE = 'code_line_v2_code';\nexport const ELEMENT_EXPRESSION = 'exp';\nexport const ELEMENT_DROPDOWN = 'dropdown';\nexport const ELEMENT_SLIDER = 'slider';\nexport const ELEMENT_STRUCTURED_IN = 'structured_input';\nexport const ELEMENT_STRUCTURED_IN_CHILD = 'structured_input_child';\n\nexport const ELEMENT_DISPLAY = 'display';\n\n// Interactive\nexport const DEPRECATED_ELEMENT_INPUT = 'input';\nexport const ELEMENT_EVAL = 'eval';\n\n// Inlines\nexport const ELEMENT_INLINE_NUMBER = 'inline-number';\n\n// tables\nexport const DEPRECATED_ELEMENT_TABLE_INPUT = 'table-input'; // legacy\nexport const ELEMENT_TABLE = 'table';\nexport const ELEMENT_TABLE_CAPTION = 'table-caption';\nexport const ELEMENT_TR = 'tr';\nexport const ELEMENT_TH = 'th';\nexport const ELEMENT_TD = 'td';\nexport const ELEMENT_TABLE_COLUMN_FORMULA = 'table-column-formula';\nexport const ELEMENT_TABLE_VARIABLE_NAME = 'table-var-name';\n\n// data-views\nexport const ELEMENT_DATA_VIEW = 'data-view';\nexport const ELEMENT_DATA_VIEW_CAPTION = 'data-view-caption';\nexport const ELEMENT_DATA_VIEW_NAME = 'data-view-name';\nexport const ELEMENT_DATA_VIEW_TR = 'data-view-tr';\nexport const ELEMENT_DATA_VIEW_TH = 'data-view-th';\n\n// live connection\nexport const ELEMENT_LIVE_CONNECTION = 'live-conn';\nexport const ELEMENT_LIVE_CONNECTION_VARIABLE_NAME = 'live-var-name';\n\n// smart refs\nexport const ELEMENT_SMART_REF = 'smart-ref';\n\n// draws\nexport const ELEMENT_DRAW = 'draw';\nexport const ELEMENT_SELECTION = 'selection';\nexport const ELEMENT_RECTANGLE = 'rectangle';\nexport const ELEMENT_DIAMOND = 'diamond';\nexport const ELEMENT_ELLIPSE = 'ellipse';\nexport const ELEMENT_TEXT = 'text';\nexport const ELEMENT_LINEAR = 'linear';\nexport const ELEMENT_LINE = 'line';\nexport const ELEMENT_FREEDRAW = 'freedraw';\nexport const ELEMENT_DRAW_IMAGE = 'image';\n\n// others\nexport const ELEMENT_CAPTION = 'caption';\n","import { MyElement } from '@decipad/editor-types';\nimport { isElement } from '@udecode/plate';\nimport { Node } from 'slate';\n\nexport function assertElementType<Type extends MyElement['type']>(\n  node: Node | undefined,\n  type: Type\n): asserts node is Extract<MyElement, { type: Type }> {\n  if (!isElement(node) || node.type !== type) {\n    throw new Error(`Expected element type to be ${type}`);\n  }\n}\n","import { getNodeString, isText } from '@udecode/plate';\nimport {\n  CodeLineElement,\n  CodeLineV2ElementCode,\n  ELEMENT_SMART_REF,\n  TableColumnFormulaElement,\n} from '@decipad/editor-types';\nimport { getExprRef } from '@decipad/computer';\nimport { isElementOfType } from './isElementOfType';\n\nexport const getCodeLineSource = (\n  node: CodeLineElement | TableColumnFormulaElement | CodeLineV2ElementCode\n) => {\n  const childCount = node.children.length;\n  const res = node.children\n    .map((c, i) => {\n      if (isElementOfType(c, ELEMENT_SMART_REF)) {\n        const needsWhitespaceBefore =\n          i >= 1 &&\n          (!isText(node.children[i - 1]) ||\n            !getNodeString(node.children[i - 1]).endsWith(' '));\n        const needsWhitespaceAfter =\n          i < childCount - 1 &&\n          (!isText(node.children[i + 1]) ||\n            !getNodeString(node.children[i + 1]).startsWith(' '));\n\n        const bspc = needsWhitespaceBefore ? ' ' : '';\n        const aspc = needsWhitespaceAfter ? ' ' : '';\n        return bspc + getExprRef(c.blockId) + aspc;\n      }\n      return getNodeString(c);\n    })\n    .join('');\n  return res;\n};\n","import { MyElement } from '@decipad/editor-types';\nimport { isElement } from '@udecode/plate';\nimport { Node } from 'slate';\n\nexport const isElementOfType = <Type extends MyElement['type']>(\n  node: Node | undefined,\n  type: Type\n): node is Extract<MyElement, { type: Type }> =>\n  isElement(node) && node.type === type;\n","import { MyElement } from '@decipad/editor-types';\n\n/** Get the (unstable) ID for a magic number. */\nexport const magicNumberId = (\n  element: MyElement,\n  childIndex: number\n): string => {\n  return `${element.id}-${childIndex}`;\n};\n"],"names":["statementToIdentifiedBlock","id","stat","definesVariable","definesTableColumn","type","block","args","parseElementAsSourceCode","blockId","source","sourceKind","solution","error","parseStatement","parseExpression","errorKind","weakMapMemoizeInteractiveElementOutput","fn","cache","WeakMap","async","editor","computer","arg","cached","get","set","getUnparsedBlockFromCodeLine","_editor","_computer","ELEMENT_CODE_LINE","getCodeLineSource","CodeLine","getParsedBlockFromElement","parseElementAsVariableAssignment","varName","disallowedNodeTypes","expression","trim","undefined","disallowNodeTypes","tryParseAsNumber","e","vname","sourcetext","children","getNodeString","typeHint","unit","kind","numberFormat","getUnitFromText","parsedInput","parseCell","Error","parseStructuredCodeLine","assertElementType","ELEMENT_CODE_LINE_V2","asNumber","length","interpretedAs","programChunk","N","CodeLineV2","getUnparsedBlockFromEval","ELEMENT_EVAL","result","Eval","Paragraph","ELEMENT_PARAGRAPH","ELEMENT_CALLOUT","ELEMENT_LI","ELEMENT_OL","ELEMENT_LIC","ELEMENT_UL","isStructural","element","flatMap","child","index","MARK_MAGICNUMBER","magicNumberId","astNode","astColumn","items","simpleError","message","tableFormulaColumnToColumn","table","th","columnName","formula","find","ELEMENT_TABLE_COLUMN_FORMULA","columnId","isElementOfType","columnFormulaBlockId","errors","elementId","formulaSourceToColumnAssign","seriesColumnToColumn","columnIndex","dataRows","cellType","firstDataRow","content","rowCount","granularity","parseSeriesStart","it","seriesIterator","getDefined","v","Promise","all","Array","from","previous","next","value","date","filter","isExpression","seriesColumn","seriesType","headerToColumn","props","cellTexts","cellIds","tr","td","push","map","text","getNullReplacementValue","dropdownColumnToColumn","columnType","inferColumn","userType","parsed","dataColumnToColumn","getTableAstNodeFromTableElement","caption","headerRow","tableName","columnAssigns","col","tableBlockId","column","toColumnAssign","name","Table","ELEMENT_TABLE","tableItself","getDefinedSymbol","columnAssign","getColumnNameFromTableColumnAssign","Column","ELEMENT_COLUMNS","StructuredInput","ELEMENT_STRUCTURED_IN","VariableDef","ELEMENT_VARIABLE_DEF","variableName","variant","coerced","inferType","coerceToType","options","dropdownExpression","dropdownType","option","getExprRef","flat","LiveConnection","ELEMENT_LIVE_CONNECTION","interactiveElementsByType","el","Object","values","interactiveLanguageElements","t","Map","elementToLanguageBlocks","interactiveElement","blocks","isElement","err","console","editorToProgram","program","blockResult","ELEMENT_HR","ELEMENT_FETCH","ELEMENT_IMPORT","ELEMENT_PLOT","ELEMENT_STRUCTURED_VARNAME","ELEMENT_CODE_LINE_V2_CODE","ELEMENT_EXPRESSION","ELEMENT_DROPDOWN","ELEMENT_SLIDER","ELEMENT_STRUCTURED_IN_CHILD","ELEMENT_DISPLAY","DEPRECATED_ELEMENT_INPUT","ELEMENT_INLINE_NUMBER","DEPRECATED_ELEMENT_TABLE_INPUT","ELEMENT_TABLE_CAPTION","ELEMENT_TR","ELEMENT_TH","ELEMENT_TD","ELEMENT_TABLE_VARIABLE_NAME","ELEMENT_DATA_VIEW","ELEMENT_DATA_VIEW_CAPTION","ELEMENT_DATA_VIEW_NAME","ELEMENT_DATA_VIEW_TR","ELEMENT_DATA_VIEW_TH","ELEMENT_LIVE_CONNECTION_VARIABLE_NAME","ELEMENT_SMART_REF","ELEMENT_DRAW","ELEMENT_SELECTION","ELEMENT_RECTANGLE","ELEMENT_DIAMOND","ELEMENT_ELLIPSE","ELEMENT_TEXT","ELEMENT_LINEAR","ELEMENT_LINE","ELEMENT_FREEDRAW","ELEMENT_DRAW_IMAGE","ELEMENT_CAPTION","node","childCount","c","i","needsWhitespaceBefore","isText","endsWith","aspc","startsWith","join","childIndex"],"sourceRoot":""}