diff --git a/node_modules/@docusaurus/core/lib/server/brokenLinks.js b/node_modules/@docusaurus/core/lib/server/brokenLinks.js
index 0d8890d..0b9432f 100644
--- a/node_modules/@docusaurus/core/lib/server/brokenLinks.js
+++ b/node_modules/@docusaurus/core/lib/server/brokenLinks.js
@@ -38,7 +38,8 @@ function getPageBrokenLinks({ pagePath, pageLinks, routes, }) {
             .reduce((prev, cur) => prev.concat(cur));
         return matchedRoutes.length === 0;
     }
-    return pageLinks.map(resolveLink).filter((l) => isBrokenLink(l.resolvedLink));
+    const links = Array.from(pageLinks).map((l) => Array.from(l)).flat(Infinity);
+    return links.map(resolveLink).filter((l) => (typeof l === 'string') && isBrokenLink(l.resolvedLink));
 }
 // The route defs can be recursive, and have a parent match-all route
 // We don't want to match broken links like /docs/brokenLink against /docs/*
@@ -115,7 +116,13 @@ async function filterExistingFileLinks({ baseUrl, outDir, allCollectedLinks, })
         }
         return filePathsToTry.some(isExistingFile);
     }
-    return (0, lodash_1.mapValues)(allCollectedLinks, (links) => links.filter((link) => !linkFileExists(link)));
+    return (0, lodash_1.mapValues)(allCollectedLinks, (links) => {
+      return Array.from(links).map(
+        (l) => Array.from(l)
+          .flat(Infinity)
+          .filter((link) => !linkFileExists(link))
+      );
+    });
 }
 exports.filterExistingFileLinks = filterExistingFileLinks;
 async function handleBrokenLinks({ allCollectedLinks, onBrokenLinks, routes, baseUrl, outDir, }) {
