diff --git a/node_modules/@architect/sandbox/src/invoke-lambda/env/index.js b/node_modules/@architect/sandbox/src/invoke-lambda/env/index.js
index aa09dfe..7e19c07 100644
--- a/node_modules/@architect/sandbox/src/invoke-lambda/env/index.js
+++ b/node_modules/@architect/sandbox/src/invoke-lambda/env/index.js
@@ -22,6 +22,7 @@ module.exports = function getEnv (params, requestID) {
 
   // Runtime environment variables
   let env = {
+    ...process.env,
     // AWS-specific
     AWS_ACCESS_KEY_ID,
     AWS_LAMBDA_FUNCTION_MEMORY_SIZE: lambda.config.memory,
diff --git a/node_modules/@architect/sandbox/src/invoke-lambda/exec/execute.js b/node_modules/@architect/sandbox/src/invoke-lambda/exec/execute.js
new file mode 100644
index 0000000..e362723
--- /dev/null
+++ b/node_modules/@architect/sandbox/src/invoke-lambda/exec/execute.js
@@ -0,0 +1,53 @@
+let errors = require('../../lib/errors')
+let { invocations } = require('../../arc/_runtime-api')
+let { workerFor } = require('./workers');
+let { getEnv } = require('./get-env')
+let { getPorts } = require('./get-ports')
+
+module.exports = function execute (lambda, params, request, callback) {
+  const { context, timeout, requestID } = params;
+  const { update } = context;
+
+  let timedOut = false
+  let replied = false
+
+  // Let's go!
+  const ports = getPorts(params.options.env);
+  const env = getEnv(params.options.env, ports);
+  const worker = workerFor(lambda.handlerFile, env, update);
+  worker.work(request, (err, response) => {
+    returned = true;
+    done(err, response);
+  });
+
+  // Set an execution timeout
+  let to = setTimeout(function () {
+    timedOut = true
+    let duration = `${timeout / 1000}s`
+    update.warn(`[${requestID}] ${lambda.handlerFile} timed out after hitting its ${duration} timeout!`)
+    done(new Error(`${duration} timeout`))
+  }, timeout)
+
+
+  // End execution
+  function done (err, response) {
+    clearTimeout(to);
+    if (replied) {
+      return;
+    }
+    if (err) {
+      console.error(err);
+      invocations[requestID].error = errors({
+        lambdaError: {
+          errorType: `Function is missing or not defined, or unknown execution error`,
+          errorMessage: `<p>${err.message ?? err}</p>`,
+        },
+        lambda,
+      })
+    } else {
+      invocations[requestID].response = response;
+    }
+    replied = true;
+    callback()
+  }
+}
diff --git a/node_modules/@architect/sandbox/src/invoke-lambda/exec/get-env.js b/node_modules/@architect/sandbox/src/invoke-lambda/exec/get-env.js
new file mode 100644
index 0000000..e1963ac
--- /dev/null
+++ b/node_modules/@architect/sandbox/src/invoke-lambda/exec/get-env.js
@@ -0,0 +1,14 @@
+const defaultEnv = (ports) => ({
+  ARC_WSS_URL: `ws://localhost:${ports.http}/ws`,
+});
+
+module.exports.getEnv = function getEnv(_env, ports) {
+  const env = {...process.env, ..._env};
+  for (const [key, value] of Object.entries(defaultEnv(ports))) {
+    if (!env[key]) {
+      env[key] = value;
+    }
+  }
+  delete env.AWS_PROFILE;
+  return env;
+};
diff --git a/node_modules/@architect/sandbox/src/invoke-lambda/exec/get-ports.js b/node_modules/@architect/sandbox/src/invoke-lambda/exec/get-ports.js
new file mode 100644
index 0000000..181ed79
--- /dev/null
+++ b/node_modules/@architect/sandbox/src/invoke-lambda/exec/get-ports.js
@@ -0,0 +1,8 @@
+module.exports.getPorts = function getPorts(env) {
+  const sandbox = env.ARC_SANDBOX;
+  if (!sandbox) {
+    throw new Error('Expected env.ARC_SANDBOX');
+  }
+  const parsedSandbox = JSON.parse(sandbox);
+  return parsedSandbox.ports;
+};
diff --git a/node_modules/@architect/sandbox/src/invoke-lambda/exec/index.js b/node_modules/@architect/sandbox/src/invoke-lambda/exec/index.js
index 02fec75..47156c4 100644
--- a/node_modules/@architect/sandbox/src/invoke-lambda/exec/index.js
+++ b/node_modules/@architect/sandbox/src/invoke-lambda/exec/index.js
@@ -1,13 +1,11 @@
 let _asap = require('@architect/asap')
-let load = require('./loader')
-let spawn = require('./spawn')
-let { runtimeEval } = require('../../lib')
+let execute = require('./execute')
 let { invocations } = require('../../arc/_runtime-api')
 
 module.exports = function exec (lambda, params, callback) {
   // ASAP is a special case that doesn't spawn
+  let { context, requestID } = params
   if (lambda.arcStaticAssetProxy) {
-    let { context, requestID } = params
     let asap = _asap({
       // Runs ASAP in local mode, skipping bucket config / env var checks, etc.
       env: 'testing',
@@ -23,30 +21,7 @@ module.exports = function exec (lambda, params, callback) {
       })
       .catch(callback)
   }
-  // Built-in runtimes or custom runtimes that rely on a `baseRuntime`
   else {
-    let run = getRuntime(lambda)
-    if (run === '_compiled') {
-      var command = lambda.handlerFile
-      var args = []
-    }
-    else {
-      let bootstrap = load()[run]
-      var { command, args } = runtimeEval[run](bootstrap)
-    }
-    spawn({ command, args, ...params, lambda }, callback)
+    execute(lambda, params, invocations[requestID].request, callback)
   }
 }
-
-function getRuntime ({ config, handlerModuleSystem }) {
-  let { runtime, runtimeConfig } = config
-  let run = runtimeConfig?.baseRuntime || runtime
-  if (run.startsWith('node')) {
-    if (handlerModuleSystem === 'esm') return 'node-esm'
-    return 'node'
-  }
-  else if (run.startsWith('deno'))   return 'deno'
-  else if (run.startsWith('ruby'))   return 'ruby'
-  else if (run.startsWith('python')) return 'python'
-  else if (runtimeConfig?.type === 'compiled') return '_compiled'
-}
diff --git a/node_modules/@architect/sandbox/src/invoke-lambda/exec/run.js b/node_modules/@architect/sandbox/src/invoke-lambda/exec/run.js
new file mode 100644
index 0000000..b39dd33
--- /dev/null
+++ b/node_modules/@architect/sandbox/src/invoke-lambda/exec/run.js
@@ -0,0 +1,91 @@
+/* eslint-disable no-console */
+const { parentPort, workerData } = require('worker_threads');
+const { join } = require('path');
+const { existsSync: exists, readFileSync: read } = require('fs');
+
+let { functionPath } = workerData;
+
+if (functionPath.endsWith('.mjs')) {
+  functionPath = `${functionPath.substring(
+    0,
+    functionPath.indexOf('.mjs')
+  )}.js`;
+}
+
+const handlerFunction = 'handler';
+const cwd = process.cwd();
+let fn = loadFunction();
+
+/* Enumerate package files */
+const pkg = (dir) =>
+  exists(join(dir, 'package.json')) &&
+  JSON.parse(read(join(dir, 'package.json')));
+const lambdaPackage = pkg(cwd);
+
+const debug = [{ note: 'Execution metadata', cwd, lambdaPackage }];
+
+function callback(err, result) {
+  if (err) console.log(err);
+  const payload = err
+    ? { name: err.name, message: err.message, stack: err.stack }
+    : result;
+  if (payload) payload.__DEP_ISSUES__ = [];
+  if (payload) payload.__DEP_DEBUG__ = debug;
+
+  parentPort.postMessage(payload);
+}
+
+parentPort.on('message', (event) => {
+  let calledback = false;
+  const callbackGuard = (err, result) => {
+    if (!calledback) {
+      calledback = true;
+      callback(err, result);
+    }
+  };
+  if (!fn) {
+    fn = loadFunction();
+  }
+  if (!fn) {
+    callbackGuard(
+      new Error(`Could not find handler for function ${functionPath}`)
+    );
+    return;
+  }
+  const context = {};
+  try {
+    const result = fn(event, context, callbackGuard);
+    if (result instanceof Promise) {
+      result
+        .then((res) => callbackGuard(null, res))
+        .catch((err) => callbackGuard(err));
+    } else if (typeof result !== 'undefined') {
+      callbackGuard(null, result);
+    }
+  } catch (err) {
+    console.error('unexpected lambda error', err);
+    callbackGuard(err);
+  }
+});
+
+parentPort.postMessage('ready');
+
+function loadFunction() {
+  try {
+    const resolved = require.resolve(functionPath);
+    // always fresh
+    delete require.cache[resolved];
+    // eslint-disable-next-line import/no-dynamic-require
+    const func = require(functionPath)[handlerFunction]; // eslint-disable-line global-require
+    if (typeof func !== 'function') {
+      throw new Error(
+        `${functionPath} is not a function: ${typeof func}, ${func}`
+      );
+    }
+
+    return func;
+  } catch (err) {
+    console.error(err);
+    return undefined;
+  }
+}
diff --git a/node_modules/@architect/sandbox/src/invoke-lambda/exec/spawn.js b/node_modules/@architect/sandbox/src/invoke-lambda/exec/spawn.js
deleted file mode 100644
index 54beb54..0000000
--- a/node_modules/@architect/sandbox/src/invoke-lambda/exec/spawn.js
+++ /dev/null
@@ -1,167 +0,0 @@
-let { spawn } = require('child_process')
-let { readdirSync } = require('fs')
-let kill = require('tree-kill')
-let errors = require('../../lib/errors')
-let { invocations } = require('../../arc/_runtime-api')
-
-module.exports = function spawnChild (params, callback) {
-  let { args, context, command, lambda, options, requestID, timeout } = params
-  let { apiType, update } = context
-  let isInLambda = process.env.AWS_LAMBDA_FUNCTION_NAME
-  let timedOut = false
-
-  // Let's go!
-  let child = spawn(command, args, options)
-  let pid = child.pid
-  let error
-  let closed
-
-  child.stdout.on('data', data => process.stdout.write('\n' + data))
-  child.stderr.on('data', data => process.stderr.write('\n' + data))
-  child.on('error', err => {
-    error = err
-    // Seen some non-string oob errors come via binary compilation
-    if (err.code) shutdown('error')
-  })
-  child.on('close', (code, signal) => {
-    update.debug.status(`[${requestID}] Emitted 'close' (pid ${pid}, code '${code}', signal '${signal}')`)
-    shutdown('child process closure')
-  })
-
-  // Set an execution timeout
-  let to = setTimeout(function () {
-    timedOut = true
-    let duration = `${timeout / 1000}s`
-    update.warn(`[${requestID}] Timed out after hitting its ${duration} timeout!`)
-    shutdown(`${duration} timeout`)
-  }, timeout)
-
-  // Terminate once we find a result from the runtime API
-  // 25ms is arbitrary, but hopefully it should be solid enough
-  let check = setInterval(function () {
-    if (invocations[requestID].response ||
-        invocations[requestID].initError ||
-        invocations[requestID].error) {
-      shutdown('runtime API completion check')
-    }
-  }, 25)
-
-  // Ensure we don't have dangling processes due to open connections, etc. before we wrap up
-  function shutdown (event) {
-    // Immediately shut down all timeouts and intervals
-    clearTimeout(to)
-    clearInterval(check)
-
-    // Only ever begin the shutdown process once per execution
-    if (closed) return
-    closed = true
-
-    update.debug.status(`[${requestID}] Shutting down (pid ${pid}, via ${event})`)
-
-    // Check if the process with specified PID is running or not
-    // Stolen from: https://github.com/nisaacson/is-running/blob/master/index.js
-    let isRunning = true
-    try {
-      // Signal 0 is a special node construct, see: https://nodejs.org/docs/latest-v14.x/api/process.html#process_process_kill_pid_signal
-      isRunning = process.kill(pid, 0)
-    }
-    catch (err) {
-      isRunning = err.code === 'EPERM'
-    }
-
-    // Wrap up here if we can verify the process is no longer running
-    if (!isRunning) {
-      update.debug.status(`[${requestID}] Process is no longer running (pid ${pid}, process closed: ${isRunning}; termination is not necessary)`)
-      done()
-      return
-    }
-
-    // Ok, so the process is still running (which is totally normal!)
-    update.debug.status(`[${requestID}] Process is still running, terminating pid ${pid} now...`)
-    if (error) {
-      update.error(`[${requestID}] Caught child process execution error (pid ${pid})`)
-    }
-
-    let isTesting = process.env.CI || process.env.NODE_ENV === 'testing'
-    // During testing/CI, the server is constantly being started and stopped
-    // This may create race conditions for compiled Lambdae, which may request the `/next` runtime API endpoint only to discover the Sandbox has already shut down
-    // Under normal end-user circumstances, we can go ahead and respond to clients immediately while Lambda process termination carries on in the background
-    if (!isTesting) {
-      done()
-    }
-
-    if (!isInLambda) {
-      kill(pid, 'SIGINT', err => {
-        if (err) {
-          update.debug.status(`[${requestID}] tree-kill process termination error (pid ${pid})`)
-          update.debug.raw(err)
-        }
-        else update.debug.status(`[${requestID}] Successfully terminated process (pid ${pid})`)
-        // If we're in CI, it's best to wait for processes to terminate, even if slightly slower
-        if (isTesting) done()
-      })
-    }
-    else {
-      // tree-kill relies on *nix `ps`, which Lambda doesn't have â€“ but it does have /proc
-      // Node process.kill() + Lambda Linux /proc/<pid>/task/<tid> is mysterious, so this may not be the best or proper approach
-      try {
-        let tasks = readdirSync(`/proc/${pid}/task`)
-        tasks.forEach(tid => {
-          try { process.kill(tid) }
-          catch (err) {
-            // Task may have ended naturally or been killed by killing child.pid, I guess we don't really know
-            update.debug.status(`[${requestID}] Did not kill task (pid ${pid}, tid ${tid})`)
-            update.debug.raw(err)
-          }
-        })
-        update.debug.status(`[${requestID}] Process (probably) successfully terminated inside Lambda (pid ${pid})`)
-        // If we're in CI, it's best to wait for processes to terminate, even if slightly slower
-        if (isTesting) done()
-      }
-      catch (err) {
-        update.debug.status(`[${requestID}] Failed to terminate process inside Lambda (pid ${pid})`)
-        update.debug.raw(err)
-      }
-    }
-  }
-
-  // End execution
-  function done () {
-    let completed = invocations[requestID].response ||
-                    invocations[requestID].initError ||
-                    invocations[requestID].error
-    if (timedOut) {
-      invocations[requestID].error = errors({
-        lambdaError: {
-          errorType: 'Timeout error',
-          errorMessage: `<p>Lambda timed out after <b>${timeout / 1000} seconds</b></p>`,
-        },
-        lambda,
-      })
-    }
-    else if (error) {
-      invocations[requestID].error = errors({
-        lambdaError: {
-          errorType: `Function is missing or not defined, or unknown execution error`,
-          errorMessage: `<p>${error}</p>`,
-        },
-        lambda,
-      })
-    }
-    else if (![ 'http', 'httpv2' ].includes(apiType) && !completed) {
-      invocations[requestID].error = errors({
-        lambdaError: {
-          errorType: `No response found`,
-          errorMessage: `Lambda did not execute the completion callback or return a value`,
-          additional: `Dependency-free functions, or functions that use <code>@architect/functions arc.http.async()</code> must return a correctly formatted response object.</p>
-
-<p>Functions that utilize <code>@architect/functions arc.http()</code> must ensure <code>res</code> gets called</p>
-
-<p>Learn more about <a href="https://arc.codes/primitives/http">dependency-free responses</a>, or about using <code><a href="https://arc.codes/reference/functions/http/node/classic">arc.http()</a></code> and <code><a href="https://arc.codes/reference/functions/http/node/async">arc.http.async()</a></code>.`,
-        },
-        lambda,
-      })
-    }
-    callback()
-  }
-}
diff --git a/node_modules/@architect/sandbox/src/invoke-lambda/exec/workers.js b/node_modules/@architect/sandbox/src/invoke-lambda/exec/workers.js
new file mode 100644
index 0000000..1f4bcfb
--- /dev/null
+++ b/node_modules/@architect/sandbox/src/invoke-lambda/exec/workers.js
@@ -0,0 +1,130 @@
+const { Worker } = require('worker_threads');
+const assert = require('assert');
+const watch = require('node-watch');
+
+const workerPath = `${__dirname}/run.js`;
+const workers = new Map();
+
+function createWorkerFor(functionName, env, update) {
+  const workQueue = [];
+  const replyQueue = [];
+
+  if (functionName.endsWith('.mjs')) {
+    // eslint-disable-next-line no-param-reassign
+    functionName =
+      // eslint-disable-next-line prefer-template
+      functionName.substring(0, functionName.indexOf('.mjs')) + '.js';
+  }
+
+  const workerData = {
+    functionPath: functionName,
+  };
+
+  const workerOptions = {
+    env,
+    workerData,
+    stdout: true,
+    stderr: true,
+  };
+
+  const fn = {
+    worker: new Worker(workerPath, workerOptions),
+    ready: false,
+    working: false,
+    terminating: false,
+    work,
+  };
+
+  const dir = functionName.slice(0, functionName.lastIndexOf('/'));
+
+  const w = watch(
+    dir,
+    {
+      recursive: true,
+    },
+    () => {
+      update.status(`function ${functionName} changed`);
+      w.close();
+      fn.terminating = true;
+      fn.worker.terminate();
+    }
+  );
+
+  fn.worker.on('message', (message) => {
+    if (message === 'ready') {
+      assert(!fn.ready, 'worker is already ready');
+      fn.ready = true;
+      maybeWork();
+      return;
+    }
+    assert(fn.ready, 'should be ready when getting a response message');
+    assert(
+      fn.working,
+      'worker should be working when getting a response message'
+    );
+    replyWith(null, message || '');
+  });
+
+  fn.worker.once('error', (err) => {
+    update.error(`worker ${functionName} error:\n${err.stack}`);
+    while (replyQueue.length > 0) {
+      replyWith(err);
+    }
+  });
+
+  fn.worker.once('exit', () => {
+    let err;
+    if (!fn.terminating) {
+      update.error(`worker exited prematurely: ${functionName} `, functionName);
+      err = new Error('Worker exited prematurely');
+    } else {
+      err = new Error('Worker exited without reply');
+      update.status(`worker exited: ${functionName} `, functionName);
+    }
+    while (replyQueue.length > 0) {
+      replyWith(err);
+    }
+    workers.delete(functionName);
+  });
+
+  fn.worker.stderr.on('data', (d) => {
+    update.error(`${functionName}:\n${d}`);
+  });
+  fn.worker.stdout.on('data', (d) => {
+    update.status(`${functionName}:\n${d}`);
+  });
+
+  return fn;
+
+  function maybeWork() {
+    if (workQueue.length === 0 || !fn.ready || fn.working) {
+      return;
+    }
+    fn.working = true;
+    const nextWork = workQueue.splice(0, 1)[0];
+    fn.worker.postMessage(nextWork);
+  }
+
+  function replyWith(error, response) {
+    fn.working = false;
+    const reply = replyQueue.splice(0, 1)[0];
+    reply(error, response || '');
+    maybeWork();
+  }
+
+  function work(request, callback) {
+    workQueue.push(request);
+    replyQueue.push(callback);
+    maybeWork();
+  }
+}
+
+module.exports.workerFor = function workerFor(functionName, env, update) {
+  let fn = workers.get(functionName);
+  if (!fn) {
+    fn = createWorkerFor(functionName, env, update);
+    workers.set(functionName, fn);
+  }
+
+  return fn;
+};
diff --git a/node_modules/@architect/sandbox/src/invoke-lambda/warn.js b/node_modules/@architect/sandbox/src/invoke-lambda/warn.js
index 2413332..625da81 100644
--- a/node_modules/@architect/sandbox/src/invoke-lambda/warn.js
+++ b/node_modules/@architect/sandbox/src/invoke-lambda/warn.js
@@ -20,7 +20,7 @@ module.exports = function warn (params) {
     })
 
     // Remove AWS-SDK, that's bundled in Lambda
-    missing = missing.filter(dep => !dep.endsWith('::aws-sdk'))
+    missing = missing.filter(dep => !dep.includes('aws-sdk'))
     // Do we still have anything left?
     if (missing.length) {
       let plural = missing.length > 1
