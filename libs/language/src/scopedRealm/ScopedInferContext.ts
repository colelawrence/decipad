/* eslint-disable no-underscore-dangle */
// eslint-disable-next-line no-restricted-imports
import type { ContextUtils, Type } from '@decipad/language-types';
// eslint-disable-next-line no-restricted-imports
import { buildType as t } from '@decipad/language-types';
import type { ExternalDataMap } from '@decipad/language-interfaces';
// eslint-disable-next-line no-restricted-imports
import { callBuiltin, callBuiltinFunctor } from '@decipad/language-builtins';
import type { AnyMapping } from '@decipad/utils';
import { produce, zip } from '@decipad/utils';
import type { InferContextUtils, TScopedInferContext } from './types';
import type {
  StackNamespaceJoiner,
  StackNamespaceSplitter,
  StackNamespaceRetrieverHackForTypesystemTables,
  TStackFrame,
} from './stack';
import { createStack } from './stack';
import { sortType } from '../infer/sortType';

export interface MakeContextArgs {
  initialGlobalScope?: AnyMapping<Type>;
  externalData?: ExternalDataMap;
  autoGeneratedVarNames?: Set<string>;
  contextUtils?: Partial<ContextUtils>;
  parent?: TScopedInferContext;
}

const typesToTable: StackNamespaceJoiner<Type> = (tableMapping, indexName) => {
  const cellCounts = Array.from(tableMapping.values())
    .map((t) => t.cellCount)
    .filter((t): t is number => t != null);

  const sortedTable = sortType(
    t.table({
      indexName,
      columnNames: [...tableMapping.keys()],
      columnTypes: [...tableMapping.values()],
      rowCount: cellCounts.length === 0 ? undefined : Math.max(...cellCounts),
    })
  );
  const indexColumnType = sortedTable.columnTypes?.[0];
  if (indexColumnType && indexColumnType.indexedBy) {
    return produce(sortedTable, (table) => {
      table.delegatesIndexTo = indexColumnType.indexedBy;
    });
  }
  return sortedTable;
};

const tableToTypes: StackNamespaceSplitter<Type> = (tableMapping) => {
  if (tableMapping.columnNames && tableMapping.columnTypes) {
    return zip(tableMapping.columnNames, tableMapping.columnTypes);
  }
  return undefined;
};

const getTableColumnAsAGoddamnColumn: StackNamespaceRetrieverHackForTypesystemTables<
  Type
> = (column, table) => {
  return t.column(column, table.indexName);
};

export class ScopedInferContext implements TScopedInferContext {
  stack: TStackFrame<Type>;
  private parent?: TScopedInferContext;
  private _externalData: ExternalDataMap;
  private _autoGeneratedVarNames: Set<string>;
  /** Marks names retrieved during typecheck */
  usedNames: Array<[string, string]>;
  private _onGoingFunctionCalls: Set<string>;
  utils: InferContextUtils;

  constructor({
    initialGlobalScope = new Map(),
    externalData = new Map(),
    autoGeneratedVarNames = new Set(),
    parent,
    contextUtils,
  }: MakeContextArgs) {
    this.stack = createStack(
      initialGlobalScope,
      typesToTable,
      tableToTypes,
      getTableColumnAsAGoddamnColumn,
      parent?.stack
    );
    this.parent = parent;
    this._externalData = externalData;
    this._autoGeneratedVarNames = autoGeneratedVarNames;
    this._onGoingFunctionCalls = new Set();
    if (parent) {
      this.usedNames = parent.usedNames as Array<[string, string]>;
    } else {
      this.usedNames = [];
    }
    this.utils = {
      retrieveIndexByName: (indexName: string) => this.stack.get(indexName),
      retrieveVariableTypeByGlobalVariableName: (varName: string) =>
        this.stack.get(varName),
      callBuiltinFunctor,
      callBuiltin,
      ...contextUtils,
    };
  }

  get externalData() {
    return new Map([
      ...(this.parent?.externalData.entries() ?? []),
      ...this._externalData.entries(),
    ]);
  }

  setExternalData(externalData: ExternalDataMap) {
    this._externalData = externalData;
  }

  get autoGeneratedVarNames() {
    return new Set([
      ...(this.parent?.autoGeneratedVarNames ?? []),
      ...this._autoGeneratedVarNames,
    ]);
  }

  addUsedName(name: [string, string]): void {
    this.usedNames.push(name);
  }

  get onGoingFunctionCalls() {
    return new Set([
      ...(this.parent?.onGoingFunctionCalls ?? []),
      ...this._onGoingFunctionCalls,
    ]);
  }

  addOngoingFunctionCall(name: string): void {
    this._onGoingFunctionCalls.add(name);
  }

  removeOngoingFunctionCall(name: string): void {
    this._onGoingFunctionCalls.delete(name);
  }

  push(): TScopedInferContext {
    return new ScopedInferContext({
      parent: this,
      externalData: this.externalData,
      autoGeneratedVarNames: this.autoGeneratedVarNames,
    });
  }
}

export const makeInferContext = (args: MakeContextArgs = {}) =>
  new ScopedInferContext(args);
