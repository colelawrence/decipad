// eslint-disable-next-line no-restricted-imports
import type { ContextUtils, Type } from '@decipad/language-types';
import type { AST, ExternalDataMap, Value } from '@decipad/language-interfaces';
import type { ExpressionCache } from '../expression-cache';
import type { TStackFrame } from './stack';

export type InferContextUtils = Omit<
  ContextUtils,
  | 'simpleExpressionEvaluate'
  | 'retrieveVariableValueByGlobalVariableName'
  | 'retrieveHumanVariableNameByGlobalVariableName'
  | 'callValue'
  | 'callFunctor'
>;

export interface TScopedInferContext {
  push(): TScopedInferContext;
  stack: TStackFrame<Type>;
  utils: InferContextUtils;
  externalData: ExternalDataMap;
  setExternalData(externalData: ExternalDataMap): void;
  autoGeneratedVarNames: ReadonlySet<string>;
  /** Marks names retrieved during typecheck */
  usedNames: ReadonlyArray<readonly [string, string]>;
  addUsedName(name: readonly [string, string]): void;
  onGoingFunctionCalls: ReadonlySet<string>;
  addOngoingFunctionCall(name: string): void;
  removeOngoingFunctionCall(name: string): void;
}

export interface TScopedRealm {
  name: string;
  parent?: TScopedRealm;
  stack: TStackFrame<Value.Value>;
  previousRow: ReadonlyMap<string | symbol, Value.Value> | undefined;
  inferContext: TScopedInferContext;
  statementId?: string;
  expressionCache: ExpressionCache<Value.Value>;
  externalData: ExternalDataMap;
  setExternalData: (externalData: ExternalDataMap) => void;
  maybeGetTypeAt(node: AST.Node): Type | undefined;
  getTypeAt(node: AST.Node): Type;
  push(nameOfNewReal: string): TScopedRealm;
  clearCacheForSymbols(symbols: string[]): void;
  utils: ContextUtils;
  depth: number;
  toString(): string;
}

export type TRealm = TScopedRealm;
