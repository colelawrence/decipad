/* eslint-disable no-await-in-loop */
import type { Writable } from 'utility-types';
// eslint-disable-next-line no-restricted-imports
import { getConstantByName } from '@decipad/language-builtins';
import type { AST } from '@decipad/language-interfaces';
// eslint-disable-next-line no-restricted-imports
import {
  InferError,
  Type,
  deserializeType,
  Unit,
  parseUnit,
  buildType as t,
  isPendingType,
  isErrorType,
} from '@decipad/language-types';
// eslint-disable-next-line no-restricted-imports
import { getIdentifierString } from '@decipad/language-utils';
import { getDateFromAstForm } from '../date';
import { expandDirectiveToType } from '../directives';
import { inferTable } from '../tables/inference';
import { inferColumnAssign } from '../tables/column-assign';
import { logRetrievedName } from './logRetrievedName';
import { inferSequence } from './sequence';
import { inferMatrixAssign, inferMatrixRef } from '../matrix';
import { inferCategories } from '../categories';
import { inferFunctionDefinition, inferFunctionCall } from './functions';
import { inferMatch } from '../match/inferMatch';
import { inferTiered } from '../tiered/inferTiered';
import { sortType } from './sortType';
import { getDefined } from '@decipad/utils';
import type { TScopedInferContext, TRealm, TScopedRealm } from '../scopedRealm';
import { ScopedRealm, makeInferContext } from '../scopedRealm';

export { logRetrievedName };
export type { ContextStats } from './inferStats';
export { initialInferStats } from './inferStats';

export const linkToAST = (node: Writable<AST.Node>, type: Type) => {
  // here we mutate the AST to add the inferred type so that it can be accessible to
  // other stages of the pipeline
  node.inferredType = type;

  if (isErrorType(type) && type.node == null) {
    // here we return a new type based on the inferred one but with the node set to the current node
    return type.inNode(node);
  } else {
    return type;
  }
};

const linkingToAST =
  <T extends AST.Node>(
    fn: (realm: TRealm, node: T, coercingTo?: Type) => Promise<Type>
  ) =>
  async (realm: TRealm, node: T, coercingTo?: Type): Promise<Type> => {
    let type = await fn(realm, node);
    if (coercingTo) {
      type = await type.sameAs(coercingTo);
    }
    return linkToAST(node, type);
  };

/**
 Walk depth-first into an expanded AST.Expression, collecting the type of things beneath and checking it against the current iteration's constraints.

 Given a literal, this type is always known (barring casting).
 Given a function call, this type is given by calling the functor with the arguments' types.
 Given a condition, the functor is (thentype == elsetype) and its condition must be boolean

 AST.Assign is special-cased by looking at its expression and returning just that
*/
export const inferExpression = linkingToAST(
  // exhaustive switch
  // eslint-disable-next-line consistent-return, complexity
  async (realm: TRealm, expr: Writable<AST.Expression>): Promise<Type> => {
    const { inferContext: ctx } = realm;
    switch (expr.type) {
      case 'noop': {
        return t.nothing();
      }
      case 'ref': {
        const name = getIdentifierString(expr);
        const c = getConstantByName(name);
        if (c) {
          return c.type;
        }

        const fromStack = ctx.stack.get(name);
        if (fromStack) {
          logRetrievedName(ctx, name);
          return sortType(fromStack);
        }

        // create a unit with the name of the ref
        if (ctx.autoGeneratedVarNames.has(name) || expr.isMissing) {
          const missingName = expr.previousVarName ?? name;
          return t.impossible(
            new InferError({
              errType: 'unknown-reference',
              refName: missingName,
            }),
            expr
          );
        }
        return t.number([parseUnit(expr.previousVarName ?? name)]); // defaults to a unit with the ref name
      }
      case 'externalref': {
        const [id] = expr.args;
        const data = ctx.externalData.get(id);
        if (data) {
          return deserializeType(data.type);
        }
        return t.impossible(
          new InferError({ errType: 'unknown-reference', refName: id }),
          expr
        );
      }
      case 'literal': {
        const [litType] = expr.args;

        if (litType === 'number') {
          return t.number(null, expr.args[2]);
        }

        return t[litType]();
      }
      case 'range': {
        const [start, end] = await Promise.all(
          expr.args.map(async (expr) =>
            inferExpression(realm, getDefined(expr))
          )
        );
        const pending = [start, end].find(isPendingType);
        if (pending) {
          return pending;
        }

        return (await Type.combine(start, end)).mapType(async () => {
          const rangeOf = await (start.date != null
            ? start.sameAs(end)
            : (await start.isScalar('number')).sameAs(end));

          return t.range(rangeOf);
        });
      }
      case 'sequence': {
        return inferSequence(realm, expr, inferExpression);
      }
      case 'date': {
        const [, specificity] = getDateFromAstForm(expr.args);
        return t.date(specificity);
      }
      case 'column': {
        const [columnItems, optionalIndex] = expr.args;
        if (columnItems.args.length === 0) {
          return t.impossible(InferError.unexpectedEmptyColumn());
        }
        const [firstCellNode, ...restCellNodes] = columnItems.args;
        const firstCellType = await inferExpression(realm, firstCellNode);
        const restCellTypes = await Promise.all(
          restCellNodes.map(async (a) =>
            inferExpression(realm, a, firstCellType)
          )
        );

        // pending type is contagious
        const pending = [firstCellType, ...restCellTypes].find(isPendingType);
        if (pending) {
          return pending;
        }

        const erroredCell = [firstCellType, ...restCellTypes].find(isErrorType);

        if (erroredCell != null) {
          if (erroredCell.errorCause?.spec.errType === 'expected-but-got') {
            // Show a more useful error message for inconsistent cell types
            const [expected, got] = erroredCell.errorCause.spec.expectedButGot;
            return t.impossible(
              InferError.columnContainsInconsistentType(
                expected as Type,
                got as Type
              )
            );
          }

          return erroredCell;
        }

        for (const restCell of restCellTypes) {
          if (
            !Unit.matchUnitArraysForColumn(
              (await firstCellType.reducedToLowest()).unit,
              (await restCell.reducedToLowest()).unit
            )
          ) {
            return t.impossible(
              InferError.columnContainsInconsistentType(firstCellType, restCell)
            );
          }
        }
        return t.column(firstCellType, optionalIndex?.args[0]);
      }
      case 'property-access': {
        const [thing, prop] = expr.args;
        const propName = getIdentifierString(prop);
        const potentialTable = await inferExpression(realm, thing);
        // pending is contagious
        if (potentialTable.pending) {
          return potentialTable;
        }
        const table = await potentialTable.isTableOrRow();

        const tableName =
          thing.type === 'ref' ? thing.args[0] : table.indexName;

        const getFromTableOrRow = (
          names: string[],
          types: Type[]
        ): [Type, number] => {
          const index = names.indexOf(propName);
          if (index < 0) {
            return [
              t.impossible(
                InferError.unknownTableColumn(tableName ?? '', propName)
              ),
              index,
            ];
          }

          const originTable = table.indexName || table.rowIndexName;
          if (originTable) {
            logRetrievedName(ctx, [originTable, propName]);
          }
          return [types[index], index];
        };

        if (table.errorCause) {
          return table;
        } else if (table.columnNames != null && table.columnTypes != null) {
          const [column, columnIndex] = getFromTableOrRow(
            table.columnNames,
            table.columnTypes
          );
          return t.column(column, table.indexName, columnIndex);
        } else {
          const { rowCellNames, rowCellTypes } = table;
          const [type] = getFromTableOrRow(
            getDefined(rowCellNames),
            getDefined(rowCellTypes)
          );
          return type;
        }
      }
      case 'matrix-ref': {
        return inferMatrixRef(realm, expr);
      }
      case 'function-call': {
        return inferFunctionCall(realm, expr);
      }
      case 'directive': {
        return expandDirectiveToType(realm, expr);
      }
      case 'match':
        return inferMatch(realm, expr);
      case 'tiered':
        return inferTiered(realm, expr);
      case 'function-definition': {
        const [fName] = expr.args;
        const functionName = getIdentifierString(fName);
        const functionType = inferFunctionDefinition(realm, expr).inNode(expr);

        ctx.stack.set(functionName, functionType, realm.statementId);
        return functionType;
      }
    }
  }
);

const inferStatementInternal = linkingToAST(
  async (realm: TRealm, statement: AST.Statement): Promise<Type> => {
    const { inferContext: ctx } = realm;
    switch (statement.type) {
      case 'assign': {
        const [nName, nValue] = statement.args;

        const varName = getIdentifierString(nName);

        const constant = getConstantByName(varName);
        const type =
          constant || ctx.stack.has(varName)
            ? t.impossible(InferError.duplicatedName(varName))
            : await inferExpression(realm, nValue);

        ctx.stack.set(varName, type, realm.statementId);
        return type;
      }
      case 'table': {
        return inferTable(realm, statement);
      }
      case 'table-column-assign': {
        return inferColumnAssign(realm, statement);
      }
      case 'matrix-assign': {
        return inferMatrixAssign(realm, statement);
      }
      case 'categories': {
        return inferCategories(realm, statement);
      }
      default: {
        return inferExpression(realm, statement);
      }
    }
  }
);

export const inferStatement = async (
  ...args: Parameters<typeof inferStatementInternal>
): Promise<Type> => {
  const [realm] = args;
  const { inferContext: ctx } = realm;
  const { usedNames: previoususedNames = [] } = ctx;

  ctx.usedNames = [...previoususedNames];

  const type = await inferStatementInternal(...args);

  // Do not keep track of names retrieved here if we errored out
  if (type.errorCause) {
    ctx.usedNames = previoususedNames;
  }

  return type;
};

export const inferBlock = async (
  block: AST.Block,
  realm: TScopedRealm = new ScopedRealm(undefined, makeInferContext())
): Promise<Type> => {
  if (block.hasDuplicateName) {
    return t.impossible(InferError.duplicatedName(block.hasDuplicateName));
  }
  let last: Type | undefined;
  for (const stmt of block.args) {
    // eslint-disable-next-line no-await-in-loop
    last = await inferStatement(realm, stmt);
  }
  block.inferredType = last;
  return getDefined(last, 'Unexpected empty block');
};

export const inferProgram = async (
  program: AST.Block[],
  realm: TScopedRealm = new ScopedRealm(undefined, makeInferContext())
): Promise<TScopedInferContext> => {
  for (const block of program) {
    // eslint-disable-next-line no-await-in-loop
    await inferBlock(block, realm);
  }
  const { inferContext: ctx } = realm;
  return ctx;
};
