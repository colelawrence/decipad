import { AnyMapping, anyMappingToMap, produce, zip } from '@decipad/utils';
// eslint-disable-next-line no-restricted-imports
import {
  AST,
  ContextUtils,
  Result,
  SerializedType,
  Type,
  buildType as t,
} from '@decipad/language-types';
import { ExternalDataMap } from '..';
import {
  Stack,
  StackNamespaceJoiner,
  StackNamespaceSplitter,
  StackNamespaceRetrieverHackForTypesystemTables,
  VarGroup,
} from '../stack';
import { sortType } from './sortType';
import { ContextStats, initialInferStats } from './inferStats';

type InferContextUtils = Omit<
  ContextUtils,
  'simpleExpressionEvaluate' | 'retrieveVariableValueByGlobalVariableName'
>;

export interface Context {
  stack: Stack<Type>;
  functionDefinitions: Map<string, AST.FunctionDefinition>;
  utils: InferContextUtils;
  previous?: Type;
  inTableBraces?: string | null;
  externalData: ExternalDataMap;
  previousStatement?: SerializedType;
  autoGeneratedVarNames: Set<string>;
  statementId?: string;
  /** Marks names retrieved during typecheck */
  usedNames?: (readonly [string, string])[];
  onGoingFunctionCalls: Set<string>;
  stats: ContextStats;
  clearStats: () => void;
  incrementStatsCounter: (key: keyof ContextStats, howMuch?: number) => void;
}

interface MakeContextArgs {
  initialGlobalScope: AnyMapping<Type>;
  initialTables: AnyMapping<Type>;
  externalData: AnyMapping<Result.Result>;
  autoGeneratedVarNames: Set<string>;
}

export const makeContext = ({
  initialGlobalScope = new Map(),
  externalData = new Map(),
  autoGeneratedVarNames = new Set(),
}: Partial<MakeContextArgs> = {}): Context => {
  // stats
  const stats = initialInferStats();
  const clearStats = () => {
    Object.assign(stats, initialInferStats());
  };
  const incrementStatsCounter = (key: keyof ContextStats, howMuch = 1) => {
    stats[key] += howMuch;
  };

  // stack
  const typesToTable: StackNamespaceJoiner<Type> = (
    tableMapping,
    indexName
  ) => {
    const sortedTable = sortType(
      t.table({
        indexName,
        columnNames: [...tableMapping.keys()],
        columnTypes: [...tableMapping.values()],
      })
    );
    const indexColumnType = sortedTable.columnTypes?.[0];
    if (indexColumnType && indexColumnType.indexedBy) {
      return produce(sortedTable, (table) => {
        table.delegatesIndexTo = indexColumnType.indexedBy;
      });
    }
    return sortedTable;
  };

  const stack = new Stack(
    initialGlobalScope,
    typesToTable,
    tableToTypes,
    getTableColumnAsAGoddamnColumn
  );

  const utils: InferContextUtils = {
    retrieveIndexByName: (indexName: string) =>
      stack.get(indexName, 'function'),
    retrieveVariableTypeByGlobalVariableName: (varName: string) =>
      stack.get(varName),
  };

  return {
    stack,
    functionDefinitions: new Map(),
    externalData: anyMappingToMap(externalData),
    autoGeneratedVarNames,
    usedNames: undefined,
    onGoingFunctionCalls: new Set(),
    utils,
    stats,
    incrementStatsCounter,
    clearStats,
  };
};

const tableToTypes: StackNamespaceSplitter<Type> = (tableMapping) => {
  if (tableMapping.columnNames && tableMapping.columnTypes) {
    return zip(tableMapping.columnNames, tableMapping.columnTypes);
  }
  return undefined;
};

const getTableColumnAsAGoddamnColumn: StackNamespaceRetrieverHackForTypesystemTables<
  Type
> = (column, table) => {
  return t.column(column, table.indexName);
};

/** Push the stack and set Context.previous for the duration of `fn` */
export const pushTableContext = async <T>(
  ctx: Context,
  tableName: string | null,
  fn: () => Promise<T>
): Promise<T> => {
  const previousPrevious = ctx.previous;
  const previousTable = ctx.inTableBraces;
  ctx.inTableBraces = tableName;
  try {
    return await ctx.stack.withPush(async () => {
      ctx.stack.set('first', t.boolean());
      return fn();
    });
  } finally {
    ctx.previous = previousPrevious;
    ctx.inTableBraces = previousTable;
  }
};

export const logRetrievedName = (
  ctx: Context,
  name: string | readonly [string, string],
  group: VarGroup = 'lexical'
) => {
  const nsName = typeof name === 'string' ? (['', name] as const) : name;
  if (ctx.usedNames && ctx.stack.isNameGlobal(nsName, group)) {
    ctx.usedNames.push(nsName);
  }
};

export const logRetrievedFunctionName = (ctx: Context, name: string) => {
  if (ctx.usedNames && ctx.functionDefinitions.has(name)) {
    ctx.usedNames.push(['', name]);
  }
};
