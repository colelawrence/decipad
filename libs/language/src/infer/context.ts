import { AnyMapping, anyMappingToMap, zip } from '@decipad/utils';

import { AST, ExternalDataMap } from '..';
import { Type, SerializedType, buildType as t } from '../type';
import {
  Stack,
  StackNamespaceJoiner,
  StackNamespaceSplitter,
  StackNamespaceRetrieverHackForTypesystemTables,
  VarGroup,
} from '../stack';
import { Result } from '../result';
import { sortType } from './sortType';

export interface Context {
  stack: Stack<Type>;
  functionDefinitions: Map<string, AST.FunctionDefinition>;
  previous?: Type;
  inTableBraces?: string | null;
  externalData: ExternalDataMap;
  previousStatement?: SerializedType;
  autoGeneratedVarNames: Set<string>;
  statementId?: string;
  /** Marks names retrieved during typecheck */
  usedNames?: (readonly [string, string])[];
  onGoingFunctionCalls: Set<string>;
}

interface MakeContextArgs {
  initialGlobalScope: AnyMapping<Type>;
  initialTables: AnyMapping<Type>;
  externalData: AnyMapping<Result>;
  autoGeneratedVarNames: Set<string>;
}

export const makeContext = ({
  initialGlobalScope = new Map(),
  externalData = new Map(),
  autoGeneratedVarNames = new Set(),
}: Partial<MakeContextArgs> = {}): Context => {
  return {
    stack: new Stack(
      initialGlobalScope,
      typesToTable,
      tableToTypes,
      getTableColumnAsAGoddamnColumn
    ),
    functionDefinitions: new Map(),
    externalData: anyMappingToMap(externalData),
    autoGeneratedVarNames,
    usedNames: undefined,
    onGoingFunctionCalls: new Set(),
  };
};

const typesToTable: StackNamespaceJoiner<Type> = (tableMapping, indexName) =>
  sortType(
    t.table({
      indexName,
      columnNames: [...tableMapping.keys()],
      columnTypes: [...tableMapping.values()],
    })
  );

const tableToTypes: StackNamespaceSplitter<Type> = (tableMapping) => {
  if (tableMapping.columnNames && tableMapping.columnTypes) {
    return zip(tableMapping.columnNames, tableMapping.columnTypes);
  }
  return undefined;
};

const getTableColumnAsAGoddamnColumn: StackNamespaceRetrieverHackForTypesystemTables<
  Type
> = (column, table) => {
  return t.column(column, table.indexName);
};

/** Push the stack and set Context.previous for the duration of `fn` */
export const pushTableContext = async <T>(
  ctx: Context,
  tableName: string | null,
  fn: () => Promise<T>
): Promise<T> => {
  const previousPrevious = ctx.previous;
  const previousTable = ctx.inTableBraces;
  ctx.inTableBraces = tableName;
  try {
    return ctx.stack.withPush(async () => {
      ctx.stack.set('first', t.boolean());
      return fn();
    });
  } finally {
    ctx.previous = previousPrevious;
    ctx.inTableBraces = previousTable;
  }
};

export const logRetrievedName = (
  ctx: Context,
  name: string | readonly [string, string],
  group: VarGroup = 'lexical'
) => {
  const nsName = typeof name === 'string' ? (['', name] as const) : name;
  const tableName = nsName[0] === '' ? nsName[1] : nsName[0];
  if (
    ctx.usedNames &&
    ctx.stack.isNameGlobal(nsName, group) &&
    tableName !== ctx.inTableBraces
  ) {
    ctx.usedNames.push(nsName);
  }
};

export const logRetrievedFunctionName = (ctx: Context, name: string) => {
  if (ctx.usedNames && ctx.functionDefinitions.has(name)) {
    ctx.usedNames.push(['', name]);
  }
};
