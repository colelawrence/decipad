import { AnyMapping, anyMappingToMap, zip } from '@decipad/utils';

import { AST, ExternalDataMap } from '..';
import { Type, SerializedType, build as t } from '../type';
import { Stack, StackNamespaceJoiner, StackNamespaceSplitter } from '../stack';
import { Result } from '../result';

export interface Context {
  stack: Stack<Type>;
  functionDefinitions: Map<string, AST.FunctionDefinition>;
  previous?: Type;
  nodeTypes: Map<AST.Node, Type>;
  externalData: ExternalDataMap;
  previousStatement?: SerializedType;
  autoGeneratedVarNames: Set<string>;
}

interface MakeContextArgs {
  initialGlobalScope: AnyMapping<Type>;
  initialTables: AnyMapping<Type>;
  externalData: AnyMapping<Result>;
  autoGeneratedVarNames: Set<string>;
}

export const makeContext = ({
  initialGlobalScope = new Map(),
  externalData = new Map(),
  autoGeneratedVarNames = new Set(),
}: Partial<MakeContextArgs> = {}): Context => {
  return {
    stack: new Stack(initialGlobalScope, typesToTable, tableToTypes),
    functionDefinitions: new Map(),
    nodeTypes: new Map(),
    externalData: anyMappingToMap(externalData),
    autoGeneratedVarNames,
  };
};

const typesToTable: StackNamespaceJoiner<Type> = (tableMapping, indexName) =>
  t.table({
    indexName,
    columnNames: [...tableMapping.keys()],
    columnTypes: [...tableMapping.values()],
  });

const tableToTypes: StackNamespaceSplitter<Type> = (tableMapping) => {
  if (tableMapping.columnNames && tableMapping.columnTypes) {
    return zip(tableMapping.columnNames, tableMapping.columnTypes);
  }
  return undefined;
};

/** Push the stack and set Context.previous for the duration of `fn` */
export const pushStackAndPrevious = async <T>(
  ctx: Context,
  fn: () => Promise<T>
): Promise<T> => {
  const previousPrevious = ctx.previous;
  try {
    return await ctx.stack.withPush(fn);
  } finally {
    ctx.previous = previousPrevious;
  }
};
